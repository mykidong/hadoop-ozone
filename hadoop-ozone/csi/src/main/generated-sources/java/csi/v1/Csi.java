// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csi.proto

package csi.v1;

public final class Csi {
  private Csi() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
    registry.add(csi.v1.Csi.csiSecret);
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface GetPluginInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetPluginInfoRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.GetPluginInfoRequest}
   */
  public  static final class GetPluginInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetPluginInfoRequest)
      GetPluginInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginInfoRequest.newBuilder() to construct.
    private GetPluginInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginInfoRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginInfoRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetPluginInfoRequest.class, csi.v1.Csi.GetPluginInfoRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetPluginInfoRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetPluginInfoRequest other = (csi.v1.Csi.GetPluginInfoRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetPluginInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.GetPluginInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetPluginInfoRequest)
        csi.v1.Csi.GetPluginInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetPluginInfoRequest.class, csi.v1.Csi.GetPluginInfoRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.GetPluginInfoRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoRequest_descriptor;
      }

      public csi.v1.Csi.GetPluginInfoRequest getDefaultInstanceForType() {
        return csi.v1.Csi.GetPluginInfoRequest.getDefaultInstance();
      }

      public csi.v1.Csi.GetPluginInfoRequest build() {
        csi.v1.Csi.GetPluginInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetPluginInfoRequest buildPartial() {
        csi.v1.Csi.GetPluginInfoRequest result = new csi.v1.Csi.GetPluginInfoRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetPluginInfoRequest) {
          return mergeFrom((csi.v1.Csi.GetPluginInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetPluginInfoRequest other) {
        if (other == csi.v1.Csi.GetPluginInfoRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetPluginInfoRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetPluginInfoRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetPluginInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoRequest)
    private static final csi.v1.Csi.GetPluginInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetPluginInfoRequest();
    }

    public static csi.v1.Csi.GetPluginInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginInfoRequest>() {
      public GetPluginInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginInfoRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginInfoRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetPluginInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetPluginInfoResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name MUST follow domain name notation format
     * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
     * include the plugin's host company name and the plugin name,
     * to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name MUST follow domain name notation format
     * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
     * include the plugin's host company name and the plugin name,
     * to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    java.lang.String getVendorVersion();
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    com.google.protobuf.ByteString
        getVendorVersionBytes();

    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    int getManifestCount();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    boolean containsManifest(
        java.lang.String key);
    /**
     * Use {@link #getManifestMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getManifest();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getManifestMap();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    java.lang.String getManifestOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    java.lang.String getManifestOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.GetPluginInfoResponse}
   */
  public  static final class GetPluginInfoResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetPluginInfoResponse)
      GetPluginInfoResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginInfoResponse.newBuilder() to construct.
    private GetPluginInfoResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginInfoResponse() {
      name_ = "";
      vendorVersion_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginInfoResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              vendorVersion_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                manifest_ = com.google.protobuf.MapField.newMapField(
                    ManifestDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              manifest__ = input.readMessage(
                  ManifestDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              manifest_.getMutableMap().put(
                  manifest__.getKey(), manifest__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetManifest();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetPluginInfoResponse.class, csi.v1.Csi.GetPluginInfoResponse.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name MUST follow domain name notation format
     * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
     * include the plugin's host company name and the plugin name,
     * to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name MUST follow domain name notation format
     * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
     * include the plugin's host company name and the plugin name,
     * to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
     * alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VENDOR_VERSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object vendorVersion_;
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    public java.lang.String getVendorVersion() {
      java.lang.Object ref = vendorVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        vendorVersion_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVendorVersionBytes() {
      java.lang.Object ref = vendorVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        vendorVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MANIFEST_FIELD_NUMBER = 3;
    private static final class ManifestDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> manifest_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetManifest() {
      if (manifest_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ManifestDefaultEntryHolder.defaultEntry);
      }
      return manifest_;
    }

    public int getManifestCount() {
      return internalGetManifest().getMap().size();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public boolean containsManifest(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetManifest().getMap().containsKey(key);
    }
    /**
     * Use {@link #getManifestMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getManifest() {
      return getManifestMap();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getManifestMap() {
      return internalGetManifest().getMap();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.lang.String getManifestOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetManifest().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.lang.String getManifestOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetManifest().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!getVendorVersionBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, vendorVersion_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetManifest(),
          ManifestDefaultEntryHolder.defaultEntry,
          3);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!getVendorVersionBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, vendorVersion_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetManifest().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        manifest__ = ManifestDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, manifest__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetPluginInfoResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetPluginInfoResponse other = (csi.v1.Csi.GetPluginInfoResponse) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getVendorVersion()
          .equals(other.getVendorVersion());
      result = result && internalGetManifest().equals(
          other.internalGetManifest());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + VENDOR_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getVendorVersion().hashCode();
      if (!internalGetManifest().getMap().isEmpty()) {
        hash = (37 * hash) + MANIFEST_FIELD_NUMBER;
        hash = (53 * hash) + internalGetManifest().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetPluginInfoResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.GetPluginInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetPluginInfoResponse)
        csi.v1.Csi.GetPluginInfoResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetManifest();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableManifest();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetPluginInfoResponse.class, csi.v1.Csi.GetPluginInfoResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.GetPluginInfoResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        vendorVersion_ = "";

        internalGetMutableManifest().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginInfoResponse_descriptor;
      }

      public csi.v1.Csi.GetPluginInfoResponse getDefaultInstanceForType() {
        return csi.v1.Csi.GetPluginInfoResponse.getDefaultInstance();
      }

      public csi.v1.Csi.GetPluginInfoResponse build() {
        csi.v1.Csi.GetPluginInfoResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetPluginInfoResponse buildPartial() {
        csi.v1.Csi.GetPluginInfoResponse result = new csi.v1.Csi.GetPluginInfoResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        result.vendorVersion_ = vendorVersion_;
        result.manifest_ = internalGetManifest();
        result.manifest_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetPluginInfoResponse) {
          return mergeFrom((csi.v1.Csi.GetPluginInfoResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetPluginInfoResponse other) {
        if (other == csi.v1.Csi.GetPluginInfoResponse.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getVendorVersion().isEmpty()) {
          vendorVersion_ = other.vendorVersion_;
          onChanged();
        }
        internalGetMutableManifest().mergeFrom(
            other.internalGetManifest());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetPluginInfoResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetPluginInfoResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name MUST follow domain name notation format
       * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
       * include the plugin's host company name and the plugin name,
       * to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name MUST follow domain name notation format
       * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
       * include the plugin's host company name and the plugin name,
       * to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name MUST follow domain name notation format
       * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
       * include the plugin's host company name and the plugin name,
       * to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name MUST follow domain name notation format
       * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
       * include the plugin's host company name and the plugin name,
       * to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name MUST follow domain name notation format
       * (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
       * include the plugin's host company name and the plugin name,
       * to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), dots (.), and
       * alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object vendorVersion_ = "";
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public java.lang.String getVendorVersion() {
        java.lang.Object ref = vendorVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          vendorVersion_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public com.google.protobuf.ByteString
          getVendorVersionBytes() {
        java.lang.Object ref = vendorVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          vendorVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder setVendorVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        vendorVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder clearVendorVersion() {
        
        vendorVersion_ = getDefaultInstance().getVendorVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder setVendorVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        vendorVersion_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> manifest_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetManifest() {
        if (manifest_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ManifestDefaultEntryHolder.defaultEntry);
        }
        return manifest_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableManifest() {
        onChanged();;
        if (manifest_ == null) {
          manifest_ = com.google.protobuf.MapField.newMapField(
              ManifestDefaultEntryHolder.defaultEntry);
        }
        if (!manifest_.isMutable()) {
          manifest_ = manifest_.copy();
        }
        return manifest_;
      }

      public int getManifestCount() {
        return internalGetManifest().getMap().size();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public boolean containsManifest(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetManifest().getMap().containsKey(key);
      }
      /**
       * Use {@link #getManifestMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getManifest() {
        return getManifestMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getManifestMap() {
        return internalGetManifest().getMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.lang.String getManifestOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetManifest().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.lang.String getManifestOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetManifest().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearManifest() {
        internalGetMutableManifest().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public Builder removeManifest(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableManifest().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableManifest() {
        return internalGetMutableManifest().getMutableMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */
      public Builder putManifest(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableManifest().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public Builder putAllManifest(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableManifest().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetPluginInfoResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoResponse)
    private static final csi.v1.Csi.GetPluginInfoResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetPluginInfoResponse();
    }

    public static csi.v1.Csi.GetPluginInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginInfoResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginInfoResponse>() {
      public GetPluginInfoResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginInfoResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginInfoResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginInfoResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetPluginInfoResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetPluginCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.GetPluginCapabilitiesRequest}
   */
  public  static final class GetPluginCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetPluginCapabilitiesRequest)
      GetPluginCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginCapabilitiesRequest.newBuilder() to construct.
    private GetPluginCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetPluginCapabilitiesRequest.class, csi.v1.Csi.GetPluginCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetPluginCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetPluginCapabilitiesRequest other = (csi.v1.Csi.GetPluginCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetPluginCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.GetPluginCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetPluginCapabilitiesRequest)
        csi.v1.Csi.GetPluginCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetPluginCapabilitiesRequest.class, csi.v1.Csi.GetPluginCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.GetPluginCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor;
      }

      public csi.v1.Csi.GetPluginCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v1.Csi.GetPluginCapabilitiesRequest.getDefaultInstance();
      }

      public csi.v1.Csi.GetPluginCapabilitiesRequest build() {
        csi.v1.Csi.GetPluginCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetPluginCapabilitiesRequest buildPartial() {
        csi.v1.Csi.GetPluginCapabilitiesRequest result = new csi.v1.Csi.GetPluginCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetPluginCapabilitiesRequest) {
          return mergeFrom((csi.v1.Csi.GetPluginCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetPluginCapabilitiesRequest other) {
        if (other == csi.v1.Csi.GetPluginCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetPluginCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetPluginCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetPluginCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesRequest)
    private static final csi.v1.Csi.GetPluginCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetPluginCapabilitiesRequest();
    }

    public static csi.v1.Csi.GetPluginCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginCapabilitiesRequest>() {
      public GetPluginCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetPluginCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetPluginCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    java.util.List<csi.v1.Csi.PluginCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    csi.v1.Csi.PluginCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.PluginCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    csi.v1.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v1.GetPluginCapabilitiesResponse}
   */
  public  static final class GetPluginCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetPluginCapabilitiesResponse)
      GetPluginCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginCapabilitiesResponse.newBuilder() to construct.
    private GetPluginCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v1.Csi.PluginCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v1.Csi.PluginCapability.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetPluginCapabilitiesResponse.class, csi.v1.Csi.GetPluginCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.PluginCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    public java.util.List<csi.v1.Csi.PluginCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.PluginCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.PluginCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(1, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetPluginCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetPluginCapabilitiesResponse other = (csi.v1.Csi.GetPluginCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetPluginCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.GetPluginCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetPluginCapabilitiesResponse)
        csi.v1.Csi.GetPluginCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetPluginCapabilitiesResponse.class, csi.v1.Csi.GetPluginCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.GetPluginCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor;
      }

      public csi.v1.Csi.GetPluginCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v1.Csi.GetPluginCapabilitiesResponse.getDefaultInstance();
      }

      public csi.v1.Csi.GetPluginCapabilitiesResponse build() {
        csi.v1.Csi.GetPluginCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetPluginCapabilitiesResponse buildPartial() {
        csi.v1.Csi.GetPluginCapabilitiesResponse result = new csi.v1.Csi.GetPluginCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetPluginCapabilitiesResponse) {
          return mergeFrom((csi.v1.Csi.GetPluginCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetPluginCapabilitiesResponse other) {
        if (other == csi.v1.Csi.GetPluginCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetPluginCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetPluginCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.PluginCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v1.Csi.PluginCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.PluginCapability, csi.v1.Csi.PluginCapability.Builder, csi.v1.Csi.PluginCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.PluginCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.PluginCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(csi.v1.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          csi.v1.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.PluginCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.PluginCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.PluginCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.PluginCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.PluginCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.PluginCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.PluginCapability, csi.v1.Csi.PluginCapability.Builder, csi.v1.Csi.PluginCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.PluginCapability, csi.v1.Csi.PluginCapability.Builder, csi.v1.Csi.PluginCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetPluginCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesResponse)
    private static final csi.v1.Csi.GetPluginCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetPluginCapabilitiesResponse();
    }

    public static csi.v1.Csi.GetPluginCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginCapabilitiesResponse>() {
      public GetPluginCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetPluginCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PluginCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.PluginCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    boolean hasService();
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    csi.v1.Csi.PluginCapability.Service getService();
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    csi.v1.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder();

    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    boolean hasVolumeExpansion();
    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    csi.v1.Csi.PluginCapability.VolumeExpansion getVolumeExpansion();
    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder getVolumeExpansionOrBuilder();

    public csi.v1.Csi.PluginCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the plugin.
   * </pre>
   *
   * Protobuf type {@code csi.v1.PluginCapability}
   */
  public  static final class PluginCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.PluginCapability)
      PluginCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PluginCapability.newBuilder() to construct.
    private PluginCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PluginCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PluginCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.PluginCapability.Service.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v1.Csi.PluginCapability.Service) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.PluginCapability.Service.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.PluginCapability.Service) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            case 18: {
              csi.v1.Csi.PluginCapability.VolumeExpansion.Builder subBuilder = null;
              if (typeCase_ == 2) {
                subBuilder = ((csi.v1.Csi.PluginCapability.VolumeExpansion) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.PluginCapability.VolumeExpansion.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.PluginCapability.VolumeExpansion) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 2;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_PluginCapability_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_PluginCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.PluginCapability.class, csi.v1.Csi.PluginCapability.Builder.class);
    }

    public interface ServiceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.PluginCapability.Service)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
       */
      csi.v1.Csi.PluginCapability.Service.Type getType();
    }
    /**
     * Protobuf type {@code csi.v1.PluginCapability.Service}
     */
    public  static final class Service extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.PluginCapability.Service)
        ServiceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Service.newBuilder() to construct.
      private Service(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Service() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Service(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_Service_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_Service_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.PluginCapability.Service.class, csi.v1.Csi.PluginCapability.Service.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v1.PluginCapability.Service.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <pre>
         * CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
         * the ControllerService. Plugins SHOULD provide this capability.
         * In rare cases certain plugins MAY wish to omit the
         * ControllerService entirely from their implementation, but such
         * SHOULD NOT be the common case.
         * The presence of this capability determines whether the CO will
         * attempt to invoke the REQUIRED ControllerService RPCs, as well
         * as specific RPCs as indicated by ControllerGetCapabilities.
         * </pre>
         *
         * <code>CONTROLLER_SERVICE = 1;</code>
         */
        CONTROLLER_SERVICE(1),
        /**
         * <pre>
         * VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
         * this plugin MAY NOT be equally accessible by all nodes in the
         * cluster. The CO MUST use the topology information returned by
         * CreateVolumeRequest along with the topology information
         * returned by NodeGetInfo to ensure that a given volume is
         * accessible from a given node when scheduling workloads.
         * </pre>
         *
         * <code>VOLUME_ACCESSIBILITY_CONSTRAINTS = 2;</code>
         */
        VOLUME_ACCESSIBILITY_CONSTRAINTS(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <pre>
         * CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
         * the ControllerService. Plugins SHOULD provide this capability.
         * In rare cases certain plugins MAY wish to omit the
         * ControllerService entirely from their implementation, but such
         * SHOULD NOT be the common case.
         * The presence of this capability determines whether the CO will
         * attempt to invoke the REQUIRED ControllerService RPCs, as well
         * as specific RPCs as indicated by ControllerGetCapabilities.
         * </pre>
         *
         * <code>CONTROLLER_SERVICE = 1;</code>
         */
        public static final int CONTROLLER_SERVICE_VALUE = 1;
        /**
         * <pre>
         * VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
         * this plugin MAY NOT be equally accessible by all nodes in the
         * cluster. The CO MUST use the topology information returned by
         * CreateVolumeRequest along with the topology information
         * returned by NodeGetInfo to ensure that a given volume is
         * accessible from a given node when scheduling workloads.
         * </pre>
         *
         * <code>VOLUME_ACCESSIBILITY_CONSTRAINTS = 2;</code>
         */
        public static final int VOLUME_ACCESSIBILITY_CONSTRAINTS_VALUE = 2;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return CONTROLLER_SERVICE;
            case 2: return VOLUME_ACCESSIBILITY_CONSTRAINTS;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v1.Csi.PluginCapability.Service.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v1.PluginCapability.Service.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Service.Type getType() {
        csi.v1.Csi.PluginCapability.Service.Type result = csi.v1.Csi.PluginCapability.Service.Type.valueOf(type_);
        return result == null ? csi.v1.Csi.PluginCapability.Service.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v1.Csi.PluginCapability.Service.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v1.Csi.PluginCapability.Service.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.PluginCapability.Service)) {
          return super.equals(obj);
        }
        csi.v1.Csi.PluginCapability.Service other = (csi.v1.Csi.PluginCapability.Service) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.Service parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.Service parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.PluginCapability.Service prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.PluginCapability.Service}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.PluginCapability.Service)
          csi.v1.Csi.PluginCapability.ServiceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_Service_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_Service_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.PluginCapability.Service.class, csi.v1.Csi.PluginCapability.Service.Builder.class);
        }

        // Construct using csi.v1.Csi.PluginCapability.Service.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_Service_descriptor;
        }

        public csi.v1.Csi.PluginCapability.Service getDefaultInstanceForType() {
          return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
        }

        public csi.v1.Csi.PluginCapability.Service build() {
          csi.v1.Csi.PluginCapability.Service result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.PluginCapability.Service buildPartial() {
          csi.v1.Csi.PluginCapability.Service result = new csi.v1.Csi.PluginCapability.Service(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.PluginCapability.Service) {
            return mergeFrom((csi.v1.Csi.PluginCapability.Service)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.PluginCapability.Service other) {
          if (other == csi.v1.Csi.PluginCapability.Service.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.PluginCapability.Service parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.PluginCapability.Service) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
         */
        public csi.v1.Csi.PluginCapability.Service.Type getType() {
          csi.v1.Csi.PluginCapability.Service.Type result = csi.v1.Csi.PluginCapability.Service.Type.valueOf(type_);
          return result == null ? csi.v1.Csi.PluginCapability.Service.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder setType(csi.v1.Csi.PluginCapability.Service.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.PluginCapability.Service)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.Service)
      private static final csi.v1.Csi.PluginCapability.Service DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.PluginCapability.Service();
      }

      public static csi.v1.Csi.PluginCapability.Service getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Service>
          PARSER = new com.google.protobuf.AbstractParser<Service>() {
        public Service parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Service(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Service> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Service> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.PluginCapability.Service getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface VolumeExpansionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.PluginCapability.VolumeExpansion)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * Protobuf type {@code csi.v1.PluginCapability.VolumeExpansion}
     */
    public  static final class VolumeExpansion extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.PluginCapability.VolumeExpansion)
        VolumeExpansionOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use VolumeExpansion.newBuilder() to construct.
      private VolumeExpansion(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private VolumeExpansion() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private VolumeExpansion(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_VolumeExpansion_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.PluginCapability.VolumeExpansion.class, csi.v1.Csi.PluginCapability.VolumeExpansion.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v1.PluginCapability.VolumeExpansion.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <pre>
         * ONLINE indicates that volumes may be expanded when published to
         * a node. When a Plugin implements this capability it MUST
         * implement either the EXPAND_VOLUME controller capability or the
         * EXPAND_VOLUME node capability or both. When a plugin supports
         * ONLINE volume expansion and also has the EXPAND_VOLUME
         * controller capability then the plugin MUST support expansion of
         * volumes currently published and available on a node. When a
         * plugin supports ONLINE volume expansion and also has the
         * EXPAND_VOLUME node capability then the plugin MAY support
         * expansion of node-published volume via NodeExpandVolume.
         * Example 1: Given a shared filesystem volume (e.g. GlusterFs),
         *   the Plugin may set the ONLINE volume expansion capability and
         *   implement ControllerExpandVolume but not NodeExpandVolume.
         * Example 2: Given a block storage volume type (e.g. EBS), the
         *   Plugin may set the ONLINE volume expansion capability and
         *   implement both ControllerExpandVolume and NodeExpandVolume.
         * Example 3: Given a Plugin that supports volume expansion only
         *   upon a node, the Plugin may set the ONLINE volume
         *   expansion capability and implement NodeExpandVolume but not
         *   ControllerExpandVolume.
         * </pre>
         *
         * <code>ONLINE = 1;</code>
         */
        ONLINE(1),
        /**
         * <pre>
         * OFFLINE indicates that volumes currently published and
         * available on a node SHALL NOT be expanded via
         * ControllerExpandVolume. When a plugin supports OFFLINE volume
         * expansion it MUST implement either the EXPAND_VOLUME controller
         * capability or both the EXPAND_VOLUME controller capability and
         * the EXPAND_VOLUME node capability.
         * Example 1: Given a block storage volume type (e.g. Azure Disk)
         *   that does not support expansion of "node-attached" (i.e.
         *   controller-published) volumes, the Plugin may indicate
         *   OFFLINE volume expansion support and implement both
         *   ControllerExpandVolume and NodeExpandVolume.
         * </pre>
         *
         * <code>OFFLINE = 2;</code>
         */
        OFFLINE(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <pre>
         * ONLINE indicates that volumes may be expanded when published to
         * a node. When a Plugin implements this capability it MUST
         * implement either the EXPAND_VOLUME controller capability or the
         * EXPAND_VOLUME node capability or both. When a plugin supports
         * ONLINE volume expansion and also has the EXPAND_VOLUME
         * controller capability then the plugin MUST support expansion of
         * volumes currently published and available on a node. When a
         * plugin supports ONLINE volume expansion and also has the
         * EXPAND_VOLUME node capability then the plugin MAY support
         * expansion of node-published volume via NodeExpandVolume.
         * Example 1: Given a shared filesystem volume (e.g. GlusterFs),
         *   the Plugin may set the ONLINE volume expansion capability and
         *   implement ControllerExpandVolume but not NodeExpandVolume.
         * Example 2: Given a block storage volume type (e.g. EBS), the
         *   Plugin may set the ONLINE volume expansion capability and
         *   implement both ControllerExpandVolume and NodeExpandVolume.
         * Example 3: Given a Plugin that supports volume expansion only
         *   upon a node, the Plugin may set the ONLINE volume
         *   expansion capability and implement NodeExpandVolume but not
         *   ControllerExpandVolume.
         * </pre>
         *
         * <code>ONLINE = 1;</code>
         */
        public static final int ONLINE_VALUE = 1;
        /**
         * <pre>
         * OFFLINE indicates that volumes currently published and
         * available on a node SHALL NOT be expanded via
         * ControllerExpandVolume. When a plugin supports OFFLINE volume
         * expansion it MUST implement either the EXPAND_VOLUME controller
         * capability or both the EXPAND_VOLUME controller capability and
         * the EXPAND_VOLUME node capability.
         * Example 1: Given a block storage volume type (e.g. Azure Disk)
         *   that does not support expansion of "node-attached" (i.e.
         *   controller-published) volumes, the Plugin may indicate
         *   OFFLINE volume expansion support and implement both
         *   ControllerExpandVolume and NodeExpandVolume.
         * </pre>
         *
         * <code>OFFLINE = 2;</code>
         */
        public static final int OFFLINE_VALUE = 2;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return ONLINE;
            case 2: return OFFLINE;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v1.Csi.PluginCapability.VolumeExpansion.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v1.PluginCapability.VolumeExpansion.Type)
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.PluginCapability.VolumeExpansion)) {
          return super.equals(obj);
        }
        csi.v1.Csi.PluginCapability.VolumeExpansion other = (csi.v1.Csi.PluginCapability.VolumeExpansion) obj;

        boolean result = true;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.PluginCapability.VolumeExpansion parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.PluginCapability.VolumeExpansion prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.PluginCapability.VolumeExpansion}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.PluginCapability.VolumeExpansion)
          csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_VolumeExpansion_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.PluginCapability.VolumeExpansion.class, csi.v1.Csi.PluginCapability.VolumeExpansion.Builder.class);
        }

        // Construct using csi.v1.Csi.PluginCapability.VolumeExpansion.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor;
        }

        public csi.v1.Csi.PluginCapability.VolumeExpansion getDefaultInstanceForType() {
          return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
        }

        public csi.v1.Csi.PluginCapability.VolumeExpansion build() {
          csi.v1.Csi.PluginCapability.VolumeExpansion result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.PluginCapability.VolumeExpansion buildPartial() {
          csi.v1.Csi.PluginCapability.VolumeExpansion result = new csi.v1.Csi.PluginCapability.VolumeExpansion(this);
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.PluginCapability.VolumeExpansion) {
            return mergeFrom((csi.v1.Csi.PluginCapability.VolumeExpansion)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.PluginCapability.VolumeExpansion other) {
          if (other == csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.PluginCapability.VolumeExpansion parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.PluginCapability.VolumeExpansion) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.PluginCapability.VolumeExpansion)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.VolumeExpansion)
      private static final csi.v1.Csi.PluginCapability.VolumeExpansion DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.PluginCapability.VolumeExpansion();
      }

      public static csi.v1.Csi.PluginCapability.VolumeExpansion getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<VolumeExpansion>
          PARSER = new com.google.protobuf.AbstractParser<VolumeExpansion>() {
        public VolumeExpansion parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new VolumeExpansion(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<VolumeExpansion> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<VolumeExpansion> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.PluginCapability.VolumeExpansion getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      SERVICE(1),
      VOLUME_EXPANSION(2),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return SERVICE;
          case 2: return VOLUME_EXPANSION;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    public boolean hasService() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    public csi.v1.Csi.PluginCapability.Service getService() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.PluginCapability.Service) type_;
      }
      return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
    }
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v1.PluginCapability.Service service = 1;</code>
     */
    public csi.v1.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.PluginCapability.Service) type_;
      }
      return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
    }

    public static final int VOLUME_EXPANSION_FIELD_NUMBER = 2;
    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    public boolean hasVolumeExpansion() {
      return typeCase_ == 2;
    }
    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    public csi.v1.Csi.PluginCapability.VolumeExpansion getVolumeExpansion() {
      if (typeCase_ == 2) {
         return (csi.v1.Csi.PluginCapability.VolumeExpansion) type_;
      }
      return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
    }
    /**
     * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
     */
    public csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder getVolumeExpansionOrBuilder() {
      if (typeCase_ == 2) {
         return (csi.v1.Csi.PluginCapability.VolumeExpansion) type_;
      }
      return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v1.Csi.PluginCapability.Service) type_);
      }
      if (typeCase_ == 2) {
        output.writeMessage(2, (csi.v1.Csi.PluginCapability.VolumeExpansion) type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v1.Csi.PluginCapability.Service) type_);
      }
      if (typeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (csi.v1.Csi.PluginCapability.VolumeExpansion) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.PluginCapability)) {
        return super.equals(obj);
      }
      csi.v1.Csi.PluginCapability other = (csi.v1.Csi.PluginCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getService()
              .equals(other.getService());
          break;
        case 2:
          result = result && getVolumeExpansion()
              .equals(other.getVolumeExpansion());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + SERVICE_FIELD_NUMBER;
          hash = (53 * hash) + getService().hashCode();
          break;
        case 2:
          hash = (37 * hash) + VOLUME_EXPANSION_FIELD_NUMBER;
          hash = (53 * hash) + getVolumeExpansion().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.PluginCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.PluginCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.PluginCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.PluginCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.PluginCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the plugin.
     * </pre>
     *
     * Protobuf type {@code csi.v1.PluginCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.PluginCapability)
        csi.v1.Csi.PluginCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.PluginCapability.class, csi.v1.Csi.PluginCapability.Builder.class);
      }

      // Construct using csi.v1.Csi.PluginCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_PluginCapability_descriptor;
      }

      public csi.v1.Csi.PluginCapability getDefaultInstanceForType() {
        return csi.v1.Csi.PluginCapability.getDefaultInstance();
      }

      public csi.v1.Csi.PluginCapability build() {
        csi.v1.Csi.PluginCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.PluginCapability buildPartial() {
        csi.v1.Csi.PluginCapability result = new csi.v1.Csi.PluginCapability(this);
        if (typeCase_ == 1) {
          if (serviceBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = serviceBuilder_.build();
          }
        }
        if (typeCase_ == 2) {
          if (volumeExpansionBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = volumeExpansionBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.PluginCapability) {
          return mergeFrom((csi.v1.Csi.PluginCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.PluginCapability other) {
        if (other == csi.v1.Csi.PluginCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case SERVICE: {
            mergeService(other.getService());
            break;
          }
          case VOLUME_EXPANSION: {
            mergeVolumeExpansion(other.getVolumeExpansion());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.PluginCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.PluginCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.PluginCapability.Service, csi.v1.Csi.PluginCapability.Service.Builder, csi.v1.Csi.PluginCapability.ServiceOrBuilder> serviceBuilder_;
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public boolean hasService() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Service getService() {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.PluginCapability.Service) type_;
          }
          return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return serviceBuilder_.getMessage();
          }
          return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public Builder setService(csi.v1.Csi.PluginCapability.Service value) {
        if (serviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          serviceBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public Builder setService(
          csi.v1.Csi.PluginCapability.Service.Builder builderForValue) {
        if (serviceBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          serviceBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public Builder mergeService(csi.v1.Csi.PluginCapability.Service value) {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v1.Csi.PluginCapability.Service.getDefaultInstance()) {
            type_ = csi.v1.Csi.PluginCapability.Service.newBuilder((csi.v1.Csi.PluginCapability.Service) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            serviceBuilder_.mergeFrom(value);
          }
          serviceBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public Builder clearService() {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          serviceBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.Service.Builder getServiceBuilder() {
        return getServiceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      public csi.v1.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder() {
        if ((typeCase_ == 1) && (serviceBuilder_ != null)) {
          return serviceBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.PluginCapability.Service) type_;
          }
          return csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v1.PluginCapability.Service service = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.PluginCapability.Service, csi.v1.Csi.PluginCapability.Service.Builder, csi.v1.Csi.PluginCapability.ServiceOrBuilder> 
          getServiceFieldBuilder() {
        if (serviceBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v1.Csi.PluginCapability.Service.getDefaultInstance();
          }
          serviceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.PluginCapability.Service, csi.v1.Csi.PluginCapability.Service.Builder, csi.v1.Csi.PluginCapability.ServiceOrBuilder>(
                  (csi.v1.Csi.PluginCapability.Service) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return serviceBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.PluginCapability.VolumeExpansion, csi.v1.Csi.PluginCapability.VolumeExpansion.Builder, csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder> volumeExpansionBuilder_;
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public boolean hasVolumeExpansion() {
        return typeCase_ == 2;
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public csi.v1.Csi.PluginCapability.VolumeExpansion getVolumeExpansion() {
        if (volumeExpansionBuilder_ == null) {
          if (typeCase_ == 2) {
            return (csi.v1.Csi.PluginCapability.VolumeExpansion) type_;
          }
          return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
        } else {
          if (typeCase_ == 2) {
            return volumeExpansionBuilder_.getMessage();
          }
          return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public Builder setVolumeExpansion(csi.v1.Csi.PluginCapability.VolumeExpansion value) {
        if (volumeExpansionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          volumeExpansionBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public Builder setVolumeExpansion(
          csi.v1.Csi.PluginCapability.VolumeExpansion.Builder builderForValue) {
        if (volumeExpansionBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          volumeExpansionBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public Builder mergeVolumeExpansion(csi.v1.Csi.PluginCapability.VolumeExpansion value) {
        if (volumeExpansionBuilder_ == null) {
          if (typeCase_ == 2 &&
              type_ != csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance()) {
            type_ = csi.v1.Csi.PluginCapability.VolumeExpansion.newBuilder((csi.v1.Csi.PluginCapability.VolumeExpansion) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 2) {
            volumeExpansionBuilder_.mergeFrom(value);
          }
          volumeExpansionBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public Builder clearVolumeExpansion() {
        if (volumeExpansionBuilder_ == null) {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
          }
          volumeExpansionBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public csi.v1.Csi.PluginCapability.VolumeExpansion.Builder getVolumeExpansionBuilder() {
        return getVolumeExpansionFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      public csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder getVolumeExpansionOrBuilder() {
        if ((typeCase_ == 2) && (volumeExpansionBuilder_ != null)) {
          return volumeExpansionBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 2) {
            return (csi.v1.Csi.PluginCapability.VolumeExpansion) type_;
          }
          return csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.PluginCapability.VolumeExpansion, csi.v1.Csi.PluginCapability.VolumeExpansion.Builder, csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder> 
          getVolumeExpansionFieldBuilder() {
        if (volumeExpansionBuilder_ == null) {
          if (!(typeCase_ == 2)) {
            type_ = csi.v1.Csi.PluginCapability.VolumeExpansion.getDefaultInstance();
          }
          volumeExpansionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.PluginCapability.VolumeExpansion, csi.v1.Csi.PluginCapability.VolumeExpansion.Builder, csi.v1.Csi.PluginCapability.VolumeExpansionOrBuilder>(
                  (csi.v1.Csi.PluginCapability.VolumeExpansion) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 2;
        onChanged();;
        return volumeExpansionBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.PluginCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability)
    private static final csi.v1.Csi.PluginCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.PluginCapability();
    }

    public static csi.v1.Csi.PluginCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PluginCapability>
        PARSER = new com.google.protobuf.AbstractParser<PluginCapability>() {
      public PluginCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PluginCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PluginCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PluginCapability> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.PluginCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ProbeRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.ProbeRequest}
   */
  public  static final class ProbeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ProbeRequest)
      ProbeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeRequest.newBuilder() to construct.
    private ProbeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ProbeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ProbeRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ProbeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ProbeRequest.class, csi.v1.Csi.ProbeRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ProbeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ProbeRequest other = (csi.v1.Csi.ProbeRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ProbeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ProbeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.ProbeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ProbeRequest)
        csi.v1.Csi.ProbeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ProbeRequest.class, csi.v1.Csi.ProbeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ProbeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeRequest_descriptor;
      }

      public csi.v1.Csi.ProbeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ProbeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ProbeRequest build() {
        csi.v1.Csi.ProbeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ProbeRequest buildPartial() {
        csi.v1.Csi.ProbeRequest result = new csi.v1.Csi.ProbeRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ProbeRequest) {
          return mergeFrom((csi.v1.Csi.ProbeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ProbeRequest other) {
        if (other == csi.v1.Csi.ProbeRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ProbeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ProbeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ProbeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ProbeRequest)
    private static final csi.v1.Csi.ProbeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ProbeRequest();
    }

    public static csi.v1.Csi.ProbeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ProbeRequest>() {
      public ProbeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ProbeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProbeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ProbeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ProbeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    boolean hasReady();
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    com.google.protobuf.BoolValue getReady();
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.ProbeResponse}
   */
  public  static final class ProbeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ProbeResponse)
      ProbeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeResponse.newBuilder() to construct.
    private ProbeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ProbeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (ready_ != null) {
                subBuilder = ready_.toBuilder();
              }
              ready_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ready_);
                ready_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ProbeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ProbeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ProbeResponse.class, csi.v1.Csi.ProbeResponse.Builder.class);
    }

    public static final int READY_FIELD_NUMBER = 1;
    private com.google.protobuf.BoolValue ready_;
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public boolean hasReady() {
      return ready_ != null;
    }
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public com.google.protobuf.BoolValue getReady() {
      return ready_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
    }
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder() {
      return getReady();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (ready_ != null) {
        output.writeMessage(1, getReady());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (ready_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getReady());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ProbeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ProbeResponse other = (csi.v1.Csi.ProbeResponse) obj;

      boolean result = true;
      result = result && (hasReady() == other.hasReady());
      if (hasReady()) {
        result = result && getReady()
            .equals(other.getReady());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReady()) {
        hash = (37 * hash) + READY_FIELD_NUMBER;
        hash = (53 * hash) + getReady().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ProbeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ProbeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ProbeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ProbeResponse)
        csi.v1.Csi.ProbeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ProbeResponse.class, csi.v1.Csi.ProbeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ProbeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (readyBuilder_ == null) {
          ready_ = null;
        } else {
          ready_ = null;
          readyBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ProbeResponse_descriptor;
      }

      public csi.v1.Csi.ProbeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ProbeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ProbeResponse build() {
        csi.v1.Csi.ProbeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ProbeResponse buildPartial() {
        csi.v1.Csi.ProbeResponse result = new csi.v1.Csi.ProbeResponse(this);
        if (readyBuilder_ == null) {
          result.ready_ = ready_;
        } else {
          result.ready_ = readyBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ProbeResponse) {
          return mergeFrom((csi.v1.Csi.ProbeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ProbeResponse other) {
        if (other == csi.v1.Csi.ProbeResponse.getDefaultInstance()) return this;
        if (other.hasReady()) {
          mergeReady(other.getReady());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ProbeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ProbeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.BoolValue ready_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> readyBuilder_;
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public boolean hasReady() {
        return readyBuilder_ != null || ready_ != null;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValue getReady() {
        if (readyBuilder_ == null) {
          return ready_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
        } else {
          return readyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder setReady(com.google.protobuf.BoolValue value) {
        if (readyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ready_ = value;
          onChanged();
        } else {
          readyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder setReady(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (readyBuilder_ == null) {
          ready_ = builderForValue.build();
          onChanged();
        } else {
          readyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder mergeReady(com.google.protobuf.BoolValue value) {
        if (readyBuilder_ == null) {
          if (ready_ != null) {
            ready_ =
              com.google.protobuf.BoolValue.newBuilder(ready_).mergeFrom(value).buildPartial();
          } else {
            ready_ = value;
          }
          onChanged();
        } else {
          readyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder clearReady() {
        if (readyBuilder_ == null) {
          ready_ = null;
          onChanged();
        } else {
          ready_ = null;
          readyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValue.Builder getReadyBuilder() {
        
        onChanged();
        return getReadyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder() {
        if (readyBuilder_ != null) {
          return readyBuilder_.getMessageOrBuilder();
        } else {
          return ready_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
        }
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getReadyFieldBuilder() {
        if (readyBuilder_ == null) {
          readyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getReady(),
                  getParentForChildren(),
                  isClean());
          ready_ = null;
        }
        return readyBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ProbeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ProbeResponse)
    private static final csi.v1.Csi.ProbeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ProbeResponse();
    }

    public static csi.v1.Csi.ProbeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ProbeResponse>() {
      public ProbeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ProbeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProbeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ProbeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.CreateVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency.  The Plugin SHOULD ensure that multiple
     *    `CreateVolume` calls for the same name do not result in more
     *    than one piece of storage provisioned corresponding to that
     *    name. If a Plugin is unable to enforce idempotency, the CO's
     *    error recovery logic could result in multiple (unused) volumes
     *    being provisioned.
     *    In the case of error, the CO MUST handle the gRPC error codes
     *    per the recovery behavior defined in the "CreateVolume Errors"
     *    section below.
     *    The CO is responsible for cleaning up volumes it provisioned
     *    that it no longer needs. If the CO is uncertain whether a volume
     *    was provisioned or not when a `CreateVolume` call fails, the CO
     *    MAY call `CreateVolume` again, with the same name, to ensure the
     *    volume exists and to retrieve the volume's `volume_id` (unless
     *    otherwise prohibited by "CreateVolume Errors").
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency.  The Plugin SHOULD ensure that multiple
     *    `CreateVolume` calls for the same name do not result in more
     *    than one piece of storage provisioned corresponding to that
     *    name. If a Plugin is unable to enforce idempotency, the CO's
     *    error recovery logic could result in multiple (unused) volumes
     *    being provisioned.
     *    In the case of error, the CO MUST handle the gRPC error codes
     *    per the recovery behavior defined in the "CreateVolume Errors"
     *    section below.
     *    The CO is responsible for cleaning up volumes it provisioned
     *    that it no longer needs. If the CO is uncertain whether a volume
     *    was provisioned or not when a `CreateVolume` call fails, the CO
     *    MAY call `CreateVolume` again, with the same name, to ensure the
     *    volume exists and to retrieve the volume's `volume_id` (unless
     *    otherwise prohibited by "CreateVolume Errors").
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    boolean hasCapacityRange();
    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    csi.v1.Csi.CapacityRange getCapacityRange();
    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder();

    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<csi.v1.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    boolean hasVolumeContentSource();
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    csi.v1.Csi.VolumeContentSource getVolumeContentSource();
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    csi.v1.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    boolean hasAccessibilityRequirements();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    csi.v1.Csi.TopologyRequirement getAccessibilityRequirements();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    csi.v1.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.CreateVolumeRequest}
   */
  public  static final class CreateVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.CreateVolumeRequest)
      CreateVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateVolumeRequest.newBuilder() to construct.
    private CreateVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateVolumeRequest() {
      name_ = "";
      volumeCapabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              csi.v1.Csi.CapacityRange.Builder subBuilder = null;
              if (capacityRange_ != null) {
                subBuilder = capacityRange_.toBuilder();
              }
              capacityRange_ = input.readMessage(csi.v1.Csi.CapacityRange.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(capacityRange_);
                capacityRange_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000004;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
            case 50: {
              csi.v1.Csi.VolumeContentSource.Builder subBuilder = null;
              if (volumeContentSource_ != null) {
                subBuilder = volumeContentSource_.toBuilder();
              }
              volumeContentSource_ = input.readMessage(csi.v1.Csi.VolumeContentSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeContentSource_);
                volumeContentSource_ = subBuilder.buildPartial();
              }

              break;
            }
            case 58: {
              csi.v1.Csi.TopologyRequirement.Builder subBuilder = null;
              if (accessibilityRequirements_ != null) {
                subBuilder = accessibilityRequirements_.toBuilder();
              }
              accessibilityRequirements_ = input.readMessage(csi.v1.Csi.TopologyRequirement.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibilityRequirements_);
                accessibilityRequirements_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 4:
          return internalGetParameters();
        case 5:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.CreateVolumeRequest.class, csi.v1.Csi.CreateVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency.  The Plugin SHOULD ensure that multiple
     *    `CreateVolume` calls for the same name do not result in more
     *    than one piece of storage provisioned corresponding to that
     *    name. If a Plugin is unable to enforce idempotency, the CO's
     *    error recovery logic could result in multiple (unused) volumes
     *    being provisioned.
     *    In the case of error, the CO MUST handle the gRPC error codes
     *    per the recovery behavior defined in the "CreateVolume Errors"
     *    section below.
     *    The CO is responsible for cleaning up volumes it provisioned
     *    that it no longer needs. If the CO is uncertain whether a volume
     *    was provisioned or not when a `CreateVolume` call fails, the CO
     *    MAY call `CreateVolume` again, with the same name, to ensure the
     *    volume exists and to retrieve the volume's `volume_id` (unless
     *    otherwise prohibited by "CreateVolume Errors").
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency.  The Plugin SHOULD ensure that multiple
     *    `CreateVolume` calls for the same name do not result in more
     *    than one piece of storage provisioned corresponding to that
     *    name. If a Plugin is unable to enforce idempotency, the CO's
     *    error recovery logic could result in multiple (unused) volumes
     *    being provisioned.
     *    In the case of error, the CO MUST handle the gRPC error codes
     *    per the recovery behavior defined in the "CreateVolume Errors"
     *    section below.
     *    The CO is responsible for cleaning up volumes it provisioned
     *    that it no longer needs. If the CO is uncertain whether a volume
     *    was provisioned or not when a `CreateVolume` call fails, the CO
     *    MAY call `CreateVolume` again, with the same name, to ensure the
     *    volume exists and to retrieve the volume's `volume_id` (unless
     *    otherwise prohibited by "CreateVolume Errors").
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAPACITY_RANGE_FIELD_NUMBER = 2;
    private csi.v1.Csi.CapacityRange capacityRange_;
    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public boolean hasCapacityRange() {
      return capacityRange_ != null;
    }
    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public csi.v1.Csi.CapacityRange getCapacityRange() {
      return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
    }
    /**
     * <pre>
     * This field is OPTIONAL. This allows the CO to specify the capacity
     * requirement of the volume to be provisioned. If not specified, the
     * Plugin MAY choose an implementation-defined capacity range. If
     * specified it MUST always be honored, even when creating volumes
     * from a source; which MAY force some backends to internally extend
     * the volume after creating it.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
      return getCapacityRange();
    }

    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 3;
    private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have. SP MUST
     * provision a volume that will satisfy ALL of the capabilities
     * specified in this list. Otherwise SP MUST return the appropriate
     * gRPC error code.
     * The Plugin MUST assume that the CO MAY use the provisioned volume
     * with ANY of the capabilities specified in this list.
     * For example, a CO MAY specify two volume capabilities: one with
     * access mode SINGLE_NODE_WRITER and another with access mode
     * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
     * provisioned volume can be used in either mode.
     * This also enables the CO to do early validation: If ANY of the
     * specified volume capabilities are not supported by the SP, the call
     * MUST return the appropriate gRPC error code.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 4;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SECRETS_FIELD_NUMBER = 5;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CONTENT_SOURCE_FIELD_NUMBER = 6;
    private csi.v1.Csi.VolumeContentSource volumeContentSource_;
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    public boolean hasVolumeContentSource() {
      return volumeContentSource_ != null;
    }
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    public csi.v1.Csi.VolumeContentSource getVolumeContentSource() {
      return volumeContentSource_ == null ? csi.v1.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
    }
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
     */
    public csi.v1.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder() {
      return getVolumeContentSource();
    }

    public static final int ACCESSIBILITY_REQUIREMENTS_FIELD_NUMBER = 7;
    private csi.v1.Csi.TopologyRequirement accessibilityRequirements_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public boolean hasAccessibilityRequirements() {
      return accessibilityRequirements_ != null;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public csi.v1.Csi.TopologyRequirement getAccessibilityRequirements() {
      return accessibilityRequirements_ == null ? csi.v1.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
     * choose where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public csi.v1.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder() {
      return getAccessibilityRequirements();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (capacityRange_ != null) {
        output.writeMessage(2, getCapacityRange());
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(3, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          4);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          5);
      if (volumeContentSource_ != null) {
        output.writeMessage(6, getVolumeContentSource());
      }
      if (accessibilityRequirements_ != null) {
        output.writeMessage(7, getAccessibilityRequirements());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (capacityRange_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getCapacityRange());
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, parameters__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, secrets__);
      }
      if (volumeContentSource_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getVolumeContentSource());
      }
      if (accessibilityRequirements_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getAccessibilityRequirements());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.CreateVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.CreateVolumeRequest other = (csi.v1.Csi.CreateVolumeRequest) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && (hasCapacityRange() == other.hasCapacityRange());
      if (hasCapacityRange()) {
        result = result && getCapacityRange()
            .equals(other.getCapacityRange());
      }
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && (hasVolumeContentSource() == other.hasVolumeContentSource());
      if (hasVolumeContentSource()) {
        result = result && getVolumeContentSource()
            .equals(other.getVolumeContentSource());
      }
      result = result && (hasAccessibilityRequirements() == other.hasAccessibilityRequirements());
      if (hasAccessibilityRequirements()) {
        result = result && getAccessibilityRequirements()
            .equals(other.getAccessibilityRequirements());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasCapacityRange()) {
        hash = (37 * hash) + CAPACITY_RANGE_FIELD_NUMBER;
        hash = (53 * hash) + getCapacityRange().hashCode();
      }
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      if (hasVolumeContentSource()) {
        hash = (37 * hash) + VOLUME_CONTENT_SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeContentSource().hashCode();
      }
      if (hasAccessibilityRequirements()) {
        hash = (37 * hash) + ACCESSIBILITY_REQUIREMENTS_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibilityRequirements().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.CreateVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.CreateVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.CreateVolumeRequest)
        csi.v1.Csi.CreateVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetParameters();
          case 5:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableParameters();
          case 5:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.CreateVolumeRequest.class, csi.v1.Csi.CreateVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.CreateVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableParameters().clear();
        internalGetMutableSecrets().clear();
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = null;
        } else {
          volumeContentSource_ = null;
          volumeContentSourceBuilder_ = null;
        }
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = null;
        } else {
          accessibilityRequirements_ = null;
          accessibilityRequirementsBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeRequest_descriptor;
      }

      public csi.v1.Csi.CreateVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.CreateVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.CreateVolumeRequest build() {
        csi.v1.Csi.CreateVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.CreateVolumeRequest buildPartial() {
        csi.v1.Csi.CreateVolumeRequest result = new csi.v1.Csi.CreateVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        if (capacityRangeBuilder_ == null) {
          result.capacityRange_ = capacityRange_;
        } else {
          result.capacityRange_ = capacityRangeBuilder_.build();
        }
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        if (volumeContentSourceBuilder_ == null) {
          result.volumeContentSource_ = volumeContentSource_;
        } else {
          result.volumeContentSource_ = volumeContentSourceBuilder_.build();
        }
        if (accessibilityRequirementsBuilder_ == null) {
          result.accessibilityRequirements_ = accessibilityRequirements_;
        } else {
          result.accessibilityRequirements_ = accessibilityRequirementsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.CreateVolumeRequest) {
          return mergeFrom((csi.v1.Csi.CreateVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.CreateVolumeRequest other) {
        if (other == csi.v1.Csi.CreateVolumeRequest.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasCapacityRange()) {
          mergeCapacityRange(other.getCapacityRange());
        }
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        if (other.hasVolumeContentSource()) {
          mergeVolumeContentSource(other.getVolumeContentSource());
        }
        if (other.hasAccessibilityRequirements()) {
          mergeAccessibilityRequirements(other.getAccessibilityRequirements());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.CreateVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.CreateVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency.  The Plugin SHOULD ensure that multiple
       *    `CreateVolume` calls for the same name do not result in more
       *    than one piece of storage provisioned corresponding to that
       *    name. If a Plugin is unable to enforce idempotency, the CO's
       *    error recovery logic could result in multiple (unused) volumes
       *    being provisioned.
       *    In the case of error, the CO MUST handle the gRPC error codes
       *    per the recovery behavior defined in the "CreateVolume Errors"
       *    section below.
       *    The CO is responsible for cleaning up volumes it provisioned
       *    that it no longer needs. If the CO is uncertain whether a volume
       *    was provisioned or not when a `CreateVolume` call fails, the CO
       *    MAY call `CreateVolume` again, with the same name, to ensure the
       *    volume exists and to retrieve the volume's `volume_id` (unless
       *    otherwise prohibited by "CreateVolume Errors").
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency.  The Plugin SHOULD ensure that multiple
       *    `CreateVolume` calls for the same name do not result in more
       *    than one piece of storage provisioned corresponding to that
       *    name. If a Plugin is unable to enforce idempotency, the CO's
       *    error recovery logic could result in multiple (unused) volumes
       *    being provisioned.
       *    In the case of error, the CO MUST handle the gRPC error codes
       *    per the recovery behavior defined in the "CreateVolume Errors"
       *    section below.
       *    The CO is responsible for cleaning up volumes it provisioned
       *    that it no longer needs. If the CO is uncertain whether a volume
       *    was provisioned or not when a `CreateVolume` call fails, the CO
       *    MAY call `CreateVolume` again, with the same name, to ensure the
       *    volume exists and to retrieve the volume's `volume_id` (unless
       *    otherwise prohibited by "CreateVolume Errors").
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency.  The Plugin SHOULD ensure that multiple
       *    `CreateVolume` calls for the same name do not result in more
       *    than one piece of storage provisioned corresponding to that
       *    name. If a Plugin is unable to enforce idempotency, the CO's
       *    error recovery logic could result in multiple (unused) volumes
       *    being provisioned.
       *    In the case of error, the CO MUST handle the gRPC error codes
       *    per the recovery behavior defined in the "CreateVolume Errors"
       *    section below.
       *    The CO is responsible for cleaning up volumes it provisioned
       *    that it no longer needs. If the CO is uncertain whether a volume
       *    was provisioned or not when a `CreateVolume` call fails, the CO
       *    MAY call `CreateVolume` again, with the same name, to ensure the
       *    volume exists and to retrieve the volume's `volume_id` (unless
       *    otherwise prohibited by "CreateVolume Errors").
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency.  The Plugin SHOULD ensure that multiple
       *    `CreateVolume` calls for the same name do not result in more
       *    than one piece of storage provisioned corresponding to that
       *    name. If a Plugin is unable to enforce idempotency, the CO's
       *    error recovery logic could result in multiple (unused) volumes
       *    being provisioned.
       *    In the case of error, the CO MUST handle the gRPC error codes
       *    per the recovery behavior defined in the "CreateVolume Errors"
       *    section below.
       *    The CO is responsible for cleaning up volumes it provisioned
       *    that it no longer needs. If the CO is uncertain whether a volume
       *    was provisioned or not when a `CreateVolume` call fails, the CO
       *    MAY call `CreateVolume` again, with the same name, to ensure the
       *    volume exists and to retrieve the volume's `volume_id` (unless
       *    otherwise prohibited by "CreateVolume Errors").
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency.  The Plugin SHOULD ensure that multiple
       *    `CreateVolume` calls for the same name do not result in more
       *    than one piece of storage provisioned corresponding to that
       *    name. If a Plugin is unable to enforce idempotency, the CO's
       *    error recovery logic could result in multiple (unused) volumes
       *    being provisioned.
       *    In the case of error, the CO MUST handle the gRPC error codes
       *    per the recovery behavior defined in the "CreateVolume Errors"
       *    section below.
       *    The CO is responsible for cleaning up volumes it provisioned
       *    that it no longer needs. If the CO is uncertain whether a volume
       *    was provisioned or not when a `CreateVolume` call fails, the CO
       *    MAY call `CreateVolume` again, with the same name, to ensure the
       *    volume exists and to retrieve the volume's `volume_id` (unless
       *    otherwise prohibited by "CreateVolume Errors").
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.CapacityRange capacityRange_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> capacityRangeBuilder_;
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public boolean hasCapacityRange() {
        return capacityRangeBuilder_ != null || capacityRange_ != null;
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRange getCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        } else {
          return capacityRangeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capacityRange_ = value;
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(
          csi.v1.Csi.CapacityRange.Builder builderForValue) {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = builderForValue.build();
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder mergeCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (capacityRange_ != null) {
            capacityRange_ =
              csi.v1.Csi.CapacityRange.newBuilder(capacityRange_).mergeFrom(value).buildPartial();
          } else {
            capacityRange_ = value;
          }
          onChanged();
        } else {
          capacityRangeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder clearCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
          onChanged();
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRange.Builder getCapacityRangeBuilder() {
        
        onChanged();
        return getCapacityRangeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
        if (capacityRangeBuilder_ != null) {
          return capacityRangeBuilder_.getMessageOrBuilder();
        } else {
          return capacityRange_ == null ?
              csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL. This allows the CO to specify the capacity
       * requirement of the volume to be provisioned. If not specified, the
       * Plugin MAY choose an implementation-defined capacity range. If
       * specified it MUST always be honored, even when creating volumes
       * from a source; which MAY force some backends to internally extend
       * the volume after creating it.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> 
          getCapacityRangeFieldBuilder() {
        if (capacityRangeBuilder_ == null) {
          capacityRangeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder>(
                  getCapacityRange(),
                  getParentForChildren(),
                  isClean());
          capacityRange_ = null;
        }
        return capacityRangeBuilder_;
      }

      private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have. SP MUST
       * provision a volume that will satisfy ALL of the capabilities
       * specified in this list. Otherwise SP MUST return the appropriate
       * gRPC error code.
       * The Plugin MUST assume that the CO MAY use the provisioned volume
       * with ANY of the capabilities specified in this list.
       * For example, a CO MAY specify two volume capabilities: one with
       * access mode SINGLE_NODE_WRITER and another with access mode
       * MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
       * provisioned volume can be used in either mode.
       * This also enables the CO to do early validation: If ANY of the
       * specified volume capabilities are not supported by the SP, the call
       * MUST return the appropriate gRPC error code.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v1.Csi.VolumeContentSource volumeContentSource_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder> volumeContentSourceBuilder_;
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public boolean hasVolumeContentSource() {
        return volumeContentSourceBuilder_ != null || volumeContentSource_ != null;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v1.Csi.VolumeContentSource getVolumeContentSource() {
        if (volumeContentSourceBuilder_ == null) {
          return volumeContentSource_ == null ? csi.v1.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
        } else {
          return volumeContentSourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder setVolumeContentSource(csi.v1.Csi.VolumeContentSource value) {
        if (volumeContentSourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeContentSource_ = value;
          onChanged();
        } else {
          volumeContentSourceBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder setVolumeContentSource(
          csi.v1.Csi.VolumeContentSource.Builder builderForValue) {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = builderForValue.build();
          onChanged();
        } else {
          volumeContentSourceBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder mergeVolumeContentSource(csi.v1.Csi.VolumeContentSource value) {
        if (volumeContentSourceBuilder_ == null) {
          if (volumeContentSource_ != null) {
            volumeContentSource_ =
              csi.v1.Csi.VolumeContentSource.newBuilder(volumeContentSource_).mergeFrom(value).buildPartial();
          } else {
            volumeContentSource_ = value;
          }
          onChanged();
        } else {
          volumeContentSourceBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder clearVolumeContentSource() {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = null;
          onChanged();
        } else {
          volumeContentSource_ = null;
          volumeContentSourceBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v1.Csi.VolumeContentSource.Builder getVolumeContentSourceBuilder() {
        
        onChanged();
        return getVolumeContentSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v1.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder() {
        if (volumeContentSourceBuilder_ != null) {
          return volumeContentSourceBuilder_.getMessageOrBuilder();
        } else {
          return volumeContentSource_ == null ?
              csi.v1.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
        }
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource volume_content_source = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder> 
          getVolumeContentSourceFieldBuilder() {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSourceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder>(
                  getVolumeContentSource(),
                  getParentForChildren(),
                  isClean());
          volumeContentSource_ = null;
        }
        return volumeContentSourceBuilder_;
      }

      private csi.v1.Csi.TopologyRequirement accessibilityRequirements_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.TopologyRequirement, csi.v1.Csi.TopologyRequirement.Builder, csi.v1.Csi.TopologyRequirementOrBuilder> accessibilityRequirementsBuilder_;
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public boolean hasAccessibilityRequirements() {
        return accessibilityRequirementsBuilder_ != null || accessibilityRequirements_ != null;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v1.Csi.TopologyRequirement getAccessibilityRequirements() {
        if (accessibilityRequirementsBuilder_ == null) {
          return accessibilityRequirements_ == null ? csi.v1.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
        } else {
          return accessibilityRequirementsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder setAccessibilityRequirements(csi.v1.Csi.TopologyRequirement value) {
        if (accessibilityRequirementsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibilityRequirements_ = value;
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder setAccessibilityRequirements(
          csi.v1.Csi.TopologyRequirement.Builder builderForValue) {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = builderForValue.build();
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder mergeAccessibilityRequirements(csi.v1.Csi.TopologyRequirement value) {
        if (accessibilityRequirementsBuilder_ == null) {
          if (accessibilityRequirements_ != null) {
            accessibilityRequirements_ =
              csi.v1.Csi.TopologyRequirement.newBuilder(accessibilityRequirements_).mergeFrom(value).buildPartial();
          } else {
            accessibilityRequirements_ = value;
          }
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder clearAccessibilityRequirements() {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = null;
          onChanged();
        } else {
          accessibilityRequirements_ = null;
          accessibilityRequirementsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v1.Csi.TopologyRequirement.Builder getAccessibilityRequirementsBuilder() {
        
        onChanged();
        return getAccessibilityRequirementsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v1.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder() {
        if (accessibilityRequirementsBuilder_ != null) {
          return accessibilityRequirementsBuilder_.getMessageOrBuilder();
        } else {
          return accessibilityRequirements_ == null ?
              csi.v1.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
       * choose where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v1.TopologyRequirement accessibility_requirements = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.TopologyRequirement, csi.v1.Csi.TopologyRequirement.Builder, csi.v1.Csi.TopologyRequirementOrBuilder> 
          getAccessibilityRequirementsFieldBuilder() {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirementsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.TopologyRequirement, csi.v1.Csi.TopologyRequirement.Builder, csi.v1.Csi.TopologyRequirementOrBuilder>(
                  getAccessibilityRequirements(),
                  getParentForChildren(),
                  isClean());
          accessibilityRequirements_ = null;
        }
        return accessibilityRequirementsBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.CreateVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeRequest)
    private static final csi.v1.Csi.CreateVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.CreateVolumeRequest();
    }

    public static csi.v1.Csi.CreateVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<CreateVolumeRequest>() {
      public CreateVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.CreateVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeContentSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.VolumeContentSource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    boolean hasSnapshot();
    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    csi.v1.Csi.VolumeContentSource.SnapshotSource getSnapshot();
    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder();

    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    boolean hasVolume();
    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    csi.v1.Csi.VolumeContentSource.VolumeSource getVolume();
    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder getVolumeOrBuilder();

    public csi.v1.Csi.VolumeContentSource.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies what source the volume will be created from. One of the
   * type fields MUST be specified.
   * </pre>
   *
   * Protobuf type {@code csi.v1.VolumeContentSource}
   */
  public  static final class VolumeContentSource extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.VolumeContentSource)
      VolumeContentSourceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VolumeContentSource.newBuilder() to construct.
    private VolumeContentSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VolumeContentSource() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private VolumeContentSource(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v1.Csi.VolumeContentSource.SnapshotSource) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.VolumeContentSource.SnapshotSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.VolumeContentSource.SnapshotSource) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            case 18: {
              csi.v1.Csi.VolumeContentSource.VolumeSource.Builder subBuilder = null;
              if (typeCase_ == 2) {
                subBuilder = ((csi.v1.Csi.VolumeContentSource.VolumeSource) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.VolumeContentSource.VolumeSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.VolumeContentSource.VolumeSource) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 2;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.VolumeContentSource.class, csi.v1.Csi.VolumeContentSource.Builder.class);
    }

    public interface SnapshotSourceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.VolumeContentSource.SnapshotSource)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      java.lang.String getSnapshotId();
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      com.google.protobuf.ByteString
          getSnapshotIdBytes();
    }
    /**
     * Protobuf type {@code csi.v1.VolumeContentSource.SnapshotSource}
     */
    public  static final class SnapshotSource extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.VolumeContentSource.SnapshotSource)
        SnapshotSourceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use SnapshotSource.newBuilder() to construct.
      private SnapshotSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private SnapshotSource() {
        snapshotId_ = "";
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private SnapshotSource(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                snapshotId_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_SnapshotSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeContentSource.SnapshotSource.class, csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder.class);
      }

      public static final int SNAPSHOT_ID_FIELD_NUMBER = 1;
      private volatile java.lang.Object snapshotId_;
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getSnapshotIdBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, snapshotId_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getSnapshotIdBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, snapshotId_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.VolumeContentSource.SnapshotSource)) {
          return super.equals(obj);
        }
        csi.v1.Csi.VolumeContentSource.SnapshotSource other = (csi.v1.Csi.VolumeContentSource.SnapshotSource) obj;

        boolean result = true;
        result = result && getSnapshotId()
            .equals(other.getSnapshotId());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
        hash = (53 * hash) + getSnapshotId().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.VolumeContentSource.SnapshotSource prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.VolumeContentSource.SnapshotSource}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.VolumeContentSource.SnapshotSource)
          csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_SnapshotSource_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.VolumeContentSource.SnapshotSource.class, csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder.class);
        }

        // Construct using csi.v1.Csi.VolumeContentSource.SnapshotSource.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          snapshotId_ = "";

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor;
        }

        public csi.v1.Csi.VolumeContentSource.SnapshotSource getDefaultInstanceForType() {
          return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }

        public csi.v1.Csi.VolumeContentSource.SnapshotSource build() {
          csi.v1.Csi.VolumeContentSource.SnapshotSource result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.VolumeContentSource.SnapshotSource buildPartial() {
          csi.v1.Csi.VolumeContentSource.SnapshotSource result = new csi.v1.Csi.VolumeContentSource.SnapshotSource(this);
          result.snapshotId_ = snapshotId_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.VolumeContentSource.SnapshotSource) {
            return mergeFrom((csi.v1.Csi.VolumeContentSource.SnapshotSource)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.VolumeContentSource.SnapshotSource other) {
          if (other == csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance()) return this;
          if (!other.getSnapshotId().isEmpty()) {
            snapshotId_ = other.snapshotId_;
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.VolumeContentSource.SnapshotSource parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.VolumeContentSource.SnapshotSource) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private java.lang.Object snapshotId_ = "";
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string snapshot_id = 1;</code>
         */
        public java.lang.String getSnapshotId() {
          java.lang.Object ref = snapshotId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            snapshotId_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string snapshot_id = 1;</code>
         */
        public com.google.protobuf.ByteString
            getSnapshotIdBytes() {
          java.lang.Object ref = snapshotId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            snapshotId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string snapshot_id = 1;</code>
         */
        public Builder setSnapshotId(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          snapshotId_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string snapshot_id = 1;</code>
         */
        public Builder clearSnapshotId() {
          
          snapshotId_ = getDefaultInstance().getSnapshotId();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string snapshot_id = 1;</code>
         */
        public Builder setSnapshotIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          snapshotId_ = value;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.VolumeContentSource.SnapshotSource)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.SnapshotSource)
      private static final csi.v1.Csi.VolumeContentSource.SnapshotSource DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.VolumeContentSource.SnapshotSource();
      }

      public static csi.v1.Csi.VolumeContentSource.SnapshotSource getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SnapshotSource>
          PARSER = new com.google.protobuf.AbstractParser<SnapshotSource>() {
        public SnapshotSource parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new SnapshotSource(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<SnapshotSource> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SnapshotSource> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.VolumeContentSource.SnapshotSource getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface VolumeSourceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.VolumeContentSource.VolumeSource)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Contains identity information for the existing source volume.
       * This field is REQUIRED. Plugins reporting CLONE_VOLUME
       * capability MUST support creating a volume from another volume.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      java.lang.String getVolumeId();
      /**
       * <pre>
       * Contains identity information for the existing source volume.
       * This field is REQUIRED. Plugins reporting CLONE_VOLUME
       * capability MUST support creating a volume from another volume.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      com.google.protobuf.ByteString
          getVolumeIdBytes();
    }
    /**
     * Protobuf type {@code csi.v1.VolumeContentSource.VolumeSource}
     */
    public  static final class VolumeSource extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.VolumeContentSource.VolumeSource)
        VolumeSourceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use VolumeSource.newBuilder() to construct.
      private VolumeSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private VolumeSource() {
        volumeId_ = "";
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private VolumeSource(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                volumeId_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_VolumeSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeContentSource.VolumeSource.class, csi.v1.Csi.VolumeContentSource.VolumeSource.Builder.class);
      }

      public static final int VOLUME_ID_FIELD_NUMBER = 1;
      private volatile java.lang.Object volumeId_;
      /**
       * <pre>
       * Contains identity information for the existing source volume.
       * This field is REQUIRED. Plugins reporting CLONE_VOLUME
       * capability MUST support creating a volume from another volume.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * Contains identity information for the existing source volume.
       * This field is REQUIRED. Plugins reporting CLONE_VOLUME
       * capability MUST support creating a volume from another volume.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getVolumeIdBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getVolumeIdBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.VolumeContentSource.VolumeSource)) {
          return super.equals(obj);
        }
        csi.v1.Csi.VolumeContentSource.VolumeSource other = (csi.v1.Csi.VolumeContentSource.VolumeSource) obj;

        boolean result = true;
        result = result && getVolumeId()
            .equals(other.getVolumeId());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeId().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeContentSource.VolumeSource parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.VolumeContentSource.VolumeSource prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.VolumeContentSource.VolumeSource}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.VolumeContentSource.VolumeSource)
          csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_VolumeSource_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.VolumeContentSource.VolumeSource.class, csi.v1.Csi.VolumeContentSource.VolumeSource.Builder.class);
        }

        // Construct using csi.v1.Csi.VolumeContentSource.VolumeSource.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          volumeId_ = "";

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor;
        }

        public csi.v1.Csi.VolumeContentSource.VolumeSource getDefaultInstanceForType() {
          return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
        }

        public csi.v1.Csi.VolumeContentSource.VolumeSource build() {
          csi.v1.Csi.VolumeContentSource.VolumeSource result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.VolumeContentSource.VolumeSource buildPartial() {
          csi.v1.Csi.VolumeContentSource.VolumeSource result = new csi.v1.Csi.VolumeContentSource.VolumeSource(this);
          result.volumeId_ = volumeId_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.VolumeContentSource.VolumeSource) {
            return mergeFrom((csi.v1.Csi.VolumeContentSource.VolumeSource)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.VolumeContentSource.VolumeSource other) {
          if (other == csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance()) return this;
          if (!other.getVolumeId().isEmpty()) {
            volumeId_ = other.volumeId_;
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.VolumeContentSource.VolumeSource parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.VolumeContentSource.VolumeSource) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private java.lang.Object volumeId_ = "";
        /**
         * <pre>
         * Contains identity information for the existing source volume.
         * This field is REQUIRED. Plugins reporting CLONE_VOLUME
         * capability MUST support creating a volume from another volume.
         * </pre>
         *
         * <code>string volume_id = 1;</code>
         */
        public java.lang.String getVolumeId() {
          java.lang.Object ref = volumeId_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            volumeId_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source volume.
         * This field is REQUIRED. Plugins reporting CLONE_VOLUME
         * capability MUST support creating a volume from another volume.
         * </pre>
         *
         * <code>string volume_id = 1;</code>
         */
        public com.google.protobuf.ByteString
            getVolumeIdBytes() {
          java.lang.Object ref = volumeId_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            volumeId_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source volume.
         * This field is REQUIRED. Plugins reporting CLONE_VOLUME
         * capability MUST support creating a volume from another volume.
         * </pre>
         *
         * <code>string volume_id = 1;</code>
         */
        public Builder setVolumeId(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          volumeId_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source volume.
         * This field is REQUIRED. Plugins reporting CLONE_VOLUME
         * capability MUST support creating a volume from another volume.
         * </pre>
         *
         * <code>string volume_id = 1;</code>
         */
        public Builder clearVolumeId() {
          
          volumeId_ = getDefaultInstance().getVolumeId();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source volume.
         * This field is REQUIRED. Plugins reporting CLONE_VOLUME
         * capability MUST support creating a volume from another volume.
         * </pre>
         *
         * <code>string volume_id = 1;</code>
         */
        public Builder setVolumeIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          volumeId_ = value;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.VolumeContentSource.VolumeSource)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.VolumeSource)
      private static final csi.v1.Csi.VolumeContentSource.VolumeSource DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.VolumeContentSource.VolumeSource();
      }

      public static csi.v1.Csi.VolumeContentSource.VolumeSource getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<VolumeSource>
          PARSER = new com.google.protobuf.AbstractParser<VolumeSource>() {
        public VolumeSource parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new VolumeSource(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<VolumeSource> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<VolumeSource> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.VolumeContentSource.VolumeSource getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      SNAPSHOT(1),
      VOLUME(2),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return SNAPSHOT;
          case 2: return VOLUME;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int SNAPSHOT_FIELD_NUMBER = 1;
    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public boolean hasSnapshot() {
      return typeCase_ == 1;
    }
    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public csi.v1.Csi.VolumeContentSource.SnapshotSource getSnapshot() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_;
      }
      return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
    }
    /**
     * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_;
      }
      return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
    }

    public static final int VOLUME_FIELD_NUMBER = 2;
    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    public boolean hasVolume() {
      return typeCase_ == 2;
    }
    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    public csi.v1.Csi.VolumeContentSource.VolumeSource getVolume() {
      if (typeCase_ == 2) {
         return (csi.v1.Csi.VolumeContentSource.VolumeSource) type_;
      }
      return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
    }
    /**
     * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
     */
    public csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder getVolumeOrBuilder() {
      if (typeCase_ == 2) {
         return (csi.v1.Csi.VolumeContentSource.VolumeSource) type_;
      }
      return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_);
      }
      if (typeCase_ == 2) {
        output.writeMessage(2, (csi.v1.Csi.VolumeContentSource.VolumeSource) type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_);
      }
      if (typeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (csi.v1.Csi.VolumeContentSource.VolumeSource) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.VolumeContentSource)) {
        return super.equals(obj);
      }
      csi.v1.Csi.VolumeContentSource other = (csi.v1.Csi.VolumeContentSource) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getSnapshot()
              .equals(other.getSnapshot());
          break;
        case 2:
          result = result && getVolume()
              .equals(other.getVolume());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
          hash = (53 * hash) + getSnapshot().hashCode();
          break;
        case 2:
          hash = (37 * hash) + VOLUME_FIELD_NUMBER;
          hash = (53 * hash) + getVolume().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.VolumeContentSource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeContentSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeContentSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.VolumeContentSource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies what source the volume will be created from. One of the
     * type fields MUST be specified.
     * </pre>
     *
     * Protobuf type {@code csi.v1.VolumeContentSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.VolumeContentSource)
        csi.v1.Csi.VolumeContentSourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeContentSource.class, csi.v1.Csi.VolumeContentSource.Builder.class);
      }

      // Construct using csi.v1.Csi.VolumeContentSource.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeContentSource_descriptor;
      }

      public csi.v1.Csi.VolumeContentSource getDefaultInstanceForType() {
        return csi.v1.Csi.VolumeContentSource.getDefaultInstance();
      }

      public csi.v1.Csi.VolumeContentSource build() {
        csi.v1.Csi.VolumeContentSource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.VolumeContentSource buildPartial() {
        csi.v1.Csi.VolumeContentSource result = new csi.v1.Csi.VolumeContentSource(this);
        if (typeCase_ == 1) {
          if (snapshotBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = snapshotBuilder_.build();
          }
        }
        if (typeCase_ == 2) {
          if (volumeBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = volumeBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.VolumeContentSource) {
          return mergeFrom((csi.v1.Csi.VolumeContentSource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.VolumeContentSource other) {
        if (other == csi.v1.Csi.VolumeContentSource.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case SNAPSHOT: {
            mergeSnapshot(other.getSnapshot());
            break;
          }
          case VOLUME: {
            mergeVolume(other.getVolume());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.VolumeContentSource parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.VolumeContentSource) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource.SnapshotSource, csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder> snapshotBuilder_;
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return typeCase_ == 1;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v1.Csi.VolumeContentSource.SnapshotSource getSnapshot() {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_;
          }
          return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return snapshotBuilder_.getMessage();
          }
          return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder setSnapshot(csi.v1.Csi.VolumeContentSource.SnapshotSource value) {
        if (snapshotBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          snapshotBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder setSnapshot(
          csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder builderForValue) {
        if (snapshotBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          snapshotBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder mergeSnapshot(csi.v1.Csi.VolumeContentSource.SnapshotSource value) {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance()) {
            type_ = csi.v1.Csi.VolumeContentSource.SnapshotSource.newBuilder((csi.v1.Csi.VolumeContentSource.SnapshotSource) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            snapshotBuilder_.mergeFrom(value);
          }
          snapshotBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder clearSnapshot() {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          snapshotBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder getSnapshotBuilder() {
        return getSnapshotFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder() {
        if ((typeCase_ == 1) && (snapshotBuilder_ != null)) {
          return snapshotBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_;
          }
          return csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource.SnapshotSource, csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder> 
          getSnapshotFieldBuilder() {
        if (snapshotBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v1.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
          }
          snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeContentSource.SnapshotSource, csi.v1.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v1.Csi.VolumeContentSource.SnapshotSourceOrBuilder>(
                  (csi.v1.Csi.VolumeContentSource.SnapshotSource) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return snapshotBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource.VolumeSource, csi.v1.Csi.VolumeContentSource.VolumeSource.Builder, csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder> volumeBuilder_;
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public boolean hasVolume() {
        return typeCase_ == 2;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public csi.v1.Csi.VolumeContentSource.VolumeSource getVolume() {
        if (volumeBuilder_ == null) {
          if (typeCase_ == 2) {
            return (csi.v1.Csi.VolumeContentSource.VolumeSource) type_;
          }
          return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
        } else {
          if (typeCase_ == 2) {
            return volumeBuilder_.getMessage();
          }
          return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public Builder setVolume(csi.v1.Csi.VolumeContentSource.VolumeSource value) {
        if (volumeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          volumeBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public Builder setVolume(
          csi.v1.Csi.VolumeContentSource.VolumeSource.Builder builderForValue) {
        if (volumeBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          volumeBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public Builder mergeVolume(csi.v1.Csi.VolumeContentSource.VolumeSource value) {
        if (volumeBuilder_ == null) {
          if (typeCase_ == 2 &&
              type_ != csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance()) {
            type_ = csi.v1.Csi.VolumeContentSource.VolumeSource.newBuilder((csi.v1.Csi.VolumeContentSource.VolumeSource) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 2) {
            volumeBuilder_.mergeFrom(value);
          }
          volumeBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public Builder clearVolume() {
        if (volumeBuilder_ == null) {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
          }
          volumeBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public csi.v1.Csi.VolumeContentSource.VolumeSource.Builder getVolumeBuilder() {
        return getVolumeFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      public csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder getVolumeOrBuilder() {
        if ((typeCase_ == 2) && (volumeBuilder_ != null)) {
          return volumeBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 2) {
            return (csi.v1.Csi.VolumeContentSource.VolumeSource) type_;
          }
          return csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeContentSource.VolumeSource volume = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource.VolumeSource, csi.v1.Csi.VolumeContentSource.VolumeSource.Builder, csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder> 
          getVolumeFieldBuilder() {
        if (volumeBuilder_ == null) {
          if (!(typeCase_ == 2)) {
            type_ = csi.v1.Csi.VolumeContentSource.VolumeSource.getDefaultInstance();
          }
          volumeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeContentSource.VolumeSource, csi.v1.Csi.VolumeContentSource.VolumeSource.Builder, csi.v1.Csi.VolumeContentSource.VolumeSourceOrBuilder>(
                  (csi.v1.Csi.VolumeContentSource.VolumeSource) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 2;
        onChanged();;
        return volumeBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.VolumeContentSource)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource)
    private static final csi.v1.Csi.VolumeContentSource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.VolumeContentSource();
    }

    public static csi.v1.Csi.VolumeContentSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeContentSource>
        PARSER = new com.google.protobuf.AbstractParser<VolumeContentSource>() {
      public VolumeContentSource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new VolumeContentSource(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<VolumeContentSource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeContentSource> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.VolumeContentSource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.CreateVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    boolean hasVolume();
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    csi.v1.Csi.Volume getVolume();
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.CreateVolumeResponse}
   */
  public  static final class CreateVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.CreateVolumeResponse)
      CreateVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateVolumeResponse.newBuilder() to construct.
    private CreateVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.Volume.Builder subBuilder = null;
              if (volume_ != null) {
                subBuilder = volume_.toBuilder();
              }
              volume_ = input.readMessage(csi.v1.Csi.Volume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volume_);
                volume_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_CreateVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_CreateVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.CreateVolumeResponse.class, csi.v1.Csi.CreateVolumeResponse.Builder.class);
    }

    public static final int VOLUME_FIELD_NUMBER = 1;
    private csi.v1.Csi.Volume volume_;
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    public boolean hasVolume() {
      return volume_ != null;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    public csi.v1.Csi.Volume getVolume() {
      return volume_ == null ? csi.v1.Csi.Volume.getDefaultInstance() : volume_;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Volume volume = 1;</code>
     */
    public csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder() {
      return getVolume();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (volume_ != null) {
        output.writeMessage(1, getVolume());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (volume_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getVolume());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.CreateVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.CreateVolumeResponse other = (csi.v1.Csi.CreateVolumeResponse) obj;

      boolean result = true;
      result = result && (hasVolume() == other.hasVolume());
      if (hasVolume()) {
        result = result && getVolume()
            .equals(other.getVolume());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasVolume()) {
        hash = (37 * hash) + VOLUME_FIELD_NUMBER;
        hash = (53 * hash) + getVolume().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.CreateVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.CreateVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.CreateVolumeResponse)
        csi.v1.Csi.CreateVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.CreateVolumeResponse.class, csi.v1.Csi.CreateVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.CreateVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (volumeBuilder_ == null) {
          volume_ = null;
        } else {
          volume_ = null;
          volumeBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_CreateVolumeResponse_descriptor;
      }

      public csi.v1.Csi.CreateVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.CreateVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.CreateVolumeResponse build() {
        csi.v1.Csi.CreateVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.CreateVolumeResponse buildPartial() {
        csi.v1.Csi.CreateVolumeResponse result = new csi.v1.Csi.CreateVolumeResponse(this);
        if (volumeBuilder_ == null) {
          result.volume_ = volume_;
        } else {
          result.volume_ = volumeBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.CreateVolumeResponse) {
          return mergeFrom((csi.v1.Csi.CreateVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.CreateVolumeResponse other) {
        if (other == csi.v1.Csi.CreateVolumeResponse.getDefaultInstance()) return this;
        if (other.hasVolume()) {
          mergeVolume(other.getVolume());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.CreateVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.CreateVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private csi.v1.Csi.Volume volume_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder> volumeBuilder_;
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public boolean hasVolume() {
        return volumeBuilder_ != null || volume_ != null;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public csi.v1.Csi.Volume getVolume() {
        if (volumeBuilder_ == null) {
          return volume_ == null ? csi.v1.Csi.Volume.getDefaultInstance() : volume_;
        } else {
          return volumeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public Builder setVolume(csi.v1.Csi.Volume value) {
        if (volumeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volume_ = value;
          onChanged();
        } else {
          volumeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public Builder setVolume(
          csi.v1.Csi.Volume.Builder builderForValue) {
        if (volumeBuilder_ == null) {
          volume_ = builderForValue.build();
          onChanged();
        } else {
          volumeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public Builder mergeVolume(csi.v1.Csi.Volume value) {
        if (volumeBuilder_ == null) {
          if (volume_ != null) {
            volume_ =
              csi.v1.Csi.Volume.newBuilder(volume_).mergeFrom(value).buildPartial();
          } else {
            volume_ = value;
          }
          onChanged();
        } else {
          volumeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public Builder clearVolume() {
        if (volumeBuilder_ == null) {
          volume_ = null;
          onChanged();
        } else {
          volume_ = null;
          volumeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public csi.v1.Csi.Volume.Builder getVolumeBuilder() {
        
        onChanged();
        return getVolumeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder() {
        if (volumeBuilder_ != null) {
          return volumeBuilder_.getMessageOrBuilder();
        } else {
          return volume_ == null ?
              csi.v1.Csi.Volume.getDefaultInstance() : volume_;
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder> 
          getVolumeFieldBuilder() {
        if (volumeBuilder_ == null) {
          volumeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder>(
                  getVolume(),
                  getParentForChildren(),
                  isClean());
          volume_ = null;
        }
        return volumeBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.CreateVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeResponse)
    private static final csi.v1.Csi.CreateVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.CreateVolumeResponse();
    }

    public static csi.v1.Csi.CreateVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<CreateVolumeResponse>() {
      public CreateVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.CreateVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.VolumeCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    boolean hasBlock();
    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    csi.v1.Csi.VolumeCapability.BlockVolume getBlock();
    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder();

    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    boolean hasMount();
    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    csi.v1.Csi.VolumeCapability.MountVolume getMount();
    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder();

    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    boolean hasAccessMode();
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    csi.v1.Csi.VolumeCapability.AccessMode getAccessMode();
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    csi.v1.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder();

    public csi.v1.Csi.VolumeCapability.AccessTypeCase getAccessTypeCase();
  }
  /**
   * <pre>
   * Specify a capability of a volume.
   * </pre>
   *
   * Protobuf type {@code csi.v1.VolumeCapability}
   */
  public  static final class VolumeCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.VolumeCapability)
      VolumeCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VolumeCapability.newBuilder() to construct.
    private VolumeCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VolumeCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private VolumeCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.VolumeCapability.BlockVolume.Builder subBuilder = null;
              if (accessTypeCase_ == 1) {
                subBuilder = ((csi.v1.Csi.VolumeCapability.BlockVolume) accessType_).toBuilder();
              }
              accessType_ =
                  input.readMessage(csi.v1.Csi.VolumeCapability.BlockVolume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.VolumeCapability.BlockVolume) accessType_);
                accessType_ = subBuilder.buildPartial();
              }
              accessTypeCase_ = 1;
              break;
            }
            case 18: {
              csi.v1.Csi.VolumeCapability.MountVolume.Builder subBuilder = null;
              if (accessTypeCase_ == 2) {
                subBuilder = ((csi.v1.Csi.VolumeCapability.MountVolume) accessType_).toBuilder();
              }
              accessType_ =
                  input.readMessage(csi.v1.Csi.VolumeCapability.MountVolume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.VolumeCapability.MountVolume) accessType_);
                accessType_ = subBuilder.buildPartial();
              }
              accessTypeCase_ = 2;
              break;
            }
            case 26: {
              csi.v1.Csi.VolumeCapability.AccessMode.Builder subBuilder = null;
              if (accessMode_ != null) {
                subBuilder = accessMode_.toBuilder();
              }
              accessMode_ = input.readMessage(csi.v1.Csi.VolumeCapability.AccessMode.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessMode_);
                accessMode_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.VolumeCapability.class, csi.v1.Csi.VolumeCapability.Builder.class);
    }

    public interface BlockVolumeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.VolumeCapability.BlockVolume)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     * Indicate that the volume will be accessed via the block device API.
     * </pre>
     *
     * Protobuf type {@code csi.v1.VolumeCapability.BlockVolume}
     */
    public  static final class BlockVolume extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.VolumeCapability.BlockVolume)
        BlockVolumeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use BlockVolume.newBuilder() to construct.
      private BlockVolume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private BlockVolume() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private BlockVolume(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_BlockVolume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeCapability.BlockVolume.class, csi.v1.Csi.VolumeCapability.BlockVolume.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.VolumeCapability.BlockVolume)) {
          return super.equals(obj);
        }
        csi.v1.Csi.VolumeCapability.BlockVolume other = (csi.v1.Csi.VolumeCapability.BlockVolume) obj;

        boolean result = true;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.VolumeCapability.BlockVolume prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Indicate that the volume will be accessed via the block device API.
       * </pre>
       *
       * Protobuf type {@code csi.v1.VolumeCapability.BlockVolume}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.VolumeCapability.BlockVolume)
          csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_BlockVolume_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.VolumeCapability.BlockVolume.class, csi.v1.Csi.VolumeCapability.BlockVolume.Builder.class);
        }

        // Construct using csi.v1.Csi.VolumeCapability.BlockVolume.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor;
        }

        public csi.v1.Csi.VolumeCapability.BlockVolume getDefaultInstanceForType() {
          return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }

        public csi.v1.Csi.VolumeCapability.BlockVolume build() {
          csi.v1.Csi.VolumeCapability.BlockVolume result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.VolumeCapability.BlockVolume buildPartial() {
          csi.v1.Csi.VolumeCapability.BlockVolume result = new csi.v1.Csi.VolumeCapability.BlockVolume(this);
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.VolumeCapability.BlockVolume) {
            return mergeFrom((csi.v1.Csi.VolumeCapability.BlockVolume)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.VolumeCapability.BlockVolume other) {
          if (other == csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.VolumeCapability.BlockVolume parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.VolumeCapability.BlockVolume) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.VolumeCapability.BlockVolume)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.BlockVolume)
      private static final csi.v1.Csi.VolumeCapability.BlockVolume DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.VolumeCapability.BlockVolume();
      }

      public static csi.v1.Csi.VolumeCapability.BlockVolume getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<BlockVolume>
          PARSER = new com.google.protobuf.AbstractParser<BlockVolume>() {
        public BlockVolume parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new BlockVolume(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<BlockVolume> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<BlockVolume> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.VolumeCapability.BlockVolume getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface MountVolumeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.VolumeCapability.MountVolume)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      java.lang.String getFsType();
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      com.google.protobuf.ByteString
          getFsTypeBytes();

      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      java.util.List<java.lang.String>
          getMountFlagsList();
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      int getMountFlagsCount();
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      java.lang.String getMountFlags(int index);
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      com.google.protobuf.ByteString
          getMountFlagsBytes(int index);
    }
    /**
     * <pre>
     * Indicate that the volume will be accessed via the filesystem API.
     * </pre>
     *
     * Protobuf type {@code csi.v1.VolumeCapability.MountVolume}
     */
    public  static final class MountVolume extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.VolumeCapability.MountVolume)
        MountVolumeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use MountVolume.newBuilder() to construct.
      private MountVolume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private MountVolume() {
        fsType_ = "";
        mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private MountVolume(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                fsType_ = s;
                break;
              }
              case 18: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  mountFlags_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000002;
                }
                mountFlags_.add(s);
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = mountFlags_.getUnmodifiableView();
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_MountVolume_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_MountVolume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeCapability.MountVolume.class, csi.v1.Csi.VolumeCapability.MountVolume.Builder.class);
      }

      private int bitField0_;
      public static final int FS_TYPE_FIELD_NUMBER = 1;
      private volatile java.lang.Object fsType_;
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      public java.lang.String getFsType() {
        java.lang.Object ref = fsType_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          fsType_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getFsTypeBytes() {
        java.lang.Object ref = fsType_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fsType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int MOUNT_FLAGS_FIELD_NUMBER = 2;
      private com.google.protobuf.LazyStringList mountFlags_;
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getMountFlagsList() {
        return mountFlags_;
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public int getMountFlagsCount() {
        return mountFlags_.size();
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public java.lang.String getMountFlags(int index) {
        return mountFlags_.get(index);
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMountFlagsBytes(int index) {
        return mountFlags_.getByteString(index);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getFsTypeBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fsType_);
        }
        for (int i = 0; i < mountFlags_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 2, mountFlags_.getRaw(i));
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getFsTypeBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, fsType_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < mountFlags_.size(); i++) {
            dataSize += computeStringSizeNoTag(mountFlags_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getMountFlagsList().size();
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.VolumeCapability.MountVolume)) {
          return super.equals(obj);
        }
        csi.v1.Csi.VolumeCapability.MountVolume other = (csi.v1.Csi.VolumeCapability.MountVolume) obj;

        boolean result = true;
        result = result && getFsType()
            .equals(other.getFsType());
        result = result && getMountFlagsList()
            .equals(other.getMountFlagsList());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + FS_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFsType().hashCode();
        if (getMountFlagsCount() > 0) {
          hash = (37 * hash) + MOUNT_FLAGS_FIELD_NUMBER;
          hash = (53 * hash) + getMountFlagsList().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.VolumeCapability.MountVolume prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Indicate that the volume will be accessed via the filesystem API.
       * </pre>
       *
       * Protobuf type {@code csi.v1.VolumeCapability.MountVolume}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.VolumeCapability.MountVolume)
          csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_MountVolume_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_MountVolume_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.VolumeCapability.MountVolume.class, csi.v1.Csi.VolumeCapability.MountVolume.Builder.class);
        }

        // Construct using csi.v1.Csi.VolumeCapability.MountVolume.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          fsType_ = "";

          mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_MountVolume_descriptor;
        }

        public csi.v1.Csi.VolumeCapability.MountVolume getDefaultInstanceForType() {
          return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }

        public csi.v1.Csi.VolumeCapability.MountVolume build() {
          csi.v1.Csi.VolumeCapability.MountVolume result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.VolumeCapability.MountVolume buildPartial() {
          csi.v1.Csi.VolumeCapability.MountVolume result = new csi.v1.Csi.VolumeCapability.MountVolume(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          result.fsType_ = fsType_;
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = mountFlags_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.mountFlags_ = mountFlags_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.VolumeCapability.MountVolume) {
            return mergeFrom((csi.v1.Csi.VolumeCapability.MountVolume)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.VolumeCapability.MountVolume other) {
          if (other == csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance()) return this;
          if (!other.getFsType().isEmpty()) {
            fsType_ = other.fsType_;
            onChanged();
          }
          if (!other.mountFlags_.isEmpty()) {
            if (mountFlags_.isEmpty()) {
              mountFlags_ = other.mountFlags_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureMountFlagsIsMutable();
              mountFlags_.addAll(other.mountFlags_);
            }
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.VolumeCapability.MountVolume parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.VolumeCapability.MountVolume) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private java.lang.Object fsType_ = "";
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public java.lang.String getFsType() {
          java.lang.Object ref = fsType_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            fsType_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public com.google.protobuf.ByteString
            getFsTypeBytes() {
          java.lang.Object ref = fsType_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            fsType_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder setFsType(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          fsType_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder clearFsType() {
          
          fsType_ = getDefaultInstance().getFsType();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder setFsTypeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          fsType_ = value;
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureMountFlagsIsMutable() {
          if (!((bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = new com.google.protobuf.LazyStringArrayList(mountFlags_);
            bitField0_ |= 0x00000002;
           }
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getMountFlagsList() {
          return mountFlags_.getUnmodifiableView();
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public int getMountFlagsCount() {
          return mountFlags_.size();
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public java.lang.String getMountFlags(int index) {
          return mountFlags_.get(index);
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public com.google.protobuf.ByteString
            getMountFlagsBytes(int index) {
          return mountFlags_.getByteString(index);
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder setMountFlags(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureMountFlagsIsMutable();
          mountFlags_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addMountFlags(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureMountFlagsIsMutable();
          mountFlags_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addAllMountFlags(
            java.lang.Iterable<java.lang.String> values) {
          ensureMountFlagsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mountFlags_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder clearMountFlags() {
          mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addMountFlagsBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureMountFlagsIsMutable();
          mountFlags_.add(value);
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.VolumeCapability.MountVolume)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.MountVolume)
      private static final csi.v1.Csi.VolumeCapability.MountVolume DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.VolumeCapability.MountVolume();
      }

      public static csi.v1.Csi.VolumeCapability.MountVolume getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<MountVolume>
          PARSER = new com.google.protobuf.AbstractParser<MountVolume>() {
        public MountVolume parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new MountVolume(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<MountVolume> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<MountVolume> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.VolumeCapability.MountVolume getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface AccessModeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.VolumeCapability.AccessMode)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      int getModeValue();
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      csi.v1.Csi.VolumeCapability.AccessMode.Mode getMode();
    }
    /**
     * <pre>
     * Specify how a volume can be accessed.
     * </pre>
     *
     * Protobuf type {@code csi.v1.VolumeCapability.AccessMode}
     */
    public  static final class AccessMode extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.VolumeCapability.AccessMode)
        AccessModeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use AccessMode.newBuilder() to construct.
      private AccessMode(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private AccessMode() {
        mode_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private AccessMode(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 8: {
                int rawValue = input.readEnum();

                mode_ = rawValue;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_AccessMode_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_AccessMode_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeCapability.AccessMode.class, csi.v1.Csi.VolumeCapability.AccessMode.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v1.VolumeCapability.AccessMode.Mode}
       */
      public enum Mode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <pre>
         * Can only be published once as read/write on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_WRITER = 1;</code>
         */
        SINGLE_NODE_WRITER(1),
        /**
         * <pre>
         * Can only be published once as readonly on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_READER_ONLY = 2;</code>
         */
        SINGLE_NODE_READER_ONLY(2),
        /**
         * <pre>
         * Can be published as readonly at multiple nodes simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_READER_ONLY = 3;</code>
         */
        MULTI_NODE_READER_ONLY(3),
        /**
         * <pre>
         * Can be published at multiple nodes simultaneously. Only one of
         * the node can be used as read/write. The rest will be readonly.
         * </pre>
         *
         * <code>MULTI_NODE_SINGLE_WRITER = 4;</code>
         */
        MULTI_NODE_SINGLE_WRITER(4),
        /**
         * <pre>
         * Can be published as read/write at multiple nodes
         * simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_MULTI_WRITER = 5;</code>
         */
        MULTI_NODE_MULTI_WRITER(5),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <pre>
         * Can only be published once as read/write on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_WRITER = 1;</code>
         */
        public static final int SINGLE_NODE_WRITER_VALUE = 1;
        /**
         * <pre>
         * Can only be published once as readonly on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_READER_ONLY = 2;</code>
         */
        public static final int SINGLE_NODE_READER_ONLY_VALUE = 2;
        /**
         * <pre>
         * Can be published as readonly at multiple nodes simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_READER_ONLY = 3;</code>
         */
        public static final int MULTI_NODE_READER_ONLY_VALUE = 3;
        /**
         * <pre>
         * Can be published at multiple nodes simultaneously. Only one of
         * the node can be used as read/write. The rest will be readonly.
         * </pre>
         *
         * <code>MULTI_NODE_SINGLE_WRITER = 4;</code>
         */
        public static final int MULTI_NODE_SINGLE_WRITER_VALUE = 4;
        /**
         * <pre>
         * Can be published as read/write at multiple nodes
         * simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_MULTI_WRITER = 5;</code>
         */
        public static final int MULTI_NODE_MULTI_WRITER_VALUE = 5;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Mode valueOf(int value) {
          return forNumber(value);
        }

        public static Mode forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return SINGLE_NODE_WRITER;
            case 2: return SINGLE_NODE_READER_ONLY;
            case 3: return MULTI_NODE_READER_ONLY;
            case 4: return MULTI_NODE_SINGLE_WRITER;
            case 5: return MULTI_NODE_MULTI_WRITER;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Mode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Mode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Mode>() {
                public Mode findValueByNumber(int number) {
                  return Mode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v1.Csi.VolumeCapability.AccessMode.getDescriptor().getEnumTypes().get(0);
        }

        private static final Mode[] VALUES = values();

        public static Mode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Mode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v1.VolumeCapability.AccessMode.Mode)
      }

      public static final int MODE_FIELD_NUMBER = 1;
      private int mode_;
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      public int getModeValue() {
        return mode_;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.AccessMode.Mode getMode() {
        csi.v1.Csi.VolumeCapability.AccessMode.Mode result = csi.v1.Csi.VolumeCapability.AccessMode.Mode.valueOf(mode_);
        return result == null ? csi.v1.Csi.VolumeCapability.AccessMode.Mode.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (mode_ != csi.v1.Csi.VolumeCapability.AccessMode.Mode.UNKNOWN.getNumber()) {
          output.writeEnum(1, mode_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (mode_ != csi.v1.Csi.VolumeCapability.AccessMode.Mode.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, mode_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.VolumeCapability.AccessMode)) {
          return super.equals(obj);
        }
        csi.v1.Csi.VolumeCapability.AccessMode other = (csi.v1.Csi.VolumeCapability.AccessMode) obj;

        boolean result = true;
        result = result && mode_ == other.mode_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.VolumeCapability.AccessMode prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Specify how a volume can be accessed.
       * </pre>
       *
       * Protobuf type {@code csi.v1.VolumeCapability.AccessMode}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.VolumeCapability.AccessMode)
          csi.v1.Csi.VolumeCapability.AccessModeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_AccessMode_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_AccessMode_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.VolumeCapability.AccessMode.class, csi.v1.Csi.VolumeCapability.AccessMode.Builder.class);
        }

        // Construct using csi.v1.Csi.VolumeCapability.AccessMode.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          mode_ = 0;

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_AccessMode_descriptor;
        }

        public csi.v1.Csi.VolumeCapability.AccessMode getDefaultInstanceForType() {
          return csi.v1.Csi.VolumeCapability.AccessMode.getDefaultInstance();
        }

        public csi.v1.Csi.VolumeCapability.AccessMode build() {
          csi.v1.Csi.VolumeCapability.AccessMode result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.VolumeCapability.AccessMode buildPartial() {
          csi.v1.Csi.VolumeCapability.AccessMode result = new csi.v1.Csi.VolumeCapability.AccessMode(this);
          result.mode_ = mode_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.VolumeCapability.AccessMode) {
            return mergeFrom((csi.v1.Csi.VolumeCapability.AccessMode)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.VolumeCapability.AccessMode other) {
          if (other == csi.v1.Csi.VolumeCapability.AccessMode.getDefaultInstance()) return this;
          if (other.mode_ != 0) {
            setModeValue(other.getModeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.VolumeCapability.AccessMode parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.VolumeCapability.AccessMode) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int mode_ = 0;
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public int getModeValue() {
          return mode_;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder setModeValue(int value) {
          mode_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public csi.v1.Csi.VolumeCapability.AccessMode.Mode getMode() {
          csi.v1.Csi.VolumeCapability.AccessMode.Mode result = csi.v1.Csi.VolumeCapability.AccessMode.Mode.valueOf(mode_);
          return result == null ? csi.v1.Csi.VolumeCapability.AccessMode.Mode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder setMode(csi.v1.Csi.VolumeCapability.AccessMode.Mode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          mode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v1.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder clearMode() {
          
          mode_ = 0;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.VolumeCapability.AccessMode)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.AccessMode)
      private static final csi.v1.Csi.VolumeCapability.AccessMode DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.VolumeCapability.AccessMode();
      }

      public static csi.v1.Csi.VolumeCapability.AccessMode getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<AccessMode>
          PARSER = new com.google.protobuf.AbstractParser<AccessMode>() {
        public AccessMode parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new AccessMode(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<AccessMode> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<AccessMode> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.VolumeCapability.AccessMode getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int accessTypeCase_ = 0;
    private java.lang.Object accessType_;
    public enum AccessTypeCase
        implements com.google.protobuf.Internal.EnumLite {
      BLOCK(1),
      MOUNT(2),
      ACCESSTYPE_NOT_SET(0);
      private final int value;
      private AccessTypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AccessTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static AccessTypeCase forNumber(int value) {
        switch (value) {
          case 1: return BLOCK;
          case 2: return MOUNT;
          case 0: return ACCESSTYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public AccessTypeCase
    getAccessTypeCase() {
      return AccessTypeCase.forNumber(
          accessTypeCase_);
    }

    public static final int BLOCK_FIELD_NUMBER = 1;
    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    public boolean hasBlock() {
      return accessTypeCase_ == 1;
    }
    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    public csi.v1.Csi.VolumeCapability.BlockVolume getBlock() {
      if (accessTypeCase_ == 1) {
         return (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_;
      }
      return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
    }
    /**
     * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
     */
    public csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder() {
      if (accessTypeCase_ == 1) {
         return (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_;
      }
      return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
    }

    public static final int MOUNT_FIELD_NUMBER = 2;
    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    public boolean hasMount() {
      return accessTypeCase_ == 2;
    }
    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    public csi.v1.Csi.VolumeCapability.MountVolume getMount() {
      if (accessTypeCase_ == 2) {
         return (csi.v1.Csi.VolumeCapability.MountVolume) accessType_;
      }
      return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
    }
    /**
     * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
     */
    public csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder() {
      if (accessTypeCase_ == 2) {
         return (csi.v1.Csi.VolumeCapability.MountVolume) accessType_;
      }
      return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
    }

    public static final int ACCESS_MODE_FIELD_NUMBER = 3;
    private csi.v1.Csi.VolumeCapability.AccessMode accessMode_;
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public boolean hasAccessMode() {
      return accessMode_ != null;
    }
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public csi.v1.Csi.VolumeCapability.AccessMode getAccessMode() {
      return accessMode_ == null ? csi.v1.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
    }
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public csi.v1.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder() {
      return getAccessMode();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (accessTypeCase_ == 1) {
        output.writeMessage(1, (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_);
      }
      if (accessTypeCase_ == 2) {
        output.writeMessage(2, (csi.v1.Csi.VolumeCapability.MountVolume) accessType_);
      }
      if (accessMode_ != null) {
        output.writeMessage(3, getAccessMode());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (accessTypeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_);
      }
      if (accessTypeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (csi.v1.Csi.VolumeCapability.MountVolume) accessType_);
      }
      if (accessMode_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessMode());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.VolumeCapability)) {
        return super.equals(obj);
      }
      csi.v1.Csi.VolumeCapability other = (csi.v1.Csi.VolumeCapability) obj;

      boolean result = true;
      result = result && (hasAccessMode() == other.hasAccessMode());
      if (hasAccessMode()) {
        result = result && getAccessMode()
            .equals(other.getAccessMode());
      }
      result = result && getAccessTypeCase().equals(
          other.getAccessTypeCase());
      if (!result) return false;
      switch (accessTypeCase_) {
        case 1:
          result = result && getBlock()
              .equals(other.getBlock());
          break;
        case 2:
          result = result && getMount()
              .equals(other.getMount());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAccessMode()) {
        hash = (37 * hash) + ACCESS_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getAccessMode().hashCode();
      }
      switch (accessTypeCase_) {
        case 1:
          hash = (37 * hash) + BLOCK_FIELD_NUMBER;
          hash = (53 * hash) + getBlock().hashCode();
          break;
        case 2:
          hash = (37 * hash) + MOUNT_FIELD_NUMBER;
          hash = (53 * hash) + getMount().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.VolumeCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.VolumeCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specify a capability of a volume.
     * </pre>
     *
     * Protobuf type {@code csi.v1.VolumeCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.VolumeCapability)
        csi.v1.Csi.VolumeCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeCapability.class, csi.v1.Csi.VolumeCapability.Builder.class);
      }

      // Construct using csi.v1.Csi.VolumeCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (accessModeBuilder_ == null) {
          accessMode_ = null;
        } else {
          accessMode_ = null;
          accessModeBuilder_ = null;
        }
        accessTypeCase_ = 0;
        accessType_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeCapability_descriptor;
      }

      public csi.v1.Csi.VolumeCapability getDefaultInstanceForType() {
        return csi.v1.Csi.VolumeCapability.getDefaultInstance();
      }

      public csi.v1.Csi.VolumeCapability build() {
        csi.v1.Csi.VolumeCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.VolumeCapability buildPartial() {
        csi.v1.Csi.VolumeCapability result = new csi.v1.Csi.VolumeCapability(this);
        if (accessTypeCase_ == 1) {
          if (blockBuilder_ == null) {
            result.accessType_ = accessType_;
          } else {
            result.accessType_ = blockBuilder_.build();
          }
        }
        if (accessTypeCase_ == 2) {
          if (mountBuilder_ == null) {
            result.accessType_ = accessType_;
          } else {
            result.accessType_ = mountBuilder_.build();
          }
        }
        if (accessModeBuilder_ == null) {
          result.accessMode_ = accessMode_;
        } else {
          result.accessMode_ = accessModeBuilder_.build();
        }
        result.accessTypeCase_ = accessTypeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.VolumeCapability) {
          return mergeFrom((csi.v1.Csi.VolumeCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.VolumeCapability other) {
        if (other == csi.v1.Csi.VolumeCapability.getDefaultInstance()) return this;
        if (other.hasAccessMode()) {
          mergeAccessMode(other.getAccessMode());
        }
        switch (other.getAccessTypeCase()) {
          case BLOCK: {
            mergeBlock(other.getBlock());
            break;
          }
          case MOUNT: {
            mergeMount(other.getMount());
            break;
          }
          case ACCESSTYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.VolumeCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.VolumeCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int accessTypeCase_ = 0;
      private java.lang.Object accessType_;
      public AccessTypeCase
          getAccessTypeCase() {
        return AccessTypeCase.forNumber(
            accessTypeCase_);
      }

      public Builder clearAccessType() {
        accessTypeCase_ = 0;
        accessType_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.BlockVolume, csi.v1.Csi.VolumeCapability.BlockVolume.Builder, csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder> blockBuilder_;
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public boolean hasBlock() {
        return accessTypeCase_ == 1;
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.BlockVolume getBlock() {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1) {
            return (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_;
          }
          return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        } else {
          if (accessTypeCase_ == 1) {
            return blockBuilder_.getMessage();
          }
          return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder setBlock(csi.v1.Csi.VolumeCapability.BlockVolume value) {
        if (blockBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessType_ = value;
          onChanged();
        } else {
          blockBuilder_.setMessage(value);
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder setBlock(
          csi.v1.Csi.VolumeCapability.BlockVolume.Builder builderForValue) {
        if (blockBuilder_ == null) {
          accessType_ = builderForValue.build();
          onChanged();
        } else {
          blockBuilder_.setMessage(builderForValue.build());
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder mergeBlock(csi.v1.Csi.VolumeCapability.BlockVolume value) {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1 &&
              accessType_ != csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance()) {
            accessType_ = csi.v1.Csi.VolumeCapability.BlockVolume.newBuilder((csi.v1.Csi.VolumeCapability.BlockVolume) accessType_)
                .mergeFrom(value).buildPartial();
          } else {
            accessType_ = value;
          }
          onChanged();
        } else {
          if (accessTypeCase_ == 1) {
            blockBuilder_.mergeFrom(value);
          }
          blockBuilder_.setMessage(value);
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder clearBlock() {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1) {
            accessTypeCase_ = 0;
            accessType_ = null;
            onChanged();
          }
        } else {
          if (accessTypeCase_ == 1) {
            accessTypeCase_ = 0;
            accessType_ = null;
          }
          blockBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.BlockVolume.Builder getBlockBuilder() {
        return getBlockFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder() {
        if ((accessTypeCase_ == 1) && (blockBuilder_ != null)) {
          return blockBuilder_.getMessageOrBuilder();
        } else {
          if (accessTypeCase_ == 1) {
            return (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_;
          }
          return csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeCapability.BlockVolume block = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.BlockVolume, csi.v1.Csi.VolumeCapability.BlockVolume.Builder, csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder> 
          getBlockFieldBuilder() {
        if (blockBuilder_ == null) {
          if (!(accessTypeCase_ == 1)) {
            accessType_ = csi.v1.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
          }
          blockBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability.BlockVolume, csi.v1.Csi.VolumeCapability.BlockVolume.Builder, csi.v1.Csi.VolumeCapability.BlockVolumeOrBuilder>(
                  (csi.v1.Csi.VolumeCapability.BlockVolume) accessType_,
                  getParentForChildren(),
                  isClean());
          accessType_ = null;
        }
        accessTypeCase_ = 1;
        onChanged();;
        return blockBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.MountVolume, csi.v1.Csi.VolumeCapability.MountVolume.Builder, csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder> mountBuilder_;
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public boolean hasMount() {
        return accessTypeCase_ == 2;
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v1.Csi.VolumeCapability.MountVolume getMount() {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2) {
            return (csi.v1.Csi.VolumeCapability.MountVolume) accessType_;
          }
          return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        } else {
          if (accessTypeCase_ == 2) {
            return mountBuilder_.getMessage();
          }
          return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder setMount(csi.v1.Csi.VolumeCapability.MountVolume value) {
        if (mountBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessType_ = value;
          onChanged();
        } else {
          mountBuilder_.setMessage(value);
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder setMount(
          csi.v1.Csi.VolumeCapability.MountVolume.Builder builderForValue) {
        if (mountBuilder_ == null) {
          accessType_ = builderForValue.build();
          onChanged();
        } else {
          mountBuilder_.setMessage(builderForValue.build());
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder mergeMount(csi.v1.Csi.VolumeCapability.MountVolume value) {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2 &&
              accessType_ != csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance()) {
            accessType_ = csi.v1.Csi.VolumeCapability.MountVolume.newBuilder((csi.v1.Csi.VolumeCapability.MountVolume) accessType_)
                .mergeFrom(value).buildPartial();
          } else {
            accessType_ = value;
          }
          onChanged();
        } else {
          if (accessTypeCase_ == 2) {
            mountBuilder_.mergeFrom(value);
          }
          mountBuilder_.setMessage(value);
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder clearMount() {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2) {
            accessTypeCase_ = 0;
            accessType_ = null;
            onChanged();
          }
        } else {
          if (accessTypeCase_ == 2) {
            accessTypeCase_ = 0;
            accessType_ = null;
          }
          mountBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v1.Csi.VolumeCapability.MountVolume.Builder getMountBuilder() {
        return getMountFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder() {
        if ((accessTypeCase_ == 2) && (mountBuilder_ != null)) {
          return mountBuilder_.getMessageOrBuilder();
        } else {
          if (accessTypeCase_ == 2) {
            return (csi.v1.Csi.VolumeCapability.MountVolume) accessType_;
          }
          return csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v1.VolumeCapability.MountVolume mount = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.MountVolume, csi.v1.Csi.VolumeCapability.MountVolume.Builder, csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder> 
          getMountFieldBuilder() {
        if (mountBuilder_ == null) {
          if (!(accessTypeCase_ == 2)) {
            accessType_ = csi.v1.Csi.VolumeCapability.MountVolume.getDefaultInstance();
          }
          mountBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability.MountVolume, csi.v1.Csi.VolumeCapability.MountVolume.Builder, csi.v1.Csi.VolumeCapability.MountVolumeOrBuilder>(
                  (csi.v1.Csi.VolumeCapability.MountVolume) accessType_,
                  getParentForChildren(),
                  isClean());
          accessType_ = null;
        }
        accessTypeCase_ = 2;
        onChanged();;
        return mountBuilder_;
      }

      private csi.v1.Csi.VolumeCapability.AccessMode accessMode_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.AccessMode, csi.v1.Csi.VolumeCapability.AccessMode.Builder, csi.v1.Csi.VolumeCapability.AccessModeOrBuilder> accessModeBuilder_;
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public boolean hasAccessMode() {
        return accessModeBuilder_ != null || accessMode_ != null;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.AccessMode getAccessMode() {
        if (accessModeBuilder_ == null) {
          return accessMode_ == null ? csi.v1.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
        } else {
          return accessModeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder setAccessMode(csi.v1.Csi.VolumeCapability.AccessMode value) {
        if (accessModeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessMode_ = value;
          onChanged();
        } else {
          accessModeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder setAccessMode(
          csi.v1.Csi.VolumeCapability.AccessMode.Builder builderForValue) {
        if (accessModeBuilder_ == null) {
          accessMode_ = builderForValue.build();
          onChanged();
        } else {
          accessModeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder mergeAccessMode(csi.v1.Csi.VolumeCapability.AccessMode value) {
        if (accessModeBuilder_ == null) {
          if (accessMode_ != null) {
            accessMode_ =
              csi.v1.Csi.VolumeCapability.AccessMode.newBuilder(accessMode_).mergeFrom(value).buildPartial();
          } else {
            accessMode_ = value;
          }
          onChanged();
        } else {
          accessModeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder clearAccessMode() {
        if (accessModeBuilder_ == null) {
          accessMode_ = null;
          onChanged();
        } else {
          accessMode_ = null;
          accessModeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.AccessMode.Builder getAccessModeBuilder() {
        
        onChanged();
        return getAccessModeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder() {
        if (accessModeBuilder_ != null) {
          return accessModeBuilder_.getMessageOrBuilder();
        } else {
          return accessMode_ == null ?
              csi.v1.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
        }
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability.AccessMode, csi.v1.Csi.VolumeCapability.AccessMode.Builder, csi.v1.Csi.VolumeCapability.AccessModeOrBuilder> 
          getAccessModeFieldBuilder() {
        if (accessModeBuilder_ == null) {
          accessModeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability.AccessMode, csi.v1.Csi.VolumeCapability.AccessMode.Builder, csi.v1.Csi.VolumeCapability.AccessModeOrBuilder>(
                  getAccessMode(),
                  getParentForChildren(),
                  isClean());
          accessMode_ = null;
        }
        return accessModeBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.VolumeCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability)
    private static final csi.v1.Csi.VolumeCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.VolumeCapability();
    }

    public static csi.v1.Csi.VolumeCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeCapability>
        PARSER = new com.google.protobuf.AbstractParser<VolumeCapability>() {
      public VolumeCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new VolumeCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<VolumeCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeCapability> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.VolumeCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CapacityRangeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.CapacityRange)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Volume MUST be at least this big. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 required_bytes = 1;</code>
     */
    long getRequiredBytes();

    /**
     * <pre>
     * Volume MUST not be bigger than this. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 limit_bytes = 2;</code>
     */
    long getLimitBytes();
  }
  /**
   * <pre>
   * The capacity of the storage space in bytes. To specify an exact size,
   * `required_bytes` and `limit_bytes` SHALL be set to the same value. At
   * least one of the these fields MUST be specified.
   * </pre>
   *
   * Protobuf type {@code csi.v1.CapacityRange}
   */
  public  static final class CapacityRange extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.CapacityRange)
      CapacityRangeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CapacityRange.newBuilder() to construct.
    private CapacityRange(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CapacityRange() {
      requiredBytes_ = 0L;
      limitBytes_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CapacityRange(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              requiredBytes_ = input.readInt64();
              break;
            }
            case 16: {

              limitBytes_ = input.readInt64();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_CapacityRange_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_CapacityRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.CapacityRange.class, csi.v1.Csi.CapacityRange.Builder.class);
    }

    public static final int REQUIRED_BYTES_FIELD_NUMBER = 1;
    private long requiredBytes_;
    /**
     * <pre>
     * Volume MUST be at least this big. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 required_bytes = 1;</code>
     */
    public long getRequiredBytes() {
      return requiredBytes_;
    }

    public static final int LIMIT_BYTES_FIELD_NUMBER = 2;
    private long limitBytes_;
    /**
     * <pre>
     * Volume MUST not be bigger than this. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 limit_bytes = 2;</code>
     */
    public long getLimitBytes() {
      return limitBytes_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (requiredBytes_ != 0L) {
        output.writeInt64(1, requiredBytes_);
      }
      if (limitBytes_ != 0L) {
        output.writeInt64(2, limitBytes_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (requiredBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, requiredBytes_);
      }
      if (limitBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, limitBytes_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.CapacityRange)) {
        return super.equals(obj);
      }
      csi.v1.Csi.CapacityRange other = (csi.v1.Csi.CapacityRange) obj;

      boolean result = true;
      result = result && (getRequiredBytes()
          == other.getRequiredBytes());
      result = result && (getLimitBytes()
          == other.getLimitBytes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + REQUIRED_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRequiredBytes());
      hash = (37 * hash) + LIMIT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLimitBytes());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.CapacityRange parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CapacityRange parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CapacityRange parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CapacityRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.CapacityRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The capacity of the storage space in bytes. To specify an exact size,
     * `required_bytes` and `limit_bytes` SHALL be set to the same value. At
     * least one of the these fields MUST be specified.
     * </pre>
     *
     * Protobuf type {@code csi.v1.CapacityRange}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.CapacityRange)
        csi.v1.Csi.CapacityRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_CapacityRange_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_CapacityRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.CapacityRange.class, csi.v1.Csi.CapacityRange.Builder.class);
      }

      // Construct using csi.v1.Csi.CapacityRange.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        requiredBytes_ = 0L;

        limitBytes_ = 0L;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_CapacityRange_descriptor;
      }

      public csi.v1.Csi.CapacityRange getDefaultInstanceForType() {
        return csi.v1.Csi.CapacityRange.getDefaultInstance();
      }

      public csi.v1.Csi.CapacityRange build() {
        csi.v1.Csi.CapacityRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.CapacityRange buildPartial() {
        csi.v1.Csi.CapacityRange result = new csi.v1.Csi.CapacityRange(this);
        result.requiredBytes_ = requiredBytes_;
        result.limitBytes_ = limitBytes_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.CapacityRange) {
          return mergeFrom((csi.v1.Csi.CapacityRange)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.CapacityRange other) {
        if (other == csi.v1.Csi.CapacityRange.getDefaultInstance()) return this;
        if (other.getRequiredBytes() != 0L) {
          setRequiredBytes(other.getRequiredBytes());
        }
        if (other.getLimitBytes() != 0L) {
          setLimitBytes(other.getLimitBytes());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.CapacityRange parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.CapacityRange) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long requiredBytes_ ;
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public long getRequiredBytes() {
        return requiredBytes_;
      }
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public Builder setRequiredBytes(long value) {
        
        requiredBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public Builder clearRequiredBytes() {
        
        requiredBytes_ = 0L;
        onChanged();
        return this;
      }

      private long limitBytes_ ;
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public long getLimitBytes() {
        return limitBytes_;
      }
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public Builder setLimitBytes(long value) {
        
        limitBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public Builder clearLimitBytes() {
        
        limitBytes_ = 0L;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.CapacityRange)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.CapacityRange)
    private static final csi.v1.Csi.CapacityRange DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.CapacityRange();
    }

    public static csi.v1.Csi.CapacityRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CapacityRange>
        PARSER = new com.google.protobuf.AbstractParser<CapacityRange>() {
      public CapacityRange parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CapacityRange(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CapacityRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CapacityRange> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.CapacityRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.Volume)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL. If not
     * set (value of 0), it indicates that the capacity of the volume is
     * unknown (e.g., NFS share).
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    long getCapacityBytes();

    /**
     * <pre>
     * The identifier for this volume, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific volume vs all other volumes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this volume.
     * The SP is NOT responsible for global uniqueness of volume_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string volume_id = 2;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The identifier for this volume, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific volume vs all other volumes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this volume.
     * The SP is NOT responsible for global uniqueness of volume_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string volume_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */
    int getVolumeContextCount();
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */
    boolean containsVolumeContext(
        java.lang.String key);
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContext();
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContextMap();
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    java.lang.String getVolumeContextOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    boolean hasContentSource();
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    csi.v1.Csi.VolumeContentSource getContentSource();
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    csi.v1.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    java.util.List<csi.v1.Csi.Topology> 
        getAccessibleTopologyList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    csi.v1.Csi.Topology getAccessibleTopology(int index);
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    int getAccessibleTopologyCount();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Information about a specific volume.
   * </pre>
   *
   * Protobuf type {@code csi.v1.Volume}
   */
  public  static final class Volume extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.Volume)
      VolumeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Volume.newBuilder() to construct.
    private Volume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Volume() {
      capacityBytes_ = 0L;
      volumeId_ = "";
      accessibleTopology_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Volume(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              capacityBytes_ = input.readInt64();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                volumeContext_ = com.google.protobuf.MapField.newMapField(
                    VolumeContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeContext__ = input.readMessage(
                  VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeContext_.getMutableMap().put(
                  volumeContext__.getKey(), volumeContext__.getValue());
              break;
            }
            case 34: {
              csi.v1.Csi.VolumeContentSource.Builder subBuilder = null;
              if (contentSource_ != null) {
                subBuilder = contentSource_.toBuilder();
              }
              contentSource_ = input.readMessage(csi.v1.Csi.VolumeContentSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(contentSource_);
                contentSource_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                accessibleTopology_ = new java.util.ArrayList<csi.v1.Csi.Topology>();
                mutable_bitField0_ |= 0x00000010;
              }
              accessibleTopology_.add(
                  input.readMessage(csi.v1.Csi.Topology.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_Volume_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetVolumeContext();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_Volume_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.Volume.class, csi.v1.Csi.Volume.Builder.class);
    }

    private int bitField0_;
    public static final int CAPACITY_BYTES_FIELD_NUMBER = 1;
    private long capacityBytes_;
    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL. If not
     * set (value of 0), it indicates that the capacity of the volume is
     * unknown (e.g., NFS share).
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    public long getCapacityBytes() {
      return capacityBytes_;
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The identifier for this volume, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific volume vs all other volumes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this volume.
     * The SP is NOT responsible for global uniqueness of volume_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string volume_id = 2;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The identifier for this volume, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific volume vs all other volumes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this volume.
     * The SP is NOT responsible for global uniqueness of volume_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string volume_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CONTEXT_FIELD_NUMBER = 3;
    private static final class VolumeContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_Volume_VolumeContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeContext() {
      if (volumeContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeContextDefaultEntryHolder.defaultEntry);
      }
      return volumeContext_;
    }

    public int getVolumeContextCount() {
      return internalGetVolumeContext().getMap().size();
    }
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    public boolean containsVolumeContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
      return getVolumeContextMap();
    }
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
      return internalGetVolumeContext().getMap();
    }
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    public java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Opaque static properties of the volume. SP MAY use this field to
     * ensure subsequent volume validation and publishing calls have
     * contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * A volume uniquely identified by `volume_id` SHALL always report the
     * same volume_context.
     * This field is OPTIONAL and when present MUST be passed to volume
     * validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 3;</code>
     */

    public java.lang.String getVolumeContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int CONTENT_SOURCE_FIELD_NUMBER = 4;
    private csi.v1.Csi.VolumeContentSource contentSource_;
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    public boolean hasContentSource() {
      return contentSource_ != null;
    }
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    public csi.v1.Csi.VolumeContentSource getContentSource() {
      return contentSource_ == null ? csi.v1.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
    }
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
     */
    public csi.v1.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder() {
      return getContentSource();
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 5;
    private java.util.List<csi.v1.Csi.Topology> accessibleTopology_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    public java.util.List<csi.v1.Csi.Topology> getAccessibleTopologyList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    public int getAccessibleTopologyCount() {
      return accessibleTopology_.size();
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    public csi.v1.Csi.Topology getAccessibleTopology(int index) {
      return accessibleTopology_.get(index);
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * MAY schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
     */
    public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index) {
      return accessibleTopology_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (capacityBytes_ != 0L) {
        output.writeInt64(1, capacityBytes_);
      }
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeContext(),
          VolumeContextDefaultEntryHolder.defaultEntry,
          3);
      if (contentSource_ != null) {
        output.writeMessage(4, getContentSource());
      }
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        output.writeMessage(5, accessibleTopology_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (capacityBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, capacityBytes_);
      }
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, volumeContext__);
      }
      if (contentSource_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getContentSource());
      }
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, accessibleTopology_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.Volume)) {
        return super.equals(obj);
      }
      csi.v1.Csi.Volume other = (csi.v1.Csi.Volume) obj;

      boolean result = true;
      result = result && (getCapacityBytes()
          == other.getCapacityBytes());
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetVolumeContext().equals(
          other.internalGetVolumeContext());
      result = result && (hasContentSource() == other.hasContentSource());
      if (hasContentSource()) {
        result = result && getContentSource()
            .equals(other.getContentSource());
      }
      result = result && getAccessibleTopologyList()
          .equals(other.getAccessibleTopologyList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CAPACITY_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapacityBytes());
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetVolumeContext().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeContext().hashCode();
      }
      if (hasContentSource()) {
        hash = (37 * hash) + CONTENT_SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getContentSource().hashCode();
      }
      if (getAccessibleTopologyCount() > 0) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopologyList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.Volume parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Volume parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Volume parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Volume parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Volume parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Volume parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Volume parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Volume parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Volume parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Volume parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Volume parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Volume parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.Volume prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Information about a specific volume.
     * </pre>
     *
     * Protobuf type {@code csi.v1.Volume}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.Volume)
        csi.v1.Csi.VolumeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_Volume_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_Volume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.Volume.class, csi.v1.Csi.Volume.Builder.class);
      }

      // Construct using csi.v1.Csi.Volume.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getAccessibleTopologyFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        capacityBytes_ = 0L;

        volumeId_ = "";

        internalGetMutableVolumeContext().clear();
        if (contentSourceBuilder_ == null) {
          contentSource_ = null;
        } else {
          contentSource_ = null;
          contentSourceBuilder_ = null;
        }
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_Volume_descriptor;
      }

      public csi.v1.Csi.Volume getDefaultInstanceForType() {
        return csi.v1.Csi.Volume.getDefaultInstance();
      }

      public csi.v1.Csi.Volume build() {
        csi.v1.Csi.Volume result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.Volume buildPartial() {
        csi.v1.Csi.Volume result = new csi.v1.Csi.Volume(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.capacityBytes_ = capacityBytes_;
        result.volumeId_ = volumeId_;
        result.volumeContext_ = internalGetVolumeContext();
        result.volumeContext_.makeImmutable();
        if (contentSourceBuilder_ == null) {
          result.contentSource_ = contentSource_;
        } else {
          result.contentSource_ = contentSourceBuilder_.build();
        }
        if (accessibleTopologyBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.Volume) {
          return mergeFrom((csi.v1.Csi.Volume)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.Volume other) {
        if (other == csi.v1.Csi.Volume.getDefaultInstance()) return this;
        if (other.getCapacityBytes() != 0L) {
          setCapacityBytes(other.getCapacityBytes());
        }
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutableVolumeContext().mergeFrom(
            other.internalGetVolumeContext());
        if (other.hasContentSource()) {
          mergeContentSource(other.getContentSource());
        }
        if (accessibleTopologyBuilder_ == null) {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopology_.isEmpty()) {
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAccessibleTopologyIsMutable();
              accessibleTopology_.addAll(other.accessibleTopology_);
            }
            onChanged();
          }
        } else {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopologyBuilder_.isEmpty()) {
              accessibleTopologyBuilder_.dispose();
              accessibleTopologyBuilder_ = null;
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000010);
              accessibleTopologyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAccessibleTopologyFieldBuilder() : null;
            } else {
              accessibleTopologyBuilder_.addAllMessages(other.accessibleTopology_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.Volume parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.Volume) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long capacityBytes_ ;
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public long getCapacityBytes() {
        return capacityBytes_;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder setCapacityBytes(long value) {
        
        capacityBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder clearCapacityBytes() {
        
        capacityBytes_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The identifier for this volume, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific volume vs all other volumes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this volume.
       * The SP is NOT responsible for global uniqueness of volume_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string volume_id = 2;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The identifier for this volume, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific volume vs all other volumes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this volume.
       * The SP is NOT responsible for global uniqueness of volume_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string volume_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The identifier for this volume, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific volume vs all other volumes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this volume.
       * The SP is NOT responsible for global uniqueness of volume_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string volume_id = 2;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier for this volume, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific volume vs all other volumes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this volume.
       * The SP is NOT responsible for global uniqueness of volume_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string volume_id = 2;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier for this volume, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific volume vs all other volumes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this volume.
       * The SP is NOT responsible for global uniqueness of volume_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string volume_id = 2;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeContext() {
        onChanged();;
        if (volumeContext_ == null) {
          volumeContext_ = com.google.protobuf.MapField.newMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        if (!volumeContext_.isMutable()) {
          volumeContext_ = volumeContext_.copy();
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeContext() {
        internalGetMutableVolumeContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public Builder removeVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeContext() {
        return internalGetMutableVolumeContext().getMutableMap();
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */
      public Builder putVolumeContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Opaque static properties of the volume. SP MAY use this field to
       * ensure subsequent volume validation and publishing calls have
       * contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * A volume uniquely identified by `volume_id` SHALL always report the
       * same volume_context.
       * This field is OPTIONAL and when present MUST be passed to volume
       * validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 3;</code>
       */

      public Builder putAllVolumeContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeContext().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v1.Csi.VolumeContentSource contentSource_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder> contentSourceBuilder_;
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public boolean hasContentSource() {
        return contentSourceBuilder_ != null || contentSource_ != null;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public csi.v1.Csi.VolumeContentSource getContentSource() {
        if (contentSourceBuilder_ == null) {
          return contentSource_ == null ? csi.v1.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
        } else {
          return contentSourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public Builder setContentSource(csi.v1.Csi.VolumeContentSource value) {
        if (contentSourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          contentSource_ = value;
          onChanged();
        } else {
          contentSourceBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public Builder setContentSource(
          csi.v1.Csi.VolumeContentSource.Builder builderForValue) {
        if (contentSourceBuilder_ == null) {
          contentSource_ = builderForValue.build();
          onChanged();
        } else {
          contentSourceBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public Builder mergeContentSource(csi.v1.Csi.VolumeContentSource value) {
        if (contentSourceBuilder_ == null) {
          if (contentSource_ != null) {
            contentSource_ =
              csi.v1.Csi.VolumeContentSource.newBuilder(contentSource_).mergeFrom(value).buildPartial();
          } else {
            contentSource_ = value;
          }
          onChanged();
        } else {
          contentSourceBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public Builder clearContentSource() {
        if (contentSourceBuilder_ == null) {
          contentSource_ = null;
          onChanged();
        } else {
          contentSource_ = null;
          contentSourceBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public csi.v1.Csi.VolumeContentSource.Builder getContentSourceBuilder() {
        
        onChanged();
        return getContentSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      public csi.v1.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder() {
        if (contentSourceBuilder_ != null) {
          return contentSourceBuilder_.getMessageOrBuilder();
        } else {
          return contentSource_ == null ?
              csi.v1.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
        }
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.VolumeContentSource content_source = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder> 
          getContentSourceFieldBuilder() {
        if (contentSourceBuilder_ == null) {
          contentSourceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeContentSource, csi.v1.Csi.VolumeContentSource.Builder, csi.v1.Csi.VolumeContentSourceOrBuilder>(
                  getContentSource(),
                  getParentForChildren(),
                  isClean());
          contentSource_ = null;
        }
        return contentSourceBuilder_;
      }

      private java.util.List<csi.v1.Csi.Topology> accessibleTopology_ =
        java.util.Collections.emptyList();
      private void ensureAccessibleTopologyIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          accessibleTopology_ = new java.util.ArrayList<csi.v1.Csi.Topology>(accessibleTopology_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;

      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public java.util.List<csi.v1.Csi.Topology> getAccessibleTopologyList() {
        if (accessibleTopologyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        } else {
          return accessibleTopologyBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public int getAccessibleTopologyCount() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.size();
        } else {
          return accessibleTopologyBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public csi.v1.Csi.Topology getAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);
        } else {
          return accessibleTopologyBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          csi.v1.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder addAllAccessibleTopology(
          java.lang.Iterable<? extends csi.v1.Csi.Topology> values) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, accessibleTopology_);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public Builder removeAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.remove(index);
          onChanged();
        } else {
          accessibleTopologyBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public csi.v1.Csi.Topology.Builder getAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
          int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);  } else {
          return accessibleTopologyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
           getAccessibleTopologyOrBuilderList() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public csi.v1.Csi.Topology.Builder addAccessibleTopologyBuilder() {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public csi.v1.Csi.Topology.Builder addAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            index, csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * MAY schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology accessible_topology = 5;</code>
       */
      public java.util.List<csi.v1.Csi.Topology.Builder> 
           getAccessibleTopologyBuilderList() {
        return getAccessibleTopologyFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder>(
                  accessibleTopology_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.Volume)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.Volume)
    private static final csi.v1.Csi.Volume DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.Volume();
    }

    public static csi.v1.Csi.Volume getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Volume>
        PARSER = new com.google.protobuf.AbstractParser<Volume>() {
      public Volume parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Volume(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Volume> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Volume> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.Volume getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TopologyRequirementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.TopologyRequirement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    java.util.List<csi.v1.Csi.Topology> 
        getRequisiteList();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    csi.v1.Csi.Topology getRequisite(int index);
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    int getRequisiteCount();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getRequisiteOrBuilderList();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    csi.v1.Csi.TopologyOrBuilder getRequisiteOrBuilder(
        int index);

    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    java.util.List<csi.v1.Csi.Topology> 
        getPreferredList();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    csi.v1.Csi.Topology getPreferred(int index);
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    int getPreferredCount();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getPreferredOrBuilderList();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    csi.v1.Csi.TopologyOrBuilder getPreferredOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v1.TopologyRequirement}
   */
  public  static final class TopologyRequirement extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.TopologyRequirement)
      TopologyRequirementOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TopologyRequirement.newBuilder() to construct.
    private TopologyRequirement(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TopologyRequirement() {
      requisite_ = java.util.Collections.emptyList();
      preferred_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TopologyRequirement(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                requisite_ = new java.util.ArrayList<csi.v1.Csi.Topology>();
                mutable_bitField0_ |= 0x00000001;
              }
              requisite_.add(
                  input.readMessage(csi.v1.Csi.Topology.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                preferred_ = new java.util.ArrayList<csi.v1.Csi.Topology>();
                mutable_bitField0_ |= 0x00000002;
              }
              preferred_.add(
                  input.readMessage(csi.v1.Csi.Topology.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          requisite_ = java.util.Collections.unmodifiableList(requisite_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          preferred_ = java.util.Collections.unmodifiableList(preferred_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_TopologyRequirement_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_TopologyRequirement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.TopologyRequirement.class, csi.v1.Csi.TopologyRequirement.Builder.class);
    }

    public static final int REQUISITE_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.Topology> requisite_;
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    public java.util.List<csi.v1.Csi.Topology> getRequisiteList() {
      return requisite_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getRequisiteOrBuilderList() {
      return requisite_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    public int getRequisiteCount() {
      return requisite_.size();
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    public csi.v1.Csi.Topology getRequisite(int index) {
      return requisite_.get(index);
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, then the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, then the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, then the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v1.Topology requisite = 1;</code>
     */
    public csi.v1.Csi.TopologyOrBuilder getRequisiteOrBuilder(
        int index) {
      return requisite_.get(index);
    }

    public static final int PREFERRED_FIELD_NUMBER = 2;
    private java.util.List<csi.v1.Csi.Topology> preferred_;
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    public java.util.List<csi.v1.Csi.Topology> getPreferredList() {
      return preferred_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
        getPreferredOrBuilderList() {
      return preferred_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    public int getPreferredCount() {
      return preferred_.size();
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    public csi.v1.Csi.Topology getPreferred(int index) {
      return preferred_.get(index);
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v1.Topology preferred = 2;</code>
     */
    public csi.v1.Csi.TopologyOrBuilder getPreferredOrBuilder(
        int index) {
      return preferred_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < requisite_.size(); i++) {
        output.writeMessage(1, requisite_.get(i));
      }
      for (int i = 0; i < preferred_.size(); i++) {
        output.writeMessage(2, preferred_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < requisite_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, requisite_.get(i));
      }
      for (int i = 0; i < preferred_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, preferred_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.TopologyRequirement)) {
        return super.equals(obj);
      }
      csi.v1.Csi.TopologyRequirement other = (csi.v1.Csi.TopologyRequirement) obj;

      boolean result = true;
      result = result && getRequisiteList()
          .equals(other.getRequisiteList());
      result = result && getPreferredList()
          .equals(other.getPreferredList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRequisiteCount() > 0) {
        hash = (37 * hash) + REQUISITE_FIELD_NUMBER;
        hash = (53 * hash) + getRequisiteList().hashCode();
      }
      if (getPreferredCount() > 0) {
        hash = (37 * hash) + PREFERRED_FIELD_NUMBER;
        hash = (53 * hash) + getPreferredList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.TopologyRequirement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.TopologyRequirement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.TopologyRequirement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.TopologyRequirement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.TopologyRequirement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.TopologyRequirement)
        csi.v1.Csi.TopologyRequirementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_TopologyRequirement_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_TopologyRequirement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.TopologyRequirement.class, csi.v1.Csi.TopologyRequirement.Builder.class);
      }

      // Construct using csi.v1.Csi.TopologyRequirement.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRequisiteFieldBuilder();
          getPreferredFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (requisiteBuilder_ == null) {
          requisite_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          requisiteBuilder_.clear();
        }
        if (preferredBuilder_ == null) {
          preferred_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          preferredBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_TopologyRequirement_descriptor;
      }

      public csi.v1.Csi.TopologyRequirement getDefaultInstanceForType() {
        return csi.v1.Csi.TopologyRequirement.getDefaultInstance();
      }

      public csi.v1.Csi.TopologyRequirement build() {
        csi.v1.Csi.TopologyRequirement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.TopologyRequirement buildPartial() {
        csi.v1.Csi.TopologyRequirement result = new csi.v1.Csi.TopologyRequirement(this);
        int from_bitField0_ = bitField0_;
        if (requisiteBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            requisite_ = java.util.Collections.unmodifiableList(requisite_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.requisite_ = requisite_;
        } else {
          result.requisite_ = requisiteBuilder_.build();
        }
        if (preferredBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            preferred_ = java.util.Collections.unmodifiableList(preferred_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.preferred_ = preferred_;
        } else {
          result.preferred_ = preferredBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.TopologyRequirement) {
          return mergeFrom((csi.v1.Csi.TopologyRequirement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.TopologyRequirement other) {
        if (other == csi.v1.Csi.TopologyRequirement.getDefaultInstance()) return this;
        if (requisiteBuilder_ == null) {
          if (!other.requisite_.isEmpty()) {
            if (requisite_.isEmpty()) {
              requisite_ = other.requisite_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRequisiteIsMutable();
              requisite_.addAll(other.requisite_);
            }
            onChanged();
          }
        } else {
          if (!other.requisite_.isEmpty()) {
            if (requisiteBuilder_.isEmpty()) {
              requisiteBuilder_.dispose();
              requisiteBuilder_ = null;
              requisite_ = other.requisite_;
              bitField0_ = (bitField0_ & ~0x00000001);
              requisiteBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRequisiteFieldBuilder() : null;
            } else {
              requisiteBuilder_.addAllMessages(other.requisite_);
            }
          }
        }
        if (preferredBuilder_ == null) {
          if (!other.preferred_.isEmpty()) {
            if (preferred_.isEmpty()) {
              preferred_ = other.preferred_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensurePreferredIsMutable();
              preferred_.addAll(other.preferred_);
            }
            onChanged();
          }
        } else {
          if (!other.preferred_.isEmpty()) {
            if (preferredBuilder_.isEmpty()) {
              preferredBuilder_.dispose();
              preferredBuilder_ = null;
              preferred_ = other.preferred_;
              bitField0_ = (bitField0_ & ~0x00000002);
              preferredBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPreferredFieldBuilder() : null;
            } else {
              preferredBuilder_.addAllMessages(other.preferred_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.TopologyRequirement parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.TopologyRequirement) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.Topology> requisite_ =
        java.util.Collections.emptyList();
      private void ensureRequisiteIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          requisite_ = new java.util.ArrayList<csi.v1.Csi.Topology>(requisite_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> requisiteBuilder_;

      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public java.util.List<csi.v1.Csi.Topology> getRequisiteList() {
        if (requisiteBuilder_ == null) {
          return java.util.Collections.unmodifiableList(requisite_);
        } else {
          return requisiteBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public int getRequisiteCount() {
        if (requisiteBuilder_ == null) {
          return requisite_.size();
        } else {
          return requisiteBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public csi.v1.Csi.Topology getRequisite(int index) {
        if (requisiteBuilder_ == null) {
          return requisite_.get(index);
        } else {
          return requisiteBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder setRequisite(
          int index, csi.v1.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.set(index, value);
          onChanged();
        } else {
          requisiteBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder setRequisite(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.set(index, builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder addRequisite(csi.v1.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.add(value);
          onChanged();
        } else {
          requisiteBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          int index, csi.v1.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.add(index, value);
          onChanged();
        } else {
          requisiteBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          csi.v1.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.add(builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.add(index, builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder addAllRequisite(
          java.lang.Iterable<? extends csi.v1.Csi.Topology> values) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, requisite_);
          onChanged();
        } else {
          requisiteBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder clearRequisite() {
        if (requisiteBuilder_ == null) {
          requisite_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          requisiteBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public Builder removeRequisite(int index) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.remove(index);
          onChanged();
        } else {
          requisiteBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public csi.v1.Csi.Topology.Builder getRequisiteBuilder(
          int index) {
        return getRequisiteFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public csi.v1.Csi.TopologyOrBuilder getRequisiteOrBuilder(
          int index) {
        if (requisiteBuilder_ == null) {
          return requisite_.get(index);  } else {
          return requisiteBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
           getRequisiteOrBuilderList() {
        if (requisiteBuilder_ != null) {
          return requisiteBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(requisite_);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public csi.v1.Csi.Topology.Builder addRequisiteBuilder() {
        return getRequisiteFieldBuilder().addBuilder(
            csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public csi.v1.Csi.Topology.Builder addRequisiteBuilder(
          int index) {
        return getRequisiteFieldBuilder().addBuilder(
            index, csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, then the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, then the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, then the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v1.Topology requisite = 1;</code>
       */
      public java.util.List<csi.v1.Csi.Topology.Builder> 
           getRequisiteBuilderList() {
        return getRequisiteFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> 
          getRequisiteFieldBuilder() {
        if (requisiteBuilder_ == null) {
          requisiteBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder>(
                  requisite_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          requisite_ = null;
        }
        return requisiteBuilder_;
      }

      private java.util.List<csi.v1.Csi.Topology> preferred_ =
        java.util.Collections.emptyList();
      private void ensurePreferredIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          preferred_ = new java.util.ArrayList<csi.v1.Csi.Topology>(preferred_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> preferredBuilder_;

      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public java.util.List<csi.v1.Csi.Topology> getPreferredList() {
        if (preferredBuilder_ == null) {
          return java.util.Collections.unmodifiableList(preferred_);
        } else {
          return preferredBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public int getPreferredCount() {
        if (preferredBuilder_ == null) {
          return preferred_.size();
        } else {
          return preferredBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public csi.v1.Csi.Topology getPreferred(int index) {
        if (preferredBuilder_ == null) {
          return preferred_.get(index);
        } else {
          return preferredBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder setPreferred(
          int index, csi.v1.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.set(index, value);
          onChanged();
        } else {
          preferredBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder setPreferred(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.set(index, builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder addPreferred(csi.v1.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.add(value);
          onChanged();
        } else {
          preferredBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          int index, csi.v1.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.add(index, value);
          onChanged();
        } else {
          preferredBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          csi.v1.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.add(builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          int index, csi.v1.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.add(index, builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder addAllPreferred(
          java.lang.Iterable<? extends csi.v1.Csi.Topology> values) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, preferred_);
          onChanged();
        } else {
          preferredBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder clearPreferred() {
        if (preferredBuilder_ == null) {
          preferred_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          preferredBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public Builder removePreferred(int index) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.remove(index);
          onChanged();
        } else {
          preferredBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public csi.v1.Csi.Topology.Builder getPreferredBuilder(
          int index) {
        return getPreferredFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public csi.v1.Csi.TopologyOrBuilder getPreferredOrBuilder(
          int index) {
        if (preferredBuilder_ == null) {
          return preferred_.get(index);  } else {
          return preferredBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public java.util.List<? extends csi.v1.Csi.TopologyOrBuilder> 
           getPreferredOrBuilderList() {
        if (preferredBuilder_ != null) {
          return preferredBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(preferred_);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public csi.v1.Csi.Topology.Builder addPreferredBuilder() {
        return getPreferredFieldBuilder().addBuilder(
            csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public csi.v1.Csi.Topology.Builder addPreferredBuilder(
          int index) {
        return getPreferredFieldBuilder().addBuilder(
            index, csi.v1.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v1.Topology preferred = 2;</code>
       */
      public java.util.List<csi.v1.Csi.Topology.Builder> 
           getPreferredBuilderList() {
        return getPreferredFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> 
          getPreferredFieldBuilder() {
        if (preferredBuilder_ == null) {
          preferredBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder>(
                  preferred_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          preferred_ = null;
        }
        return preferredBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.TopologyRequirement)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.TopologyRequirement)
    private static final csi.v1.Csi.TopologyRequirement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.TopologyRequirement();
    }

    public static csi.v1.Csi.TopologyRequirement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TopologyRequirement>
        PARSER = new com.google.protobuf.AbstractParser<TopologyRequirement>() {
      public TopologyRequirement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TopologyRequirement(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TopologyRequirement> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TopologyRequirement> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.TopologyRequirement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TopologyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.Topology)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    int getSegmentsCount();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    boolean containsSegments(
        java.lang.String key);
    /**
     * Use {@link #getSegmentsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSegments();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSegmentsMap();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    java.lang.String getSegmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    java.lang.String getSegmentsOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * Topology is a map of topological domains to topological segments.
   * A topological domain is a sub-division of a cluster, like "region",
   * "zone", "rack", etc.
   * A topological segment is a specific instance of a topological domain,
   * like "zone3", "rack3", etc.
   * For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
   * Valid keys have two segments: an OPTIONAL prefix and name, separated
   * by a slash (/), for example: "com.company.example/zone".
   * The key name segment is REQUIRED. The prefix is OPTIONAL.
   * The key name MUST be 63 characters or less, begin and end with an
   * alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
   * underscores (_), dots (.), or alphanumerics in between, for example
   * "zone".
   * The key prefix MUST be 63 characters or less, begin and end with a
   * lower-case alphanumeric character ([a-z0-9]), contain only
   * dashes (-), dots (.), or lower-case alphanumerics in between, and
   * follow domain name notation format
   * (https://tools.ietf.org/html/rfc1035#section-2.3.1).
   * The key prefix SHOULD include the plugin's host company name and/or
   * the plugin name, to minimize the possibility of collisions with keys
   * from other plugins.
   * If a key prefix is specified, it MUST be identical across all
   * topology keys returned by the SP (across all RPCs).
   * Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
   * MUST not both exist.
   * Each value (topological segment) MUST contain 1 or more strings.
   * Each string MUST be 63 characters or less and begin and end with an
   * alphanumeric character with '-', '_', '.', or alphanumerics in
   * between.
   * </pre>
   *
   * Protobuf type {@code csi.v1.Topology}
   */
  public  static final class Topology extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.Topology)
      TopologyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Topology.newBuilder() to construct.
    private Topology(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Topology() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Topology(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                segments_ = com.google.protobuf.MapField.newMapField(
                    SegmentsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              segments__ = input.readMessage(
                  SegmentsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              segments_.getMutableMap().put(
                  segments__.getKey(), segments__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_Topology_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetSegments();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_Topology_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.Topology.class, csi.v1.Csi.Topology.Builder.class);
    }

    public static final int SEGMENTS_FIELD_NUMBER = 1;
    private static final class SegmentsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_Topology_SegmentsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> segments_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSegments() {
      if (segments_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SegmentsDefaultEntryHolder.defaultEntry);
      }
      return segments_;
    }

    public int getSegmentsCount() {
      return internalGetSegments().getMap().size();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public boolean containsSegments(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSegments().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSegmentsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSegments() {
      return getSegmentsMap();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSegmentsMap() {
      return internalGetSegments().getMap();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.lang.String getSegmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSegments().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.lang.String getSegmentsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSegments().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSegments(),
          SegmentsDefaultEntryHolder.defaultEntry,
          1);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSegments().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        segments__ = SegmentsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, segments__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.Topology)) {
        return super.equals(obj);
      }
      csi.v1.Csi.Topology other = (csi.v1.Csi.Topology) obj;

      boolean result = true;
      result = result && internalGetSegments().equals(
          other.internalGetSegments());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetSegments().getMap().isEmpty()) {
        hash = (37 * hash) + SEGMENTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSegments().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.Topology parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Topology parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Topology parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Topology parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Topology parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Topology parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Topology parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Topology parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Topology parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Topology parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Topology parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Topology parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.Topology prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Topology is a map of topological domains to topological segments.
     * A topological domain is a sub-division of a cluster, like "region",
     * "zone", "rack", etc.
     * A topological segment is a specific instance of a topological domain,
     * like "zone3", "rack3", etc.
     * For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
     * Valid keys have two segments: an OPTIONAL prefix and name, separated
     * by a slash (/), for example: "com.company.example/zone".
     * The key name segment is REQUIRED. The prefix is OPTIONAL.
     * The key name MUST be 63 characters or less, begin and end with an
     * alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
     * underscores (_), dots (.), or alphanumerics in between, for example
     * "zone".
     * The key prefix MUST be 63 characters or less, begin and end with a
     * lower-case alphanumeric character ([a-z0-9]), contain only
     * dashes (-), dots (.), or lower-case alphanumerics in between, and
     * follow domain name notation format
     * (https://tools.ietf.org/html/rfc1035#section-2.3.1).
     * The key prefix SHOULD include the plugin's host company name and/or
     * the plugin name, to minimize the possibility of collisions with keys
     * from other plugins.
     * If a key prefix is specified, it MUST be identical across all
     * topology keys returned by the SP (across all RPCs).
     * Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
     * MUST not both exist.
     * Each value (topological segment) MUST contain 1 or more strings.
     * Each string MUST be 63 characters or less and begin and end with an
     * alphanumeric character with '-', '_', '.', or alphanumerics in
     * between.
     * </pre>
     *
     * Protobuf type {@code csi.v1.Topology}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.Topology)
        csi.v1.Csi.TopologyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_Topology_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetSegments();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableSegments();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_Topology_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.Topology.class, csi.v1.Csi.Topology.Builder.class);
      }

      // Construct using csi.v1.Csi.Topology.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        internalGetMutableSegments().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_Topology_descriptor;
      }

      public csi.v1.Csi.Topology getDefaultInstanceForType() {
        return csi.v1.Csi.Topology.getDefaultInstance();
      }

      public csi.v1.Csi.Topology build() {
        csi.v1.Csi.Topology result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.Topology buildPartial() {
        csi.v1.Csi.Topology result = new csi.v1.Csi.Topology(this);
        int from_bitField0_ = bitField0_;
        result.segments_ = internalGetSegments();
        result.segments_.makeImmutable();
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.Topology) {
          return mergeFrom((csi.v1.Csi.Topology)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.Topology other) {
        if (other == csi.v1.Csi.Topology.getDefaultInstance()) return this;
        internalGetMutableSegments().mergeFrom(
            other.internalGetSegments());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.Topology parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.Topology) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> segments_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSegments() {
        if (segments_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SegmentsDefaultEntryHolder.defaultEntry);
        }
        return segments_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSegments() {
        onChanged();;
        if (segments_ == null) {
          segments_ = com.google.protobuf.MapField.newMapField(
              SegmentsDefaultEntryHolder.defaultEntry);
        }
        if (!segments_.isMutable()) {
          segments_ = segments_.copy();
        }
        return segments_;
      }

      public int getSegmentsCount() {
        return internalGetSegments().getMap().size();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public boolean containsSegments(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSegments().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSegmentsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSegments() {
        return getSegmentsMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSegmentsMap() {
        return internalGetSegments().getMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.lang.String getSegmentsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSegments().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.lang.String getSegmentsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSegments().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSegments() {
        internalGetMutableSegments().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public Builder removeSegments(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSegments().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSegments() {
        return internalGetMutableSegments().getMutableMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */
      public Builder putSegments(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSegments().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public Builder putAllSegments(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSegments().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.Topology)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.Topology)
    private static final csi.v1.Csi.Topology DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.Topology();
    }

    public static csi.v1.Csi.Topology getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Topology>
        PARSER = new com.google.protobuf.AbstractParser<Topology>() {
      public Topology parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Topology(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Topology> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Topology> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.Topology getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.DeleteVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.DeleteVolumeRequest}
   */
  public  static final class DeleteVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.DeleteVolumeRequest)
      DeleteVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteVolumeRequest.newBuilder() to construct.
    private DeleteVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteVolumeRequest() {
      volumeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.DeleteVolumeRequest.class, csi.v1.Csi.DeleteVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SECRETS_FIELD_NUMBER = 2;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          2);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, secrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.DeleteVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.DeleteVolumeRequest other = (csi.v1.Csi.DeleteVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.DeleteVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.DeleteVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.DeleteVolumeRequest)
        csi.v1.Csi.DeleteVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.DeleteVolumeRequest.class, csi.v1.Csi.DeleteVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.DeleteVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutableSecrets().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeRequest_descriptor;
      }

      public csi.v1.Csi.DeleteVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.DeleteVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.DeleteVolumeRequest build() {
        csi.v1.Csi.DeleteVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.DeleteVolumeRequest buildPartial() {
        csi.v1.Csi.DeleteVolumeRequest result = new csi.v1.Csi.DeleteVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.DeleteVolumeRequest) {
          return mergeFrom((csi.v1.Csi.DeleteVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.DeleteVolumeRequest other) {
        if (other == csi.v1.Csi.DeleteVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.DeleteVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.DeleteVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.DeleteVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeRequest)
    private static final csi.v1.Csi.DeleteVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.DeleteVolumeRequest();
    }

    public static csi.v1.Csi.DeleteVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<DeleteVolumeRequest>() {
      public DeleteVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.DeleteVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.DeleteVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.DeleteVolumeResponse}
   */
  public  static final class DeleteVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.DeleteVolumeResponse)
      DeleteVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteVolumeResponse.newBuilder() to construct.
    private DeleteVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.DeleteVolumeResponse.class, csi.v1.Csi.DeleteVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.DeleteVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.DeleteVolumeResponse other = (csi.v1.Csi.DeleteVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.DeleteVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.DeleteVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.DeleteVolumeResponse)
        csi.v1.Csi.DeleteVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.DeleteVolumeResponse.class, csi.v1.Csi.DeleteVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.DeleteVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteVolumeResponse_descriptor;
      }

      public csi.v1.Csi.DeleteVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.DeleteVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.DeleteVolumeResponse build() {
        csi.v1.Csi.DeleteVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.DeleteVolumeResponse buildPartial() {
        csi.v1.Csi.DeleteVolumeResponse result = new csi.v1.Csi.DeleteVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.DeleteVolumeResponse) {
          return mergeFrom((csi.v1.Csi.DeleteVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.DeleteVolumeResponse other) {
        if (other == csi.v1.Csi.DeleteVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.DeleteVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.DeleteVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.DeleteVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeResponse)
    private static final csi.v1.Csi.DeleteVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.DeleteVolumeResponse();
    }

    public static csi.v1.Csi.DeleteVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<DeleteVolumeResponse>() {
      public DeleteVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.DeleteVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerPublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerPublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Indicates SP MUST publish the volume in readonly mode.
     * CO MUST set this field to false if SP does not have the
     * PUBLISH_READONLY controller capability.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>bool readonly = 4;</code>
     */
    boolean getReadonly();

    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    int getVolumeContextCount();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    boolean containsVolumeContext(
        java.lang.String key);
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContext();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContextMap();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    java.lang.String getVolumeContextOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.ControllerPublishVolumeRequest}
   */
  public  static final class ControllerPublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerPublishVolumeRequest)
      ControllerPublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerPublishVolumeRequest.newBuilder() to construct.
    private ControllerPublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerPublishVolumeRequest() {
      volumeId_ = "";
      nodeId_ = "";
      readonly_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerPublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 26: {
              csi.v1.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 32: {

              readonly_ = input.readBool();
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                volumeContext_ = com.google.protobuf.MapField.newMapField(
                    VolumeContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000020;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeContext__ = input.readMessage(
                  VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeContext_.getMutableMap().put(
                  volumeContext__.getKey(), volumeContext__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 5:
          return internalGetSecrets();
        case 6:
          return internalGetVolumeContext();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerPublishVolumeRequest.class, csi.v1.Csi.ControllerPublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 3;
    private csi.v1.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int READONLY_FIELD_NUMBER = 4;
    private boolean readonly_;
    /**
     * <pre>
     * Indicates SP MUST publish the volume in readonly mode.
     * CO MUST set this field to false if SP does not have the
     * PUBLISH_READONLY controller capability.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>bool readonly = 4;</code>
     */
    public boolean getReadonly() {
      return readonly_;
    }

    public static final int SECRETS_FIELD_NUMBER = 5;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CONTEXT_FIELD_NUMBER = 6;
    private static final class VolumeContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeContext() {
      if (volumeContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeContextDefaultEntryHolder.defaultEntry);
      }
      return volumeContext_;
    }

    public int getVolumeContextCount() {
      return internalGetVolumeContext().getMap().size();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public boolean containsVolumeContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
      return getVolumeContextMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
      return internalGetVolumeContext().getMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.lang.String getVolumeContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nodeId_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(3, getVolumeCapability());
      }
      if (readonly_ != false) {
        output.writeBool(4, readonly_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          5);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeContext(),
          VolumeContextDefaultEntryHolder.defaultEntry,
          6);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nodeId_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getVolumeCapability());
      }
      if (readonly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, readonly_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, secrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, volumeContext__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerPublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerPublishVolumeRequest other = (csi.v1.Csi.ControllerPublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && (getReadonly()
          == other.getReadonly());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && internalGetVolumeContext().equals(
          other.internalGetVolumeContext());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      hash = (37 * hash) + READONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReadonly());
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      if (!internalGetVolumeContext().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeContext().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerPublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerPublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerPublishVolumeRequest)
        csi.v1.Csi.ControllerPublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 5:
            return internalGetSecrets();
          case 6:
            return internalGetVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 5:
            return internalGetMutableSecrets();
          case 6:
            return internalGetMutableVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerPublishVolumeRequest.class, csi.v1.Csi.ControllerPublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerPublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        nodeId_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        readonly_ = false;

        internalGetMutableSecrets().clear();
        internalGetMutableVolumeContext().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor;
      }

      public csi.v1.Csi.ControllerPublishVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerPublishVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerPublishVolumeRequest build() {
        csi.v1.Csi.ControllerPublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerPublishVolumeRequest buildPartial() {
        csi.v1.Csi.ControllerPublishVolumeRequest result = new csi.v1.Csi.ControllerPublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.nodeId_ = nodeId_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.readonly_ = readonly_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.volumeContext_ = internalGetVolumeContext();
        result.volumeContext_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerPublishVolumeRequest) {
          return mergeFrom((csi.v1.Csi.ControllerPublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerPublishVolumeRequest other) {
        if (other == csi.v1.Csi.ControllerPublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        if (other.getReadonly() != false) {
          setReadonly(other.getReadonly());
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        internalGetMutableVolumeContext().mergeFrom(
            other.internalGetVolumeContext());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerPublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerPublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public Builder setVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public Builder setVolumeCapability(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public Builder mergeVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v1.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private boolean readonly_ ;
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * CO MUST set this field to false if SP does not have the
       * PUBLISH_READONLY controller capability.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public boolean getReadonly() {
        return readonly_;
      }
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * CO MUST set this field to false if SP does not have the
       * PUBLISH_READONLY controller capability.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public Builder setReadonly(boolean value) {
        
        readonly_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * CO MUST set this field to false if SP does not have the
       * PUBLISH_READONLY controller capability.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public Builder clearReadonly() {
        
        readonly_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeContext() {
        onChanged();;
        if (volumeContext_ == null) {
          volumeContext_ = com.google.protobuf.MapField.newMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        if (!volumeContext_.isMutable()) {
          volumeContext_ = volumeContext_.copy();
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeContext() {
        internalGetMutableVolumeContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public Builder removeVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeContext() {
        return internalGetMutableVolumeContext().getMutableMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */
      public Builder putVolumeContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public Builder putAllVolumeContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeContext().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerPublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeRequest)
    private static final csi.v1.Csi.ControllerPublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerPublishVolumeRequest();
    }

    public static csi.v1.Csi.ControllerPublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerPublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerPublishVolumeRequest>() {
      public ControllerPublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerPublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerPublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerPublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerPublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerPublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerPublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */
    int getPublishContextCount();
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */
    boolean containsPublishContext(
        java.lang.String key);
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContext();
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContextMap();
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    java.lang.String getPublishContextOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.ControllerPublishVolumeResponse}
   */
  public  static final class ControllerPublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerPublishVolumeResponse)
      ControllerPublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerPublishVolumeResponse.newBuilder() to construct.
    private ControllerPublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerPublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerPublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                publishContext_ = com.google.protobuf.MapField.newMapField(
                    PublishContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishContext__ = input.readMessage(
                  PublishContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishContext_.getMutableMap().put(
                  publishContext__.getKey(), publishContext__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetPublishContext();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerPublishVolumeResponse.class, csi.v1.Csi.ControllerPublishVolumeResponse.Builder.class);
    }

    public static final int PUBLISH_CONTEXT_FIELD_NUMBER = 1;
    private static final class PublishContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishContext() {
      if (publishContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishContextDefaultEntryHolder.defaultEntry);
      }
      return publishContext_;
    }

    public int getPublishContextCount() {
      return internalGetPublishContext().getMap().size();
    }
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    public boolean containsPublishContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
      return getPublishContextMap();
    }
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
      return internalGetPublishContext().getMap();
    }
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    public java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Opaque static publish properties of the volume. SP MAY use this
     * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
     * calls calls have contextual information.
     * The contents of this field SHALL be opaque to a CO.
     * The contents of this field SHALL NOT be mutable.
     * The contents of this field SHALL be safe for the CO to cache.
     * The contents of this field SHOULD NOT contain sensitive
     * information.
     * The contents of this field SHOULD NOT be used for uniquely
     * identifying a volume. The `volume_id` alone SHOULD be sufficient to
     * identify the volume.
     * This field is OPTIONAL and when present MUST be passed to
     * subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 1;</code>
     */

    public java.lang.String getPublishContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishContext(),
          PublishContextDefaultEntryHolder.defaultEntry,
          1);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishContext__ = PublishContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, publishContext__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerPublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerPublishVolumeResponse other = (csi.v1.Csi.ControllerPublishVolumeResponse) obj;

      boolean result = true;
      result = result && internalGetPublishContext().equals(
          other.internalGetPublishContext());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPublishContext().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishContext().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerPublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerPublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerPublishVolumeResponse)
        csi.v1.Csi.ControllerPublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetPublishContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePublishContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerPublishVolumeResponse.class, csi.v1.Csi.ControllerPublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerPublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        internalGetMutablePublishContext().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor;
      }

      public csi.v1.Csi.ControllerPublishVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerPublishVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerPublishVolumeResponse build() {
        csi.v1.Csi.ControllerPublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerPublishVolumeResponse buildPartial() {
        csi.v1.Csi.ControllerPublishVolumeResponse result = new csi.v1.Csi.ControllerPublishVolumeResponse(this);
        int from_bitField0_ = bitField0_;
        result.publishContext_ = internalGetPublishContext();
        result.publishContext_.makeImmutable();
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerPublishVolumeResponse) {
          return mergeFrom((csi.v1.Csi.ControllerPublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerPublishVolumeResponse other) {
        if (other == csi.v1.Csi.ControllerPublishVolumeResponse.getDefaultInstance()) return this;
        internalGetMutablePublishContext().mergeFrom(
            other.internalGetPublishContext());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerPublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerPublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishContext() {
        if (publishContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        return publishContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishContext() {
        onChanged();;
        if (publishContext_ == null) {
          publishContext_ = com.google.protobuf.MapField.newMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        if (!publishContext_.isMutable()) {
          publishContext_ = publishContext_.copy();
        }
        return publishContext_;
      }

      public int getPublishContextCount() {
        return internalGetPublishContext().getMap().size();
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public boolean containsPublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
        return getPublishContextMap();
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
        return internalGetPublishContext().getMap();
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public java.lang.String getPublishContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public java.lang.String getPublishContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishContext() {
        internalGetMutablePublishContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public Builder removePublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishContext() {
        return internalGetMutablePublishContext().getMutableMap();
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */
      public Builder putPublishContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Opaque static publish properties of the volume. SP MAY use this
       * field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
       * calls calls have contextual information.
       * The contents of this field SHALL be opaque to a CO.
       * The contents of this field SHALL NOT be mutable.
       * The contents of this field SHALL be safe for the CO to cache.
       * The contents of this field SHOULD NOT contain sensitive
       * information.
       * The contents of this field SHOULD NOT be used for uniquely
       * identifying a volume. The `volume_id` alone SHOULD be sufficient to
       * identify the volume.
       * This field is OPTIONAL and when present MUST be passed to
       * subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 1;</code>
       */

      public Builder putAllPublishContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishContext().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerPublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeResponse)
    private static final csi.v1.Csi.ControllerPublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerPublishVolumeResponse();
    }

    public static csi.v1.Csi.ControllerPublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerPublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerPublishVolumeResponse>() {
      public ControllerPublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerPublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerPublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerPublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerPublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerUnpublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerUnpublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.ControllerUnpublishVolumeRequest}
   */
  public  static final class ControllerUnpublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerUnpublishVolumeRequest)
      ControllerUnpublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerUnpublishVolumeRequest.newBuilder() to construct.
    private ControllerUnpublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerUnpublishVolumeRequest() {
      volumeId_ = "";
      nodeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerUnpublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerUnpublishVolumeRequest.class, csi.v1.Csi.ControllerUnpublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SECRETS_FIELD_NUMBER = 3;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nodeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          3);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nodeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, secrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerUnpublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerUnpublishVolumeRequest other = (csi.v1.Csi.ControllerUnpublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerUnpublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerUnpublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerUnpublishVolumeRequest)
        csi.v1.Csi.ControllerUnpublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerUnpublishVolumeRequest.class, csi.v1.Csi.ControllerUnpublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerUnpublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        nodeId_ = "";

        internalGetMutableSecrets().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor;
      }

      public csi.v1.Csi.ControllerUnpublishVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerUnpublishVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerUnpublishVolumeRequest build() {
        csi.v1.Csi.ControllerUnpublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerUnpublishVolumeRequest buildPartial() {
        csi.v1.Csi.ControllerUnpublishVolumeRequest result = new csi.v1.Csi.ControllerUnpublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.nodeId_ = nodeId_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerUnpublishVolumeRequest) {
          return mergeFrom((csi.v1.Csi.ControllerUnpublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerUnpublishVolumeRequest other) {
        if (other == csi.v1.Csi.ControllerUnpublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerUnpublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerUnpublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerUnpublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeRequest)
    private static final csi.v1.Csi.ControllerUnpublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerUnpublishVolumeRequest();
    }

    public static csi.v1.Csi.ControllerUnpublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerUnpublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerUnpublishVolumeRequest>() {
      public ControllerUnpublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerUnpublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerUnpublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerUnpublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerUnpublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerUnpublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerUnpublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.ControllerUnpublishVolumeResponse}
   */
  public  static final class ControllerUnpublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerUnpublishVolumeResponse)
      ControllerUnpublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerUnpublishVolumeResponse.newBuilder() to construct.
    private ControllerUnpublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerUnpublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerUnpublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerUnpublishVolumeResponse.class, csi.v1.Csi.ControllerUnpublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerUnpublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerUnpublishVolumeResponse other = (csi.v1.Csi.ControllerUnpublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerUnpublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.ControllerUnpublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerUnpublishVolumeResponse)
        csi.v1.Csi.ControllerUnpublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerUnpublishVolumeResponse.class, csi.v1.Csi.ControllerUnpublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerUnpublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor;
      }

      public csi.v1.Csi.ControllerUnpublishVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerUnpublishVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerUnpublishVolumeResponse build() {
        csi.v1.Csi.ControllerUnpublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerUnpublishVolumeResponse buildPartial() {
        csi.v1.Csi.ControllerUnpublishVolumeResponse result = new csi.v1.Csi.ControllerUnpublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerUnpublishVolumeResponse) {
          return mergeFrom((csi.v1.Csi.ControllerUnpublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerUnpublishVolumeResponse other) {
        if (other == csi.v1.Csi.ControllerUnpublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerUnpublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerUnpublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerUnpublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeResponse)
    private static final csi.v1.Csi.ControllerUnpublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerUnpublishVolumeResponse();
    }

    public static csi.v1.Csi.ControllerUnpublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerUnpublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerUnpublishVolumeResponse>() {
      public ControllerUnpublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerUnpublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerUnpublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerUnpublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerUnpublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidateVolumeCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ValidateVolumeCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */
    int getVolumeContextCount();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */
    boolean containsVolumeContext(
        java.lang.String key);
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContext();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContextMap();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    java.lang.String getVolumeContextOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<csi.v1.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesRequest}
   */
  public  static final class ValidateVolumeCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ValidateVolumeCapabilitiesRequest)
      ValidateVolumeCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidateVolumeCapabilitiesRequest.newBuilder() to construct.
    private ValidateVolumeCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidateVolumeCapabilitiesRequest() {
      volumeId_ = "";
      volumeCapabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidateVolumeCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                volumeContext_ = com.google.protobuf.MapField.newMapField(
                    VolumeContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeContext__ = input.readMessage(
                  VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeContext_.getMutableMap().put(
                  volumeContext__.getKey(), volumeContext__.getValue());
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000004;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetVolumeContext();
        case 4:
          return internalGetParameters();
        case 5:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ValidateVolumeCapabilitiesRequest.class, csi.v1.Csi.ValidateVolumeCapabilitiesRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CONTEXT_FIELD_NUMBER = 2;
    private static final class VolumeContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeContext() {
      if (volumeContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeContextDefaultEntryHolder.defaultEntry);
      }
      return volumeContext_;
    }

    public int getVolumeContextCount() {
      return internalGetVolumeContext().getMap().size();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    public boolean containsVolumeContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
      return getVolumeContextMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
      return internalGetVolumeContext().getMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    public java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 2;</code>
     */

    public java.lang.String getVolumeContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 3;
    private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "confirmed" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 4;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * See CreateVolumeRequest.parameters.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SECRETS_FIELD_NUMBER = 5;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume validation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeContext(),
          VolumeContextDefaultEntryHolder.defaultEntry,
          2);
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(3, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          4);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          5);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, volumeContext__);
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, parameters__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, secrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ValidateVolumeCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ValidateVolumeCapabilitiesRequest other = (csi.v1.Csi.ValidateVolumeCapabilitiesRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetVolumeContext().equals(
          other.internalGetVolumeContext());
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetVolumeContext().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeContext().hashCode();
      }
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ValidateVolumeCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ValidateVolumeCapabilitiesRequest)
        csi.v1.Csi.ValidateVolumeCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetVolumeContext();
          case 4:
            return internalGetParameters();
          case 5:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableVolumeContext();
          case 4:
            return internalGetMutableParameters();
          case 5:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ValidateVolumeCapabilitiesRequest.class, csi.v1.Csi.ValidateVolumeCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ValidateVolumeCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutableVolumeContext().clear();
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableParameters().clear();
        internalGetMutableSecrets().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor;
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ValidateVolumeCapabilitiesRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesRequest build() {
        csi.v1.Csi.ValidateVolumeCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesRequest buildPartial() {
        csi.v1.Csi.ValidateVolumeCapabilitiesRequest result = new csi.v1.Csi.ValidateVolumeCapabilitiesRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.volumeContext_ = internalGetVolumeContext();
        result.volumeContext_.makeImmutable();
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ValidateVolumeCapabilitiesRequest) {
          return mergeFrom((csi.v1.Csi.ValidateVolumeCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ValidateVolumeCapabilitiesRequest other) {
        if (other == csi.v1.Csi.ValidateVolumeCapabilitiesRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutableVolumeContext().mergeFrom(
            other.internalGetVolumeContext());
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ValidateVolumeCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ValidateVolumeCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeContext() {
        onChanged();;
        if (volumeContext_ == null) {
          volumeContext_ = com.google.protobuf.MapField.newMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        if (!volumeContext_.isMutable()) {
          volumeContext_ = volumeContext_.copy();
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeContext() {
        internalGetMutableVolumeContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public Builder removeVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeContext() {
        return internalGetMutableVolumeContext().getMutableMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */
      public Builder putVolumeContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 2;</code>
       */

      public Builder putAllVolumeContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeContext().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "confirmed" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * See CreateVolumeRequest.parameters.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume validation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ValidateVolumeCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesRequest)
    private static final csi.v1.Csi.ValidateVolumeCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ValidateVolumeCapabilitiesRequest();
    }

    public static csi.v1.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ValidateVolumeCapabilitiesRequest>() {
      public ValidateVolumeCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidateVolumeCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidateVolumeCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ValidateVolumeCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    boolean hasConfirmed();
    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getConfirmed();
    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder getConfirmedOrBuilder();

    /**
     * <pre>
     * Message to the CO if `confirmed` above is empty. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message to the CO if `confirmed` above is empty. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesResponse}
   */
  public  static final class ValidateVolumeCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ValidateVolumeCapabilitiesResponse)
      ValidateVolumeCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidateVolumeCapabilitiesResponse.newBuilder() to construct.
    private ValidateVolumeCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidateVolumeCapabilitiesResponse() {
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidateVolumeCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder subBuilder = null;
              if (confirmed_ != null) {
                subBuilder = confirmed_.toBuilder();
              }
              confirmed_ = input.readMessage(csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(confirmed_);
                confirmed_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              message_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ValidateVolumeCapabilitiesResponse.class, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Builder.class);
    }

    public interface ConfirmedOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */
      int getVolumeContextCount();
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */
      boolean containsVolumeContext(
          java.lang.String key);
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      java.util.Map<java.lang.String, java.lang.String>
      getVolumeContext();
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */
      java.util.Map<java.lang.String, java.lang.String>
      getVolumeContextMap();
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue);
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      java.lang.String getVolumeContextOrThrow(
          java.lang.String key);

      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      java.util.List<csi.v1.Csi.VolumeCapability> 
          getVolumeCapabilitiesList();
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index);
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      int getVolumeCapabilitiesCount();
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesOrBuilderList();
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index);

      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      int getParametersCount();
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      boolean containsParameters(
          java.lang.String key);
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      java.util.Map<java.lang.String, java.lang.String>
      getParameters();
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */
      java.util.Map<java.lang.String, java.lang.String>
      getParametersMap();
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue);
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      java.lang.String getParametersOrThrow(
          java.lang.String key);
    }
    /**
     * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed}
     */
    public  static final class Confirmed extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
        ConfirmedOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Confirmed.newBuilder() to construct.
      private Confirmed(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Confirmed() {
        volumeCapabilities_ = java.util.Collections.emptyList();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Confirmed(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                  volumeContext_ = com.google.protobuf.MapField.newMapField(
                      VolumeContextDefaultEntryHolder.defaultEntry);
                  mutable_bitField0_ |= 0x00000001;
                }
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                volumeContext__ = input.readMessage(
                    VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                volumeContext_.getMutableMap().put(
                    volumeContext__.getKey(), volumeContext__.getValue());
                break;
              }
              case 18: {
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>();
                  mutable_bitField0_ |= 0x00000002;
                }
                volumeCapabilities_.add(
                    input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry));
                break;
              }
              case 26: {
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  parameters_ = com.google.protobuf.MapField.newMapField(
                      ParametersDefaultEntryHolder.defaultEntry);
                  mutable_bitField0_ |= 0x00000004;
                }
                com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
                parameters__ = input.readMessage(
                    ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                parameters_.getMutableMap().put(
                    parameters__.getKey(), parameters__.getValue());
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetVolumeContext();
          case 3:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.class, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder.class);
      }

      public static final int VOLUME_CONTEXT_FIELD_NUMBER = 1;
      private static final class VolumeContextDefaultEntryHolder {
        static final com.google.protobuf.MapEntry<
            java.lang.String, java.lang.String> defaultEntry =
                com.google.protobuf.MapEntry
                .<java.lang.String, java.lang.String>newDefaultInstance(
                    csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_descriptor, 
                    com.google.protobuf.WireFormat.FieldType.STRING,
                    "",
                    com.google.protobuf.WireFormat.FieldType.STRING,
                    "");
      }
      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Volume context validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 1;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 2;
      private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_;
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        return volumeCapabilities_;
      }
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesOrBuilderList() {
        return volumeCapabilities_;
      }
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      public int getVolumeCapabilitiesCount() {
        return volumeCapabilities_.size();
      }
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
        return volumeCapabilities_.get(index);
      }
      /**
       * <pre>
       * Volume capabilities supported by the plugin.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        return volumeCapabilities_.get(index);
      }

      public static final int PARAMETERS_FIELD_NUMBER = 3;
      private static final class ParametersDefaultEntryHolder {
        static final com.google.protobuf.MapEntry<
            java.lang.String, java.lang.String> defaultEntry =
                com.google.protobuf.MapEntry
                .<java.lang.String, java.lang.String>newDefaultInstance(
                    csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_descriptor, 
                    com.google.protobuf.WireFormat.FieldType.STRING,
                    "",
                    com.google.protobuf.WireFormat.FieldType.STRING,
                    "");
      }
      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The volume creation parameters validated by the plugin.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 3;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        com.google.protobuf.GeneratedMessageV3
          .serializeStringMapTo(
            output,
            internalGetVolumeContext(),
            VolumeContextDefaultEntryHolder.defaultEntry,
            1);
        for (int i = 0; i < volumeCapabilities_.size(); i++) {
          output.writeMessage(2, volumeCapabilities_.get(i));
        }
        com.google.protobuf.GeneratedMessageV3
          .serializeStringMapTo(
            output,
            internalGetParameters(),
            ParametersDefaultEntryHolder.defaultEntry,
            3);
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
             : internalGetVolumeContext().getMap().entrySet()) {
          com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
          volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
              .setKey(entry.getKey())
              .setValue(entry.getValue())
              .build();
          size += com.google.protobuf.CodedOutputStream
              .computeMessageSize(1, volumeContext__);
        }
        for (int i = 0; i < volumeCapabilities_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, volumeCapabilities_.get(i));
        }
        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
             : internalGetParameters().getMap().entrySet()) {
          com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
          parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
              .setKey(entry.getKey())
              .setValue(entry.getValue())
              .build();
          size += com.google.protobuf.CodedOutputStream
              .computeMessageSize(3, parameters__);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed)) {
          return super.equals(obj);
        }
        csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed other = (csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed) obj;

        boolean result = true;
        result = result && internalGetVolumeContext().equals(
            other.internalGetVolumeContext());
        result = result && getVolumeCapabilitiesList()
            .equals(other.getVolumeCapabilitiesList());
        result = result && internalGetParameters().equals(
            other.internalGetParameters());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (!internalGetVolumeContext().getMap().isEmpty()) {
          hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
          hash = (53 * hash) + internalGetVolumeContext().hashCode();
        }
        if (getVolumeCapabilitiesCount() > 0) {
          hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
          hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
        }
        if (!internalGetParameters().getMap().isEmpty()) {
          hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
          hash = (53 * hash) + internalGetParameters().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor;
        }

        @SuppressWarnings({"rawtypes"})
        protected com.google.protobuf.MapField internalGetMapField(
            int number) {
          switch (number) {
            case 1:
              return internalGetVolumeContext();
            case 3:
              return internalGetParameters();
            default:
              throw new RuntimeException(
                  "Invalid map field number: " + number);
          }
        }
        @SuppressWarnings({"rawtypes"})
        protected com.google.protobuf.MapField internalGetMutableMapField(
            int number) {
          switch (number) {
            case 1:
              return internalGetMutableVolumeContext();
            case 3:
              return internalGetMutableParameters();
            default:
              throw new RuntimeException(
                  "Invalid map field number: " + number);
          }
        }
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.class, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder.class);
        }

        // Construct using csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getVolumeCapabilitiesFieldBuilder();
          }
        }
        public Builder clear() {
          super.clear();
          internalGetMutableVolumeContext().clear();
          if (volumeCapabilitiesBuilder_ == null) {
            volumeCapabilities_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            volumeCapabilitiesBuilder_.clear();
          }
          internalGetMutableParameters().clear();
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor;
        }

        public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getDefaultInstanceForType() {
          return csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.getDefaultInstance();
        }

        public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed build() {
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed buildPartial() {
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed result = new csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed(this);
          int from_bitField0_ = bitField0_;
          result.volumeContext_ = internalGetVolumeContext();
          result.volumeContext_.makeImmutable();
          if (volumeCapabilitiesBuilder_ == null) {
            if (((bitField0_ & 0x00000002) == 0x00000002)) {
              volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
              bitField0_ = (bitField0_ & ~0x00000002);
            }
            result.volumeCapabilities_ = volumeCapabilities_;
          } else {
            result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
          }
          result.parameters_ = internalGetParameters();
          result.parameters_.makeImmutable();
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed) {
            return mergeFrom((csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed other) {
          if (other == csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.getDefaultInstance()) return this;
          internalGetMutableVolumeContext().mergeFrom(
              other.internalGetVolumeContext());
          if (volumeCapabilitiesBuilder_ == null) {
            if (!other.volumeCapabilities_.isEmpty()) {
              if (volumeCapabilities_.isEmpty()) {
                volumeCapabilities_ = other.volumeCapabilities_;
                bitField0_ = (bitField0_ & ~0x00000002);
              } else {
                ensureVolumeCapabilitiesIsMutable();
                volumeCapabilities_.addAll(other.volumeCapabilities_);
              }
              onChanged();
            }
          } else {
            if (!other.volumeCapabilities_.isEmpty()) {
              if (volumeCapabilitiesBuilder_.isEmpty()) {
                volumeCapabilitiesBuilder_.dispose();
                volumeCapabilitiesBuilder_ = null;
                volumeCapabilities_ = other.volumeCapabilities_;
                bitField0_ = (bitField0_ & ~0x00000002);
                volumeCapabilitiesBuilder_ = 
                  com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                     getVolumeCapabilitiesFieldBuilder() : null;
              } else {
                volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
              }
            }
          }
          internalGetMutableParameters().mergeFrom(
              other.internalGetParameters());
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.MapField<
            java.lang.String, java.lang.String> volumeContext_;
        private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetVolumeContext() {
          if (volumeContext_ == null) {
            return com.google.protobuf.MapField.emptyMapField(
                VolumeContextDefaultEntryHolder.defaultEntry);
          }
          return volumeContext_;
        }
        private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetMutableVolumeContext() {
          onChanged();;
          if (volumeContext_ == null) {
            volumeContext_ = com.google.protobuf.MapField.newMapField(
                VolumeContextDefaultEntryHolder.defaultEntry);
          }
          if (!volumeContext_.isMutable()) {
            volumeContext_ = volumeContext_.copy();
          }
          return volumeContext_;
        }

        public int getVolumeContextCount() {
          return internalGetVolumeContext().getMap().size();
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public boolean containsVolumeContext(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          return internalGetVolumeContext().getMap().containsKey(key);
        }
        /**
         * Use {@link #getVolumeContextMap()} instead.
         */
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
          return getVolumeContextMap();
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
          return internalGetVolumeContext().getMap();
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public java.lang.String getVolumeContextOrDefault(
            java.lang.String key,
            java.lang.String defaultValue) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.String> map =
              internalGetVolumeContext().getMap();
          return map.containsKey(key) ? map.get(key) : defaultValue;
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public java.lang.String getVolumeContextOrThrow(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.String> map =
              internalGetVolumeContext().getMap();
          if (!map.containsKey(key)) {
            throw new java.lang.IllegalArgumentException();
          }
          return map.get(key);
        }

        public Builder clearVolumeContext() {
          internalGetMutableVolumeContext().getMutableMap()
              .clear();
          return this;
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public Builder removeVolumeContext(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          internalGetMutableVolumeContext().getMutableMap()
              .remove(key);
          return this;
        }
        /**
         * Use alternate mutation accessors instead.
         */
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.String>
        getMutableVolumeContext() {
          return internalGetMutableVolumeContext().getMutableMap();
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */
        public Builder putVolumeContext(
            java.lang.String key,
            java.lang.String value) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          if (value == null) { throw new java.lang.NullPointerException(); }
          internalGetMutableVolumeContext().getMutableMap()
              .put(key, value);
          return this;
        }
        /**
         * <pre>
         * Volume context validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; volume_context = 1;</code>
         */

        public Builder putAllVolumeContext(
            java.util.Map<java.lang.String, java.lang.String> values) {
          internalGetMutableVolumeContext().getMutableMap()
              .putAll(values);
          return this;
        }

        private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_ =
          java.util.Collections.emptyList();
        private void ensureVolumeCapabilitiesIsMutable() {
          if (!((bitField0_ & 0x00000002) == 0x00000002)) {
            volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>(volumeCapabilities_);
            bitField0_ |= 0x00000002;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilderV3<
            csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
          if (volumeCapabilitiesBuilder_ == null) {
            return java.util.Collections.unmodifiableList(volumeCapabilities_);
          } else {
            return volumeCapabilitiesBuilder_.getMessageList();
          }
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public int getVolumeCapabilitiesCount() {
          if (volumeCapabilitiesBuilder_ == null) {
            return volumeCapabilities_.size();
          } else {
            return volumeCapabilitiesBuilder_.getCount();
          }
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
          if (volumeCapabilitiesBuilder_ == null) {
            return volumeCapabilities_.get(index);
          } else {
            return volumeCapabilitiesBuilder_.getMessage(index);
          }
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder setVolumeCapabilities(
            int index, csi.v1.Csi.VolumeCapability value) {
          if (volumeCapabilitiesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.set(index, value);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder setVolumeCapabilities(
            int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
          if (volumeCapabilitiesBuilder_ == null) {
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.set(index, builderForValue.build());
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder addVolumeCapabilities(csi.v1.Csi.VolumeCapability value) {
          if (volumeCapabilitiesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.add(value);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder addVolumeCapabilities(
            int index, csi.v1.Csi.VolumeCapability value) {
          if (volumeCapabilitiesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.add(index, value);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder addVolumeCapabilities(
            csi.v1.Csi.VolumeCapability.Builder builderForValue) {
          if (volumeCapabilitiesBuilder_ == null) {
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.add(builderForValue.build());
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder addVolumeCapabilities(
            int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
          if (volumeCapabilitiesBuilder_ == null) {
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.add(index, builderForValue.build());
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder addAllVolumeCapabilities(
            java.lang.Iterable<? extends csi.v1.Csi.VolumeCapability> values) {
          if (volumeCapabilitiesBuilder_ == null) {
            ensureVolumeCapabilitiesIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, volumeCapabilities_);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder clearVolumeCapabilities() {
          if (volumeCapabilitiesBuilder_ == null) {
            volumeCapabilities_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000002);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.clear();
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public Builder removeVolumeCapabilities(int index) {
          if (volumeCapabilitiesBuilder_ == null) {
            ensureVolumeCapabilitiesIsMutable();
            volumeCapabilities_.remove(index);
            onChanged();
          } else {
            volumeCapabilitiesBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
            int index) {
          return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
            int index) {
          if (volumeCapabilitiesBuilder_ == null) {
            return volumeCapabilities_.get(index);  } else {
            return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
             getVolumeCapabilitiesOrBuilderList() {
          if (volumeCapabilitiesBuilder_ != null) {
            return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(volumeCapabilities_);
          }
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
          return getVolumeCapabilitiesFieldBuilder().addBuilder(
              csi.v1.Csi.VolumeCapability.getDefaultInstance());
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
            int index) {
          return getVolumeCapabilitiesFieldBuilder().addBuilder(
              index, csi.v1.Csi.VolumeCapability.getDefaultInstance());
        }
        /**
         * <pre>
         * Volume capabilities supported by the plugin.
         * This field is REQUIRED.
         * </pre>
         *
         * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 2;</code>
         */
        public java.util.List<csi.v1.Csi.VolumeCapability.Builder> 
             getVolumeCapabilitiesBuilderList() {
          return getVolumeCapabilitiesFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilderV3<
            csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
            getVolumeCapabilitiesFieldBuilder() {
          if (volumeCapabilitiesBuilder_ == null) {
            volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
                csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                    volumeCapabilities_,
                    ((bitField0_ & 0x00000002) == 0x00000002),
                    getParentForChildren(),
                    isClean());
            volumeCapabilities_ = null;
          }
          return volumeCapabilitiesBuilder_;
        }

        private com.google.protobuf.MapField<
            java.lang.String, java.lang.String> parameters_;
        private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetParameters() {
          if (parameters_ == null) {
            return com.google.protobuf.MapField.emptyMapField(
                ParametersDefaultEntryHolder.defaultEntry);
          }
          return parameters_;
        }
        private com.google.protobuf.MapField<java.lang.String, java.lang.String>
        internalGetMutableParameters() {
          onChanged();;
          if (parameters_ == null) {
            parameters_ = com.google.protobuf.MapField.newMapField(
                ParametersDefaultEntryHolder.defaultEntry);
          }
          if (!parameters_.isMutable()) {
            parameters_ = parameters_.copy();
          }
          return parameters_;
        }

        public int getParametersCount() {
          return internalGetParameters().getMap().size();
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public boolean containsParameters(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          return internalGetParameters().getMap().containsKey(key);
        }
        /**
         * Use {@link #getParametersMap()} instead.
         */
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.String> getParameters() {
          return getParametersMap();
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
          return internalGetParameters().getMap();
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public java.lang.String getParametersOrDefault(
            java.lang.String key,
            java.lang.String defaultValue) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.String> map =
              internalGetParameters().getMap();
          return map.containsKey(key) ? map.get(key) : defaultValue;
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public java.lang.String getParametersOrThrow(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.String> map =
              internalGetParameters().getMap();
          if (!map.containsKey(key)) {
            throw new java.lang.IllegalArgumentException();
          }
          return map.get(key);
        }

        public Builder clearParameters() {
          internalGetMutableParameters().getMutableMap()
              .clear();
          return this;
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public Builder removeParameters(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          internalGetMutableParameters().getMutableMap()
              .remove(key);
          return this;
        }
        /**
         * Use alternate mutation accessors instead.
         */
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.String>
        getMutableParameters() {
          return internalGetMutableParameters().getMutableMap();
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */
        public Builder putParameters(
            java.lang.String key,
            java.lang.String value) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          if (value == null) { throw new java.lang.NullPointerException(); }
          internalGetMutableParameters().getMutableMap()
              .put(key, value);
          return this;
        }
        /**
         * <pre>
         * The volume creation parameters validated by the plugin.
         * This field is OPTIONAL.
         * </pre>
         *
         * <code>map&lt;string, string&gt; parameters = 3;</code>
         */

        public Builder putAllParameters(
            java.util.Map<java.lang.String, java.lang.String> values) {
          internalGetMutableParameters().getMutableMap()
              .putAll(values);
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
      private static final csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed();
      }

      public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Confirmed>
          PARSER = new com.google.protobuf.AbstractParser<Confirmed>() {
        public Confirmed parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Confirmed(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Confirmed> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Confirmed> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int CONFIRMED_FIELD_NUMBER = 1;
    private csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed confirmed_;
    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    public boolean hasConfirmed() {
      return confirmed_ != null;
    }
    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getConfirmed() {
      return confirmed_ == null ? csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.getDefaultInstance() : confirmed_;
    }
    /**
     * <pre>
     * Confirmed indicates to the CO the set of capabilities that the
     * plugin has validated. This field SHALL only be set to a non-empty
     * value for successful validation responses.
     * For successful validation responses, the CO SHALL compare the
     * fields of this message to the originally requested capabilities in
     * order to guard against an older plugin reporting "valid" for newer
     * capability fields that it does not yet understand.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
     */
    public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder getConfirmedOrBuilder() {
      return getConfirmed();
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    private volatile java.lang.Object message_;
    /**
     * <pre>
     * Message to the CO if `confirmed` above is empty. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Message to the CO if `confirmed` above is empty. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (confirmed_ != null) {
        output.writeMessage(1, getConfirmed());
      }
      if (!getMessageBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (confirmed_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getConfirmed());
      }
      if (!getMessageBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ValidateVolumeCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ValidateVolumeCapabilitiesResponse other = (csi.v1.Csi.ValidateVolumeCapabilitiesResponse) obj;

      boolean result = true;
      result = result && (hasConfirmed() == other.hasConfirmed());
      if (hasConfirmed()) {
        result = result && getConfirmed()
            .equals(other.getConfirmed());
      }
      result = result && getMessage()
          .equals(other.getMessage());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfirmed()) {
        hash = (37 * hash) + CONFIRMED_FIELD_NUMBER;
        hash = (53 * hash) + getConfirmed().hashCode();
      }
      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ValidateVolumeCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ValidateVolumeCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ValidateVolumeCapabilitiesResponse)
        csi.v1.Csi.ValidateVolumeCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ValidateVolumeCapabilitiesResponse.class, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ValidateVolumeCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (confirmedBuilder_ == null) {
          confirmed_ = null;
        } else {
          confirmed_ = null;
          confirmedBuilder_ = null;
        }
        message_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor;
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ValidateVolumeCapabilitiesResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse build() {
        csi.v1.Csi.ValidateVolumeCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse buildPartial() {
        csi.v1.Csi.ValidateVolumeCapabilitiesResponse result = new csi.v1.Csi.ValidateVolumeCapabilitiesResponse(this);
        if (confirmedBuilder_ == null) {
          result.confirmed_ = confirmed_;
        } else {
          result.confirmed_ = confirmedBuilder_.build();
        }
        result.message_ = message_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ValidateVolumeCapabilitiesResponse) {
          return mergeFrom((csi.v1.Csi.ValidateVolumeCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ValidateVolumeCapabilitiesResponse other) {
        if (other == csi.v1.Csi.ValidateVolumeCapabilitiesResponse.getDefaultInstance()) return this;
        if (other.hasConfirmed()) {
          mergeConfirmed(other.getConfirmed());
        }
        if (!other.getMessage().isEmpty()) {
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ValidateVolumeCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ValidateVolumeCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed confirmed_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder> confirmedBuilder_;
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public boolean hasConfirmed() {
        return confirmedBuilder_ != null || confirmed_ != null;
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed getConfirmed() {
        if (confirmedBuilder_ == null) {
          return confirmed_ == null ? csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.getDefaultInstance() : confirmed_;
        } else {
          return confirmedBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public Builder setConfirmed(csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed value) {
        if (confirmedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          confirmed_ = value;
          onChanged();
        } else {
          confirmedBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public Builder setConfirmed(
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder builderForValue) {
        if (confirmedBuilder_ == null) {
          confirmed_ = builderForValue.build();
          onChanged();
        } else {
          confirmedBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public Builder mergeConfirmed(csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed value) {
        if (confirmedBuilder_ == null) {
          if (confirmed_ != null) {
            confirmed_ =
              csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.newBuilder(confirmed_).mergeFrom(value).buildPartial();
          } else {
            confirmed_ = value;
          }
          onChanged();
        } else {
          confirmedBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public Builder clearConfirmed() {
        if (confirmedBuilder_ == null) {
          confirmed_ = null;
          onChanged();
        } else {
          confirmed_ = null;
          confirmedBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder getConfirmedBuilder() {
        
        onChanged();
        return getConfirmedFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      public csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder getConfirmedOrBuilder() {
        if (confirmedBuilder_ != null) {
          return confirmedBuilder_.getMessageOrBuilder();
        } else {
          return confirmed_ == null ?
              csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.getDefaultInstance() : confirmed_;
        }
      }
      /**
       * <pre>
       * Confirmed indicates to the CO the set of capabilities that the
       * plugin has validated. This field SHALL only be set to a non-empty
       * value for successful validation responses.
       * For successful validation responses, the CO SHALL compare the
       * fields of this message to the originally requested capabilities in
       * order to guard against an older plugin reporting "valid" for newer
       * capability fields that it does not yet understand.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder> 
          getConfirmedFieldBuilder() {
        if (confirmedBuilder_ == null) {
          confirmedBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.Confirmed.Builder, csi.v1.Csi.ValidateVolumeCapabilitiesResponse.ConfirmedOrBuilder>(
                  getConfirmed(),
                  getParentForChildren(),
                  isClean());
          confirmed_ = null;
        }
        return confirmedBuilder_;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message to the CO if `confirmed` above is empty. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message to the CO if `confirmed` above is empty. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message to the CO if `confirmed` above is empty. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message to the CO if `confirmed` above is empty. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder clearMessage() {
        
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message to the CO if `confirmed` above is empty. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        message_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ValidateVolumeCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse)
    private static final csi.v1.Csi.ValidateVolumeCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ValidateVolumeCapabilitiesResponse();
    }

    public static csi.v1.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ValidateVolumeCapabilitiesResponse>() {
      public ValidateVolumeCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidateVolumeCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListVolumesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ListVolumesRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    int getMaxEntries();

    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    java.lang.String getStartingToken();
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getStartingTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v1.ListVolumesRequest}
   */
  public  static final class ListVolumesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ListVolumesRequest)
      ListVolumesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListVolumesRequest.newBuilder() to construct.
    private ListVolumesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListVolumesRequest() {
      maxEntries_ = 0;
      startingToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListVolumesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              maxEntries_ = input.readInt32();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              startingToken_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ListVolumesRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ListVolumesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ListVolumesRequest.class, csi.v1.Csi.ListVolumesRequest.Builder.class);
    }

    public static final int MAX_ENTRIES_FIELD_NUMBER = 1;
    private int maxEntries_;
    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    public int getMaxEntries() {
      return maxEntries_;
    }

    public static final int STARTING_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object startingToken_;
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public java.lang.String getStartingToken() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        startingToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStartingTokenBytes() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startingToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (maxEntries_ != 0) {
        output.writeInt32(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, startingToken_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxEntries_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, startingToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ListVolumesRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ListVolumesRequest other = (csi.v1.Csi.ListVolumesRequest) obj;

      boolean result = true;
      result = result && (getMaxEntries()
          == other.getMaxEntries());
      result = result && getStartingToken()
          .equals(other.getStartingToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ENTRIES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxEntries();
      hash = (37 * hash) + STARTING_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getStartingToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ListVolumesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ListVolumesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ListVolumesRequest)
        csi.v1.Csi.ListVolumesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListVolumesRequest.class, csi.v1.Csi.ListVolumesRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ListVolumesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        maxEntries_ = 0;

        startingToken_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesRequest_descriptor;
      }

      public csi.v1.Csi.ListVolumesRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ListVolumesRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ListVolumesRequest build() {
        csi.v1.Csi.ListVolumesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ListVolumesRequest buildPartial() {
        csi.v1.Csi.ListVolumesRequest result = new csi.v1.Csi.ListVolumesRequest(this);
        result.maxEntries_ = maxEntries_;
        result.startingToken_ = startingToken_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ListVolumesRequest) {
          return mergeFrom((csi.v1.Csi.ListVolumesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ListVolumesRequest other) {
        if (other == csi.v1.Csi.ListVolumesRequest.getDefaultInstance()) return this;
        if (other.getMaxEntries() != 0) {
          setMaxEntries(other.getMaxEntries());
        }
        if (!other.getStartingToken().isEmpty()) {
          startingToken_ = other.startingToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ListVolumesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ListVolumesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int maxEntries_ ;
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public int getMaxEntries() {
        return maxEntries_;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder setMaxEntries(int value) {
        
        maxEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder clearMaxEntries() {
        
        maxEntries_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object startingToken_ = "";
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public java.lang.String getStartingToken() {
        java.lang.Object ref = startingToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          startingToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStartingTokenBytes() {
        java.lang.Object ref = startingToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startingToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        startingToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder clearStartingToken() {
        
        startingToken_ = getDefaultInstance().getStartingToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        startingToken_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ListVolumesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesRequest)
    private static final csi.v1.Csi.ListVolumesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ListVolumesRequest();
    }

    public static csi.v1.Csi.ListVolumesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListVolumesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ListVolumesRequest>() {
      public ListVolumesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListVolumesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListVolumesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListVolumesRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ListVolumesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListVolumesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ListVolumesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    java.util.List<csi.v1.Csi.ListVolumesResponse.Entry> 
        getEntriesList();
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    csi.v1.Csi.ListVolumesResponse.Entry getEntries(int index);
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    int getEntriesCount();
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.ListVolumesResponse.EntryOrBuilder> 
        getEntriesOrBuilderList();
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    csi.v1.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
        int index);

    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    java.lang.String getNextToken();
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getNextTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v1.ListVolumesResponse}
   */
  public  static final class ListVolumesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ListVolumesResponse)
      ListVolumesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListVolumesResponse.newBuilder() to construct.
    private ListVolumesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListVolumesResponse() {
      entries_ = java.util.Collections.emptyList();
      nextToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListVolumesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                entries_ = new java.util.ArrayList<csi.v1.Csi.ListVolumesResponse.Entry>();
                mutable_bitField0_ |= 0x00000001;
              }
              entries_.add(
                  input.readMessage(csi.v1.Csi.ListVolumesResponse.Entry.parser(), extensionRegistry));
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nextToken_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = java.util.Collections.unmodifiableList(entries_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ListVolumesResponse.class, csi.v1.Csi.ListVolumesResponse.Builder.class);
    }

    public interface EntryOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.ListVolumesResponse.Entry)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      boolean hasVolume();
      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      csi.v1.Csi.Volume getVolume();
      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder();
    }
    /**
     * Protobuf type {@code csi.v1.ListVolumesResponse.Entry}
     */
    public  static final class Entry extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.ListVolumesResponse.Entry)
        EntryOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Entry.newBuilder() to construct.
      private Entry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Entry() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Entry(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                csi.v1.Csi.Volume.Builder subBuilder = null;
                if (volume_ != null) {
                  subBuilder = volume_.toBuilder();
                }
                volume_ = input.readMessage(csi.v1.Csi.Volume.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(volume_);
                  volume_ = subBuilder.buildPartial();
                }

                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_Entry_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_Entry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListVolumesResponse.Entry.class, csi.v1.Csi.ListVolumesResponse.Entry.Builder.class);
      }

      public static final int VOLUME_FIELD_NUMBER = 1;
      private csi.v1.Csi.Volume volume_;
      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public boolean hasVolume() {
        return volume_ != null;
      }
      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public csi.v1.Csi.Volume getVolume() {
        return volume_ == null ? csi.v1.Csi.Volume.getDefaultInstance() : volume_;
      }
      /**
       * <code>.csi.v1.Volume volume = 1;</code>
       */
      public csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder() {
        return getVolume();
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (volume_ != null) {
          output.writeMessage(1, getVolume());
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (volume_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getVolume());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.ListVolumesResponse.Entry)) {
          return super.equals(obj);
        }
        csi.v1.Csi.ListVolumesResponse.Entry other = (csi.v1.Csi.ListVolumesResponse.Entry) obj;

        boolean result = true;
        result = result && (hasVolume() == other.hasVolume());
        if (hasVolume()) {
          result = result && getVolume()
              .equals(other.getVolume());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasVolume()) {
          hash = (37 * hash) + VOLUME_FIELD_NUMBER;
          hash = (53 * hash) + getVolume().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.ListVolumesResponse.Entry prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.ListVolumesResponse.Entry}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.ListVolumesResponse.Entry)
          csi.v1.Csi.ListVolumesResponse.EntryOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_Entry_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_Entry_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.ListVolumesResponse.Entry.class, csi.v1.Csi.ListVolumesResponse.Entry.Builder.class);
        }

        // Construct using csi.v1.Csi.ListVolumesResponse.Entry.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          if (volumeBuilder_ == null) {
            volume_ = null;
          } else {
            volume_ = null;
            volumeBuilder_ = null;
          }
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_Entry_descriptor;
        }

        public csi.v1.Csi.ListVolumesResponse.Entry getDefaultInstanceForType() {
          return csi.v1.Csi.ListVolumesResponse.Entry.getDefaultInstance();
        }

        public csi.v1.Csi.ListVolumesResponse.Entry build() {
          csi.v1.Csi.ListVolumesResponse.Entry result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.ListVolumesResponse.Entry buildPartial() {
          csi.v1.Csi.ListVolumesResponse.Entry result = new csi.v1.Csi.ListVolumesResponse.Entry(this);
          if (volumeBuilder_ == null) {
            result.volume_ = volume_;
          } else {
            result.volume_ = volumeBuilder_.build();
          }
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.ListVolumesResponse.Entry) {
            return mergeFrom((csi.v1.Csi.ListVolumesResponse.Entry)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.ListVolumesResponse.Entry other) {
          if (other == csi.v1.Csi.ListVolumesResponse.Entry.getDefaultInstance()) return this;
          if (other.hasVolume()) {
            mergeVolume(other.getVolume());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.ListVolumesResponse.Entry parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.ListVolumesResponse.Entry) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private csi.v1.Csi.Volume volume_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder> volumeBuilder_;
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public boolean hasVolume() {
          return volumeBuilder_ != null || volume_ != null;
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public csi.v1.Csi.Volume getVolume() {
          if (volumeBuilder_ == null) {
            return volume_ == null ? csi.v1.Csi.Volume.getDefaultInstance() : volume_;
          } else {
            return volumeBuilder_.getMessage();
          }
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public Builder setVolume(csi.v1.Csi.Volume value) {
          if (volumeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            volume_ = value;
            onChanged();
          } else {
            volumeBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public Builder setVolume(
            csi.v1.Csi.Volume.Builder builderForValue) {
          if (volumeBuilder_ == null) {
            volume_ = builderForValue.build();
            onChanged();
          } else {
            volumeBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public Builder mergeVolume(csi.v1.Csi.Volume value) {
          if (volumeBuilder_ == null) {
            if (volume_ != null) {
              volume_ =
                csi.v1.Csi.Volume.newBuilder(volume_).mergeFrom(value).buildPartial();
            } else {
              volume_ = value;
            }
            onChanged();
          } else {
            volumeBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public Builder clearVolume() {
          if (volumeBuilder_ == null) {
            volume_ = null;
            onChanged();
          } else {
            volume_ = null;
            volumeBuilder_ = null;
          }

          return this;
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public csi.v1.Csi.Volume.Builder getVolumeBuilder() {
          
          onChanged();
          return getVolumeFieldBuilder().getBuilder();
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        public csi.v1.Csi.VolumeOrBuilder getVolumeOrBuilder() {
          if (volumeBuilder_ != null) {
            return volumeBuilder_.getMessageOrBuilder();
          } else {
            return volume_ == null ?
                csi.v1.Csi.Volume.getDefaultInstance() : volume_;
          }
        }
        /**
         * <code>.csi.v1.Volume volume = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder> 
            getVolumeFieldBuilder() {
          if (volumeBuilder_ == null) {
            volumeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                csi.v1.Csi.Volume, csi.v1.Csi.Volume.Builder, csi.v1.Csi.VolumeOrBuilder>(
                    getVolume(),
                    getParentForChildren(),
                    isClean());
            volume_ = null;
          }
          return volumeBuilder_;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.ListVolumesResponse.Entry)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse.Entry)
      private static final csi.v1.Csi.ListVolumesResponse.Entry DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.ListVolumesResponse.Entry();
      }

      public static csi.v1.Csi.ListVolumesResponse.Entry getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Entry>
          PARSER = new com.google.protobuf.AbstractParser<Entry>() {
        public Entry parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Entry(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Entry> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Entry> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.ListVolumesResponse.Entry getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.ListVolumesResponse.Entry> entries_;
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    public java.util.List<csi.v1.Csi.ListVolumesResponse.Entry> getEntriesList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.ListVolumesResponse.EntryOrBuilder> 
        getEntriesOrBuilderList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    public int getEntriesCount() {
      return entries_.size();
    }
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    public csi.v1.Csi.ListVolumesResponse.Entry getEntries(int index) {
      return entries_.get(index);
    }
    /**
     * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
     */
    public csi.v1.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
        int index) {
      return entries_.get(index);
    }

    public static final int NEXT_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object nextToken_;
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public java.lang.String getNextToken() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nextToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNextTokenBytes() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nextToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < entries_.size(); i++) {
        output.writeMessage(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nextToken_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < entries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nextToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ListVolumesResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ListVolumesResponse other = (csi.v1.Csi.ListVolumesResponse) obj;

      boolean result = true;
      result = result && getEntriesList()
          .equals(other.getEntriesList());
      result = result && getNextToken()
          .equals(other.getNextToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getEntriesCount() > 0) {
        hash = (37 * hash) + ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + getEntriesList().hashCode();
      }
      hash = (37 * hash) + NEXT_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getNextToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ListVolumesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ListVolumesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ListVolumesResponse)
        csi.v1.Csi.ListVolumesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListVolumesResponse.class, csi.v1.Csi.ListVolumesResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ListVolumesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getEntriesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          entriesBuilder_.clear();
        }
        nextToken_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ListVolumesResponse_descriptor;
      }

      public csi.v1.Csi.ListVolumesResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ListVolumesResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ListVolumesResponse build() {
        csi.v1.Csi.ListVolumesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ListVolumesResponse buildPartial() {
        csi.v1.Csi.ListVolumesResponse result = new csi.v1.Csi.ListVolumesResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (entriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            entries_ = java.util.Collections.unmodifiableList(entries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.entries_ = entries_;
        } else {
          result.entries_ = entriesBuilder_.build();
        }
        result.nextToken_ = nextToken_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ListVolumesResponse) {
          return mergeFrom((csi.v1.Csi.ListVolumesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ListVolumesResponse other) {
        if (other == csi.v1.Csi.ListVolumesResponse.getDefaultInstance()) return this;
        if (entriesBuilder_ == null) {
          if (!other.entries_.isEmpty()) {
            if (entries_.isEmpty()) {
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureEntriesIsMutable();
              entries_.addAll(other.entries_);
            }
            onChanged();
          }
        } else {
          if (!other.entries_.isEmpty()) {
            if (entriesBuilder_.isEmpty()) {
              entriesBuilder_.dispose();
              entriesBuilder_ = null;
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              entriesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEntriesFieldBuilder() : null;
            } else {
              entriesBuilder_.addAllMessages(other.entries_);
            }
          }
        }
        if (!other.getNextToken().isEmpty()) {
          nextToken_ = other.nextToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ListVolumesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ListVolumesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.ListVolumesResponse.Entry> entries_ =
        java.util.Collections.emptyList();
      private void ensureEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = new java.util.ArrayList<csi.v1.Csi.ListVolumesResponse.Entry>(entries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ListVolumesResponse.Entry, csi.v1.Csi.ListVolumesResponse.Entry.Builder, csi.v1.Csi.ListVolumesResponse.EntryOrBuilder> entriesBuilder_;

      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ListVolumesResponse.Entry> getEntriesList() {
        if (entriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(entries_);
        } else {
          return entriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public int getEntriesCount() {
        if (entriesBuilder_ == null) {
          return entries_.size();
        } else {
          return entriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListVolumesResponse.Entry getEntries(int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);
        } else {
          return entriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v1.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.set(index, value);
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v1.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.set(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(csi.v1.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v1.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(index, value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          csi.v1.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v1.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addAllEntries(
          java.lang.Iterable<? extends csi.v1.Csi.ListVolumesResponse.Entry> values) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, entries_);
          onChanged();
        } else {
          entriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder clearEntries() {
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          entriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder removeEntries(int index) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.remove(index);
          onChanged();
        } else {
          entriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListVolumesResponse.Entry.Builder getEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
          int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);  } else {
          return entriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.ListVolumesResponse.EntryOrBuilder> 
           getEntriesOrBuilderList() {
        if (entriesBuilder_ != null) {
          return entriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(entries_);
        }
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListVolumesResponse.Entry.Builder addEntriesBuilder() {
        return getEntriesFieldBuilder().addBuilder(
            csi.v1.Csi.ListVolumesResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListVolumesResponse.Entry.Builder addEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().addBuilder(
            index, csi.v1.Csi.ListVolumesResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v1.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ListVolumesResponse.Entry.Builder> 
           getEntriesBuilderList() {
        return getEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ListVolumesResponse.Entry, csi.v1.Csi.ListVolumesResponse.Entry.Builder, csi.v1.Csi.ListVolumesResponse.EntryOrBuilder> 
          getEntriesFieldBuilder() {
        if (entriesBuilder_ == null) {
          entriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.ListVolumesResponse.Entry, csi.v1.Csi.ListVolumesResponse.Entry.Builder, csi.v1.Csi.ListVolumesResponse.EntryOrBuilder>(
                  entries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          entries_ = null;
        }
        return entriesBuilder_;
      }

      private java.lang.Object nextToken_ = "";
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public java.lang.String getNextToken() {
        java.lang.Object ref = nextToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nextToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNextTokenBytes() {
        java.lang.Object ref = nextToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nextToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nextToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder clearNextToken() {
        
        nextToken_ = getDefaultInstance().getNextToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nextToken_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ListVolumesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse)
    private static final csi.v1.Csi.ListVolumesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ListVolumesResponse();
    }

    public static csi.v1.Csi.ListVolumesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListVolumesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ListVolumesResponse>() {
      public ListVolumesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListVolumesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListVolumesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListVolumesResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ListVolumesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetCapacityRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetCapacityRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    java.util.List<csi.v1.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    boolean hasAccessibleTopology();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    csi.v1.Csi.Topology getAccessibleTopology();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.GetCapacityRequest}
   */
  public  static final class GetCapacityRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetCapacityRequest)
      GetCapacityRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetCapacityRequest.newBuilder() to construct.
    private GetCapacityRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetCapacityRequest() {
      volumeCapabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetCapacityRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            case 26: {
              csi.v1.Csi.Topology.Builder subBuilder = null;
              if (accessibleTopology_ != null) {
                subBuilder = accessibleTopology_.toBuilder();
              }
              accessibleTopology_ = input.readMessage(csi.v1.Csi.Topology.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibleTopology_);
                accessibleTopology_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetCapacityRequest.class, csi.v1.Csi.GetCapacityRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 2;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 3;
    private csi.v1.Csi.Topology accessibleTopology_;
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public boolean hasAccessibleTopology() {
      return accessibleTopology_ != null;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public csi.v1.Csi.Topology getAccessibleTopology() {
      return accessibleTopology_ == null ? csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
      return getAccessibleTopology();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(1, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          2);
      if (accessibleTopology_ != null) {
        output.writeMessage(3, getAccessibleTopology());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, parameters__);
      }
      if (accessibleTopology_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessibleTopology());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetCapacityRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetCapacityRequest other = (csi.v1.Csi.GetCapacityRequest) obj;

      boolean result = true;
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && (hasAccessibleTopology() == other.hasAccessibleTopology());
      if (hasAccessibleTopology()) {
        result = result && getAccessibleTopology()
            .equals(other.getAccessibleTopology());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (hasAccessibleTopology()) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopology().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetCapacityRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.GetCapacityRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetCapacityRequest)
        csi.v1.Csi.GetCapacityRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetCapacityRequest.class, csi.v1.Csi.GetCapacityRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.GetCapacityRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableParameters().clear();
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityRequest_descriptor;
      }

      public csi.v1.Csi.GetCapacityRequest getDefaultInstanceForType() {
        return csi.v1.Csi.GetCapacityRequest.getDefaultInstance();
      }

      public csi.v1.Csi.GetCapacityRequest build() {
        csi.v1.Csi.GetCapacityRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetCapacityRequest buildPartial() {
        csi.v1.Csi.GetCapacityRequest result = new csi.v1.Csi.GetCapacityRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        if (accessibleTopologyBuilder_ == null) {
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetCapacityRequest) {
          return mergeFrom((csi.v1.Csi.GetCapacityRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetCapacityRequest other) {
        if (other == csi.v1.Csi.GetCapacityRequest.getDefaultInstance()) return this;
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        if (other.hasAccessibleTopology()) {
          mergeAccessibleTopology(other.getAccessibleTopology());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetCapacityRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetCapacityRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v1.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v1.Csi.Topology accessibleTopology_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public boolean hasAccessibleTopology() {
        return accessibleTopologyBuilder_ != null || accessibleTopology_ != null;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.Topology getAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_ == null ? csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        } else {
          return accessibleTopologyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibleTopology_ = value;
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(
          csi.v1.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = builderForValue.build();
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder mergeAccessibleTopology(csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (accessibleTopology_ != null) {
            accessibleTopology_ =
              csi.v1.Csi.Topology.newBuilder(accessibleTopology_).mergeFrom(value).buildPartial();
          } else {
            accessibleTopology_ = value;
          }
          onChanged();
        } else {
          accessibleTopologyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
          onChanged();
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.Topology.Builder getAccessibleTopologyBuilder() {
        
        onChanged();
        return getAccessibleTopologyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilder();
        } else {
          return accessibleTopology_ == null ?
              csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder>(
                  getAccessibleTopology(),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetCapacityRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityRequest)
    private static final csi.v1.Csi.GetCapacityRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetCapacityRequest();
    }

    public static csi.v1.Csi.GetCapacityRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetCapacityRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetCapacityRequest>() {
      public GetCapacityRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetCapacityRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetCapacityRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetCapacityRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetCapacityRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetCapacityResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.GetCapacityResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If `volume_capabilities` or `parameters` is
     * specified in the request, the Plugin SHALL take those into
     * consideration when calculating the available capacity of the
     * storage. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available_capacity = 1;</code>
     */
    long getAvailableCapacity();
  }
  /**
   * Protobuf type {@code csi.v1.GetCapacityResponse}
   */
  public  static final class GetCapacityResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.GetCapacityResponse)
      GetCapacityResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetCapacityResponse.newBuilder() to construct.
    private GetCapacityResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetCapacityResponse() {
      availableCapacity_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetCapacityResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              availableCapacity_ = input.readInt64();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_GetCapacityResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_GetCapacityResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.GetCapacityResponse.class, csi.v1.Csi.GetCapacityResponse.Builder.class);
    }

    public static final int AVAILABLE_CAPACITY_FIELD_NUMBER = 1;
    private long availableCapacity_;
    /**
     * <pre>
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If `volume_capabilities` or `parameters` is
     * specified in the request, the Plugin SHALL take those into
     * consideration when calculating the available capacity of the
     * storage. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available_capacity = 1;</code>
     */
    public long getAvailableCapacity() {
      return availableCapacity_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (availableCapacity_ != 0L) {
        output.writeInt64(1, availableCapacity_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (availableCapacity_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, availableCapacity_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.GetCapacityResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.GetCapacityResponse other = (csi.v1.Csi.GetCapacityResponse) obj;

      boolean result = true;
      result = result && (getAvailableCapacity()
          == other.getAvailableCapacity());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AVAILABLE_CAPACITY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAvailableCapacity());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.GetCapacityResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.GetCapacityResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.GetCapacityResponse)
        csi.v1.Csi.GetCapacityResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.GetCapacityResponse.class, csi.v1.Csi.GetCapacityResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.GetCapacityResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        availableCapacity_ = 0L;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_GetCapacityResponse_descriptor;
      }

      public csi.v1.Csi.GetCapacityResponse getDefaultInstanceForType() {
        return csi.v1.Csi.GetCapacityResponse.getDefaultInstance();
      }

      public csi.v1.Csi.GetCapacityResponse build() {
        csi.v1.Csi.GetCapacityResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.GetCapacityResponse buildPartial() {
        csi.v1.Csi.GetCapacityResponse result = new csi.v1.Csi.GetCapacityResponse(this);
        result.availableCapacity_ = availableCapacity_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.GetCapacityResponse) {
          return mergeFrom((csi.v1.Csi.GetCapacityResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.GetCapacityResponse other) {
        if (other == csi.v1.Csi.GetCapacityResponse.getDefaultInstance()) return this;
        if (other.getAvailableCapacity() != 0L) {
          setAvailableCapacity(other.getAvailableCapacity());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.GetCapacityResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.GetCapacityResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long availableCapacity_ ;
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public long getAvailableCapacity() {
        return availableCapacity_;
      }
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public Builder setAvailableCapacity(long value) {
        
        availableCapacity_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public Builder clearAvailableCapacity() {
        
        availableCapacity_ = 0L;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.GetCapacityResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityResponse)
    private static final csi.v1.Csi.GetCapacityResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.GetCapacityResponse();
    }

    public static csi.v1.Csi.GetCapacityResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetCapacityResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetCapacityResponse>() {
      public GetCapacityResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetCapacityResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetCapacityResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetCapacityResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.GetCapacityResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerGetCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerGetCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.ControllerGetCapabilitiesRequest}
   */
  public  static final class ControllerGetCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerGetCapabilitiesRequest)
      ControllerGetCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerGetCapabilitiesRequest.newBuilder() to construct.
    private ControllerGetCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerGetCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerGetCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerGetCapabilitiesRequest.class, csi.v1.Csi.ControllerGetCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerGetCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerGetCapabilitiesRequest other = (csi.v1.Csi.ControllerGetCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerGetCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.ControllerGetCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerGetCapabilitiesRequest)
        csi.v1.Csi.ControllerGetCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerGetCapabilitiesRequest.class, csi.v1.Csi.ControllerGetCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerGetCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor;
      }

      public csi.v1.Csi.ControllerGetCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerGetCapabilitiesRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerGetCapabilitiesRequest build() {
        csi.v1.Csi.ControllerGetCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerGetCapabilitiesRequest buildPartial() {
        csi.v1.Csi.ControllerGetCapabilitiesRequest result = new csi.v1.Csi.ControllerGetCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerGetCapabilitiesRequest) {
          return mergeFrom((csi.v1.Csi.ControllerGetCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerGetCapabilitiesRequest other) {
        if (other == csi.v1.Csi.ControllerGetCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerGetCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerGetCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerGetCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesRequest)
    private static final csi.v1.Csi.ControllerGetCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerGetCapabilitiesRequest();
    }

    public static csi.v1.Csi.ControllerGetCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerGetCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerGetCapabilitiesRequest>() {
      public ControllerGetCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerGetCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerGetCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerGetCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerGetCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerGetCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerGetCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    java.util.List<csi.v1.Csi.ControllerServiceCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    csi.v1.Csi.ControllerServiceCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.ControllerServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    csi.v1.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v1.ControllerGetCapabilitiesResponse}
   */
  public  static final class ControllerGetCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerGetCapabilitiesResponse)
      ControllerGetCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerGetCapabilitiesResponse.newBuilder() to construct.
    private ControllerGetCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerGetCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerGetCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v1.Csi.ControllerServiceCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v1.Csi.ControllerServiceCapability.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerGetCapabilitiesResponse.class, csi.v1.Csi.ControllerGetCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.ControllerServiceCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    public java.util.List<csi.v1.Csi.ControllerServiceCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.ControllerServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.ControllerServiceCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(1, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerGetCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerGetCapabilitiesResponse other = (csi.v1.Csi.ControllerGetCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerGetCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerGetCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerGetCapabilitiesResponse)
        csi.v1.Csi.ControllerGetCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerGetCapabilitiesResponse.class, csi.v1.Csi.ControllerGetCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerGetCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor;
      }

      public csi.v1.Csi.ControllerGetCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerGetCapabilitiesResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerGetCapabilitiesResponse build() {
        csi.v1.Csi.ControllerGetCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerGetCapabilitiesResponse buildPartial() {
        csi.v1.Csi.ControllerGetCapabilitiesResponse result = new csi.v1.Csi.ControllerGetCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerGetCapabilitiesResponse) {
          return mergeFrom((csi.v1.Csi.ControllerGetCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerGetCapabilitiesResponse other) {
        if (other == csi.v1.Csi.ControllerGetCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerGetCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerGetCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.ControllerServiceCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v1.Csi.ControllerServiceCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ControllerServiceCapability, csi.v1.Csi.ControllerServiceCapability.Builder, csi.v1.Csi.ControllerServiceCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ControllerServiceCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(csi.v1.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          csi.v1.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.ControllerServiceCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.ControllerServiceCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.ControllerServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.ControllerServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.ControllerServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ControllerServiceCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ControllerServiceCapability, csi.v1.Csi.ControllerServiceCapability.Builder, csi.v1.Csi.ControllerServiceCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.ControllerServiceCapability, csi.v1.Csi.ControllerServiceCapability.Builder, csi.v1.Csi.ControllerServiceCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerGetCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesResponse)
    private static final csi.v1.Csi.ControllerGetCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerGetCapabilitiesResponse();
    }

    public static csi.v1.Csi.ControllerGetCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerGetCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerGetCapabilitiesResponse>() {
      public ControllerGetCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerGetCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerGetCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerGetCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerGetCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerServiceCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerServiceCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    boolean hasRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    csi.v1.Csi.ControllerServiceCapability.RPC getRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder();

    public csi.v1.Csi.ControllerServiceCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the controller service.
   * </pre>
   *
   * Protobuf type {@code csi.v1.ControllerServiceCapability}
   */
  public  static final class ControllerServiceCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerServiceCapability)
      ControllerServiceCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerServiceCapability.newBuilder() to construct.
    private ControllerServiceCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerServiceCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerServiceCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.ControllerServiceCapability.RPC.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v1.Csi.ControllerServiceCapability.RPC) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.ControllerServiceCapability.RPC.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.ControllerServiceCapability.RPC) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerServiceCapability.class, csi.v1.Csi.ControllerServiceCapability.Builder.class);
    }

    public interface RPCOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.ControllerServiceCapability.RPC)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      csi.v1.Csi.ControllerServiceCapability.RPC.Type getType();
    }
    /**
     * Protobuf type {@code csi.v1.ControllerServiceCapability.RPC}
     */
    public  static final class RPC extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.ControllerServiceCapability.RPC)
        RPCOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use RPC.newBuilder() to construct.
      private RPC(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private RPC() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private RPC(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_RPC_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerServiceCapability.RPC.class, csi.v1.Csi.ControllerServiceCapability.RPC.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v1.ControllerServiceCapability.RPC.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <code>CREATE_DELETE_VOLUME = 1;</code>
         */
        CREATE_DELETE_VOLUME(1),
        /**
         * <code>PUBLISH_UNPUBLISH_VOLUME = 2;</code>
         */
        PUBLISH_UNPUBLISH_VOLUME(2),
        /**
         * <code>LIST_VOLUMES = 3;</code>
         */
        LIST_VOLUMES(3),
        /**
         * <code>GET_CAPACITY = 4;</code>
         */
        GET_CAPACITY(4),
        /**
         * <pre>
         * Currently the only way to consume a snapshot is to create
         * a volume from it. Therefore plugins supporting
         * CREATE_DELETE_SNAPSHOT MUST support creating volume from
         * snapshot.
         * </pre>
         *
         * <code>CREATE_DELETE_SNAPSHOT = 5;</code>
         */
        CREATE_DELETE_SNAPSHOT(5),
        /**
         * <code>LIST_SNAPSHOTS = 6;</code>
         */
        LIST_SNAPSHOTS(6),
        /**
         * <pre>
         * Plugins supporting volume cloning at the storage level MAY
         * report this capability. The source volume MUST be managed by
         * the same plugin. Not all volume sources and parameters
         * combinations MAY work.
         * </pre>
         *
         * <code>CLONE_VOLUME = 7;</code>
         */
        CLONE_VOLUME(7),
        /**
         * <pre>
         * Indicates the SP supports ControllerPublishVolume.readonly
         * field.
         * </pre>
         *
         * <code>PUBLISH_READONLY = 8;</code>
         */
        PUBLISH_READONLY(8),
        /**
         * <pre>
         * See VolumeExpansion for details.
         * </pre>
         *
         * <code>EXPAND_VOLUME = 9;</code>
         */
        EXPAND_VOLUME(9),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <code>CREATE_DELETE_VOLUME = 1;</code>
         */
        public static final int CREATE_DELETE_VOLUME_VALUE = 1;
        /**
         * <code>PUBLISH_UNPUBLISH_VOLUME = 2;</code>
         */
        public static final int PUBLISH_UNPUBLISH_VOLUME_VALUE = 2;
        /**
         * <code>LIST_VOLUMES = 3;</code>
         */
        public static final int LIST_VOLUMES_VALUE = 3;
        /**
         * <code>GET_CAPACITY = 4;</code>
         */
        public static final int GET_CAPACITY_VALUE = 4;
        /**
         * <pre>
         * Currently the only way to consume a snapshot is to create
         * a volume from it. Therefore plugins supporting
         * CREATE_DELETE_SNAPSHOT MUST support creating volume from
         * snapshot.
         * </pre>
         *
         * <code>CREATE_DELETE_SNAPSHOT = 5;</code>
         */
        public static final int CREATE_DELETE_SNAPSHOT_VALUE = 5;
        /**
         * <code>LIST_SNAPSHOTS = 6;</code>
         */
        public static final int LIST_SNAPSHOTS_VALUE = 6;
        /**
         * <pre>
         * Plugins supporting volume cloning at the storage level MAY
         * report this capability. The source volume MUST be managed by
         * the same plugin. Not all volume sources and parameters
         * combinations MAY work.
         * </pre>
         *
         * <code>CLONE_VOLUME = 7;</code>
         */
        public static final int CLONE_VOLUME_VALUE = 7;
        /**
         * <pre>
         * Indicates the SP supports ControllerPublishVolume.readonly
         * field.
         * </pre>
         *
         * <code>PUBLISH_READONLY = 8;</code>
         */
        public static final int PUBLISH_READONLY_VALUE = 8;
        /**
         * <pre>
         * See VolumeExpansion for details.
         * </pre>
         *
         * <code>EXPAND_VOLUME = 9;</code>
         */
        public static final int EXPAND_VOLUME_VALUE = 9;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return CREATE_DELETE_VOLUME;
            case 2: return PUBLISH_UNPUBLISH_VOLUME;
            case 3: return LIST_VOLUMES;
            case 4: return GET_CAPACITY;
            case 5: return CREATE_DELETE_SNAPSHOT;
            case 6: return LIST_SNAPSHOTS;
            case 7: return CLONE_VOLUME;
            case 8: return PUBLISH_READONLY;
            case 9: return EXPAND_VOLUME;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v1.Csi.ControllerServiceCapability.RPC.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v1.ControllerServiceCapability.RPC.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.RPC.Type getType() {
        csi.v1.Csi.ControllerServiceCapability.RPC.Type result = csi.v1.Csi.ControllerServiceCapability.RPC.Type.valueOf(type_);
        return result == null ? csi.v1.Csi.ControllerServiceCapability.RPC.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v1.Csi.ControllerServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v1.Csi.ControllerServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.ControllerServiceCapability.RPC)) {
          return super.equals(obj);
        }
        csi.v1.Csi.ControllerServiceCapability.RPC other = (csi.v1.Csi.ControllerServiceCapability.RPC) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.ControllerServiceCapability.RPC prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.ControllerServiceCapability.RPC}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.ControllerServiceCapability.RPC)
          csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_RPC_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.ControllerServiceCapability.RPC.class, csi.v1.Csi.ControllerServiceCapability.RPC.Builder.class);
        }

        // Construct using csi.v1.Csi.ControllerServiceCapability.RPC.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor;
        }

        public csi.v1.Csi.ControllerServiceCapability.RPC getDefaultInstanceForType() {
          return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }

        public csi.v1.Csi.ControllerServiceCapability.RPC build() {
          csi.v1.Csi.ControllerServiceCapability.RPC result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.ControllerServiceCapability.RPC buildPartial() {
          csi.v1.Csi.ControllerServiceCapability.RPC result = new csi.v1.Csi.ControllerServiceCapability.RPC(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.ControllerServiceCapability.RPC) {
            return mergeFrom((csi.v1.Csi.ControllerServiceCapability.RPC)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.ControllerServiceCapability.RPC other) {
          if (other == csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.ControllerServiceCapability.RPC parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.ControllerServiceCapability.RPC) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public csi.v1.Csi.ControllerServiceCapability.RPC.Type getType() {
          csi.v1.Csi.ControllerServiceCapability.RPC.Type result = csi.v1.Csi.ControllerServiceCapability.RPC.Type.valueOf(type_);
          return result == null ? csi.v1.Csi.ControllerServiceCapability.RPC.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setType(csi.v1.Csi.ControllerServiceCapability.RPC.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.ControllerServiceCapability.RPC)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability.RPC)
      private static final csi.v1.Csi.ControllerServiceCapability.RPC DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.ControllerServiceCapability.RPC();
      }

      public static csi.v1.Csi.ControllerServiceCapability.RPC getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<RPC>
          PARSER = new com.google.protobuf.AbstractParser<RPC>() {
        public RPC parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new RPC(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<RPC> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<RPC> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.ControllerServiceCapability.RPC getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      RPC(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return RPC;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int RPC_FIELD_NUMBER = 1;
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public boolean hasRpc() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v1.Csi.ControllerServiceCapability.RPC getRpc() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.ControllerServiceCapability.RPC) type_;
      }
      return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.ControllerServiceCapability.RPC) type_;
      }
      return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v1.Csi.ControllerServiceCapability.RPC) type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v1.Csi.ControllerServiceCapability.RPC) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerServiceCapability)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerServiceCapability other = (csi.v1.Csi.ControllerServiceCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getRpc()
              .equals(other.getRpc());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + RPC_FIELD_NUMBER;
          hash = (53 * hash) + getRpc().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerServiceCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the controller service.
     * </pre>
     *
     * Protobuf type {@code csi.v1.ControllerServiceCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerServiceCapability)
        csi.v1.Csi.ControllerServiceCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerServiceCapability.class, csi.v1.Csi.ControllerServiceCapability.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerServiceCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerServiceCapability_descriptor;
      }

      public csi.v1.Csi.ControllerServiceCapability getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerServiceCapability.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerServiceCapability build() {
        csi.v1.Csi.ControllerServiceCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerServiceCapability buildPartial() {
        csi.v1.Csi.ControllerServiceCapability result = new csi.v1.Csi.ControllerServiceCapability(this);
        if (typeCase_ == 1) {
          if (rpcBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = rpcBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerServiceCapability) {
          return mergeFrom((csi.v1.Csi.ControllerServiceCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerServiceCapability other) {
        if (other == csi.v1.Csi.ControllerServiceCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case RPC: {
            mergeRpc(other.getRpc());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerServiceCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerServiceCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.ControllerServiceCapability.RPC, csi.v1.Csi.ControllerServiceCapability.RPC.Builder, csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder> rpcBuilder_;
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public boolean hasRpc() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.RPC getRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.ControllerServiceCapability.RPC) type_;
          }
          return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return rpcBuilder_.getMessage();
          }
          return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(csi.v1.Csi.ControllerServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(
          csi.v1.Csi.ControllerServiceCapability.RPC.Builder builderForValue) {
        if (rpcBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          rpcBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder mergeRpc(csi.v1.Csi.ControllerServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance()) {
            type_ = csi.v1.Csi.ControllerServiceCapability.RPC.newBuilder((csi.v1.Csi.ControllerServiceCapability.RPC) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            rpcBuilder_.mergeFrom(value);
          }
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder clearRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          rpcBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.RPC.Builder getRpcBuilder() {
        return getRpcFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder() {
        if ((typeCase_ == 1) && (rpcBuilder_ != null)) {
          return rpcBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.ControllerServiceCapability.RPC) type_;
          }
          return csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.ControllerServiceCapability.RPC, csi.v1.Csi.ControllerServiceCapability.RPC.Builder, csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder> 
          getRpcFieldBuilder() {
        if (rpcBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v1.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
          }
          rpcBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.ControllerServiceCapability.RPC, csi.v1.Csi.ControllerServiceCapability.RPC.Builder, csi.v1.Csi.ControllerServiceCapability.RPCOrBuilder>(
                  (csi.v1.Csi.ControllerServiceCapability.RPC) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return rpcBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerServiceCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability)
    private static final csi.v1.Csi.ControllerServiceCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerServiceCapability();
    }

    public static csi.v1.Csi.ControllerServiceCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerServiceCapability>
        PARSER = new com.google.protobuf.AbstractParser<ControllerServiceCapability>() {
      public ControllerServiceCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerServiceCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerServiceCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerServiceCapability> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerServiceCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateSnapshotRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.CreateSnapshotRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.CreateSnapshotRequest}
   */
  public  static final class CreateSnapshotRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.CreateSnapshotRequest)
      CreateSnapshotRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateSnapshotRequest.newBuilder() to construct.
    private CreateSnapshotRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateSnapshotRequest() {
      sourceVolumeId_ = "";
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateSnapshotRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetSecrets();
        case 4:
          return internalGetParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.CreateSnapshotRequest.class, csi.v1.Csi.CreateSnapshotRequest.Builder.class);
    }

    private int bitField0_;
    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * Any Unicode string that conforms to the length limit is allowed
     * except those containing the following banned characters:
     * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
     * (These are control characters other than commonly used whitespace.)
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SECRETS_FIELD_NUMBER = 3;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 4;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, sourceVolumeId_);
      }
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          3);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          4);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, sourceVolumeId_);
      }
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, secrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, parameters__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.CreateSnapshotRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.CreateSnapshotRequest other = (csi.v1.Csi.CreateSnapshotRequest) obj;

      boolean result = true;
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && getName()
          .equals(other.getName());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.CreateSnapshotRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.CreateSnapshotRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.CreateSnapshotRequest)
        csi.v1.Csi.CreateSnapshotRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetSecrets();
          case 4:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableSecrets();
          case 4:
            return internalGetMutableParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.CreateSnapshotRequest.class, csi.v1.Csi.CreateSnapshotRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.CreateSnapshotRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        sourceVolumeId_ = "";

        name_ = "";

        internalGetMutableSecrets().clear();
        internalGetMutableParameters().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotRequest_descriptor;
      }

      public csi.v1.Csi.CreateSnapshotRequest getDefaultInstanceForType() {
        return csi.v1.Csi.CreateSnapshotRequest.getDefaultInstance();
      }

      public csi.v1.Csi.CreateSnapshotRequest build() {
        csi.v1.Csi.CreateSnapshotRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.CreateSnapshotRequest buildPartial() {
        csi.v1.Csi.CreateSnapshotRequest result = new csi.v1.Csi.CreateSnapshotRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.sourceVolumeId_ = sourceVolumeId_;
        result.name_ = name_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.CreateSnapshotRequest) {
          return mergeFrom((csi.v1.Csi.CreateSnapshotRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.CreateSnapshotRequest other) {
        if (other == csi.v1.Csi.CreateSnapshotRequest.getDefaultInstance()) return this;
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.CreateSnapshotRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.CreateSnapshotRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * Any Unicode string that conforms to the length limit is allowed
       * except those containing the following banned characters:
       * U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
       * (These are control characters other than commonly used whitespace.)
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.CreateSnapshotRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotRequest)
    private static final csi.v1.Csi.CreateSnapshotRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.CreateSnapshotRequest();
    }

    public static csi.v1.Csi.CreateSnapshotRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateSnapshotRequest>
        PARSER = new com.google.protobuf.AbstractParser<CreateSnapshotRequest>() {
      public CreateSnapshotRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateSnapshotRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateSnapshotRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateSnapshotRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.CreateSnapshotRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateSnapshotResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.CreateSnapshotResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    boolean hasSnapshot();
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    csi.v1.Csi.Snapshot getSnapshot();
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.CreateSnapshotResponse}
   */
  public  static final class CreateSnapshotResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.CreateSnapshotResponse)
      CreateSnapshotResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateSnapshotResponse.newBuilder() to construct.
    private CreateSnapshotResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateSnapshotResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateSnapshotResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.Snapshot.Builder subBuilder = null;
              if (snapshot_ != null) {
                subBuilder = snapshot_.toBuilder();
              }
              snapshot_ = input.readMessage(csi.v1.Csi.Snapshot.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(snapshot_);
                snapshot_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.CreateSnapshotResponse.class, csi.v1.Csi.CreateSnapshotResponse.Builder.class);
    }

    public static final int SNAPSHOT_FIELD_NUMBER = 1;
    private csi.v1.Csi.Snapshot snapshot_;
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    public boolean hasSnapshot() {
      return snapshot_ != null;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    public csi.v1.Csi.Snapshot getSnapshot() {
      return snapshot_ == null ? csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.Snapshot snapshot = 1;</code>
     */
    public csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
      return getSnapshot();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (snapshot_ != null) {
        output.writeMessage(1, getSnapshot());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (snapshot_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSnapshot());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.CreateSnapshotResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.CreateSnapshotResponse other = (csi.v1.Csi.CreateSnapshotResponse) obj;

      boolean result = true;
      result = result && (hasSnapshot() == other.hasSnapshot());
      if (hasSnapshot()) {
        result = result && getSnapshot()
            .equals(other.getSnapshot());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSnapshot()) {
        hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
        hash = (53 * hash) + getSnapshot().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.CreateSnapshotResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.CreateSnapshotResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.CreateSnapshotResponse)
        csi.v1.Csi.CreateSnapshotResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.CreateSnapshotResponse.class, csi.v1.Csi.CreateSnapshotResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.CreateSnapshotResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (snapshotBuilder_ == null) {
          snapshot_ = null;
        } else {
          snapshot_ = null;
          snapshotBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_CreateSnapshotResponse_descriptor;
      }

      public csi.v1.Csi.CreateSnapshotResponse getDefaultInstanceForType() {
        return csi.v1.Csi.CreateSnapshotResponse.getDefaultInstance();
      }

      public csi.v1.Csi.CreateSnapshotResponse build() {
        csi.v1.Csi.CreateSnapshotResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.CreateSnapshotResponse buildPartial() {
        csi.v1.Csi.CreateSnapshotResponse result = new csi.v1.Csi.CreateSnapshotResponse(this);
        if (snapshotBuilder_ == null) {
          result.snapshot_ = snapshot_;
        } else {
          result.snapshot_ = snapshotBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.CreateSnapshotResponse) {
          return mergeFrom((csi.v1.Csi.CreateSnapshotResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.CreateSnapshotResponse other) {
        if (other == csi.v1.Csi.CreateSnapshotResponse.getDefaultInstance()) return this;
        if (other.hasSnapshot()) {
          mergeSnapshot(other.getSnapshot());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.CreateSnapshotResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.CreateSnapshotResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private csi.v1.Csi.Snapshot snapshot_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder> snapshotBuilder_;
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return snapshotBuilder_ != null || snapshot_ != null;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public csi.v1.Csi.Snapshot getSnapshot() {
        if (snapshotBuilder_ == null) {
          return snapshot_ == null ? csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
        } else {
          return snapshotBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public Builder setSnapshot(csi.v1.Csi.Snapshot value) {
        if (snapshotBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          snapshot_ = value;
          onChanged();
        } else {
          snapshotBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public Builder setSnapshot(
          csi.v1.Csi.Snapshot.Builder builderForValue) {
        if (snapshotBuilder_ == null) {
          snapshot_ = builderForValue.build();
          onChanged();
        } else {
          snapshotBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public Builder mergeSnapshot(csi.v1.Csi.Snapshot value) {
        if (snapshotBuilder_ == null) {
          if (snapshot_ != null) {
            snapshot_ =
              csi.v1.Csi.Snapshot.newBuilder(snapshot_).mergeFrom(value).buildPartial();
          } else {
            snapshot_ = value;
          }
          onChanged();
        } else {
          snapshotBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public Builder clearSnapshot() {
        if (snapshotBuilder_ == null) {
          snapshot_ = null;
          onChanged();
        } else {
          snapshot_ = null;
          snapshotBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public csi.v1.Csi.Snapshot.Builder getSnapshotBuilder() {
        
        onChanged();
        return getSnapshotFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
        if (snapshotBuilder_ != null) {
          return snapshotBuilder_.getMessageOrBuilder();
        } else {
          return snapshot_ == null ?
              csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder> 
          getSnapshotFieldBuilder() {
        if (snapshotBuilder_ == null) {
          snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder>(
                  getSnapshot(),
                  getParentForChildren(),
                  isClean());
          snapshot_ = null;
        }
        return snapshotBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.CreateSnapshotResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotResponse)
    private static final csi.v1.Csi.CreateSnapshotResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.CreateSnapshotResponse();
    }

    public static csi.v1.Csi.CreateSnapshotResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateSnapshotResponse>
        PARSER = new com.google.protobuf.AbstractParser<CreateSnapshotResponse>() {
      public CreateSnapshotResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateSnapshotResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateSnapshotResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateSnapshotResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.CreateSnapshotResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SnapshotOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.Snapshot)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is the complete size of the snapshot in bytes. The purpose of
     * this field is to give CO guidance on how much space is needed to
     * create a volume from this snapshot. The size of the volume MUST NOT
     * be less than the size of the source snapshot. This field is
     * OPTIONAL. If this field is not set, it indicates that this size is
     * unknown. The value of this field MUST NOT be negative and a size of
     * zero means it is unspecified.
     * </pre>
     *
     * <code>int64 size_bytes = 1;</code>
     */
    long getSizeBytes();

    /**
     * <pre>
     * The identifier for this snapshot, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific snapshot vs all other snapshots supported by this
     * plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this snapshot.
     * The SP is NOT responsible for global uniqueness of snapshot_id
     * across multiple SPs.
     * </pre>
     *
     * <code>string snapshot_id = 2;</code>
     */
    java.lang.String getSnapshotId();
    /**
     * <pre>
     * The identifier for this snapshot, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific snapshot vs all other snapshots supported by this
     * plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this snapshot.
     * The SP is NOT responsible for global uniqueness of snapshot_id
     * across multiple SPs.
     * </pre>
     *
     * <code>string snapshot_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getSnapshotIdBytes();

    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    boolean hasCreationTime();
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    com.google.protobuf.Timestamp getCreationTime();
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    com.google.protobuf.TimestampOrBuilder getCreationTimeOrBuilder();

    /**
     * <pre>
     * Indicates if a snapshot is ready to use as a
     * `volume_content_source` in a `CreateVolumeRequest`. The default
     * value is false. This field is REQUIRED.
     * </pre>
     *
     * <code>bool ready_to_use = 5;</code>
     */
    boolean getReadyToUse();
  }
  /**
   * <pre>
   * Information about a specific snapshot.
   * </pre>
   *
   * Protobuf type {@code csi.v1.Snapshot}
   */
  public  static final class Snapshot extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.Snapshot)
      SnapshotOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Snapshot.newBuilder() to construct.
    private Snapshot(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Snapshot() {
      sizeBytes_ = 0L;
      snapshotId_ = "";
      sourceVolumeId_ = "";
      readyToUse_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Snapshot(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              sizeBytes_ = input.readInt64();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              snapshotId_ = s;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 34: {
              com.google.protobuf.Timestamp.Builder subBuilder = null;
              if (creationTime_ != null) {
                subBuilder = creationTime_.toBuilder();
              }
              creationTime_ = input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(creationTime_);
                creationTime_ = subBuilder.buildPartial();
              }

              break;
            }
            case 40: {

              readyToUse_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_Snapshot_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_Snapshot_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.Snapshot.class, csi.v1.Csi.Snapshot.Builder.class);
    }

    public static final int SIZE_BYTES_FIELD_NUMBER = 1;
    private long sizeBytes_;
    /**
     * <pre>
     * This is the complete size of the snapshot in bytes. The purpose of
     * this field is to give CO guidance on how much space is needed to
     * create a volume from this snapshot. The size of the volume MUST NOT
     * be less than the size of the source snapshot. This field is
     * OPTIONAL. If this field is not set, it indicates that this size is
     * unknown. The value of this field MUST NOT be negative and a size of
     * zero means it is unspecified.
     * </pre>
     *
     * <code>int64 size_bytes = 1;</code>
     */
    public long getSizeBytes() {
      return sizeBytes_;
    }

    public static final int SNAPSHOT_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object snapshotId_;
    /**
     * <pre>
     * The identifier for this snapshot, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific snapshot vs all other snapshots supported by this
     * plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this snapshot.
     * The SP is NOT responsible for global uniqueness of snapshot_id
     * across multiple SPs.
     * </pre>
     *
     * <code>string snapshot_id = 2;</code>
     */
    public java.lang.String getSnapshotId() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        snapshotId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The identifier for this snapshot, generated by the plugin.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific snapshot vs all other snapshots supported by this
     * plugin.
     * This field SHALL be used by the CO in subsequent calls to refer to
     * this snapshot.
     * The SP is NOT responsible for global uniqueness of snapshot_id
     * across multiple SPs.
     * </pre>
     *
     * <code>string snapshot_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getSnapshotIdBytes() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        snapshotId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 3;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CREATION_TIME_FIELD_NUMBER = 4;
    private com.google.protobuf.Timestamp creationTime_;
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    public boolean hasCreationTime() {
      return creationTime_ != null;
    }
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    public com.google.protobuf.Timestamp getCreationTime() {
      return creationTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : creationTime_;
    }
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. This field is REQUIRED.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp creation_time = 4;</code>
     */
    public com.google.protobuf.TimestampOrBuilder getCreationTimeOrBuilder() {
      return getCreationTime();
    }

    public static final int READY_TO_USE_FIELD_NUMBER = 5;
    private boolean readyToUse_;
    /**
     * <pre>
     * Indicates if a snapshot is ready to use as a
     * `volume_content_source` in a `CreateVolumeRequest`. The default
     * value is false. This field is REQUIRED.
     * </pre>
     *
     * <code>bool ready_to_use = 5;</code>
     */
    public boolean getReadyToUse() {
      return readyToUse_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (sizeBytes_ != 0L) {
        output.writeInt64(1, sizeBytes_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, snapshotId_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sourceVolumeId_);
      }
      if (creationTime_ != null) {
        output.writeMessage(4, getCreationTime());
      }
      if (readyToUse_ != false) {
        output.writeBool(5, readyToUse_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (sizeBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, sizeBytes_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, snapshotId_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sourceVolumeId_);
      }
      if (creationTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getCreationTime());
      }
      if (readyToUse_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, readyToUse_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.Snapshot)) {
        return super.equals(obj);
      }
      csi.v1.Csi.Snapshot other = (csi.v1.Csi.Snapshot) obj;

      boolean result = true;
      result = result && (getSizeBytes()
          == other.getSizeBytes());
      result = result && getSnapshotId()
          .equals(other.getSnapshotId());
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && (hasCreationTime() == other.hasCreationTime());
      if (hasCreationTime()) {
        result = result && getCreationTime()
            .equals(other.getCreationTime());
      }
      result = result && (getReadyToUse()
          == other.getReadyToUse());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SIZE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSizeBytes());
      hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSnapshotId().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      if (hasCreationTime()) {
        hash = (37 * hash) + CREATION_TIME_FIELD_NUMBER;
        hash = (53 * hash) + getCreationTime().hashCode();
      }
      hash = (37 * hash) + READY_TO_USE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReadyToUse());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.Snapshot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Snapshot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.Snapshot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Snapshot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Snapshot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.Snapshot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.Snapshot prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Information about a specific snapshot.
     * </pre>
     *
     * Protobuf type {@code csi.v1.Snapshot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.Snapshot)
        csi.v1.Csi.SnapshotOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_Snapshot_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_Snapshot_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.Snapshot.class, csi.v1.Csi.Snapshot.Builder.class);
      }

      // Construct using csi.v1.Csi.Snapshot.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        sizeBytes_ = 0L;

        snapshotId_ = "";

        sourceVolumeId_ = "";

        if (creationTimeBuilder_ == null) {
          creationTime_ = null;
        } else {
          creationTime_ = null;
          creationTimeBuilder_ = null;
        }
        readyToUse_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_Snapshot_descriptor;
      }

      public csi.v1.Csi.Snapshot getDefaultInstanceForType() {
        return csi.v1.Csi.Snapshot.getDefaultInstance();
      }

      public csi.v1.Csi.Snapshot build() {
        csi.v1.Csi.Snapshot result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.Snapshot buildPartial() {
        csi.v1.Csi.Snapshot result = new csi.v1.Csi.Snapshot(this);
        result.sizeBytes_ = sizeBytes_;
        result.snapshotId_ = snapshotId_;
        result.sourceVolumeId_ = sourceVolumeId_;
        if (creationTimeBuilder_ == null) {
          result.creationTime_ = creationTime_;
        } else {
          result.creationTime_ = creationTimeBuilder_.build();
        }
        result.readyToUse_ = readyToUse_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.Snapshot) {
          return mergeFrom((csi.v1.Csi.Snapshot)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.Snapshot other) {
        if (other == csi.v1.Csi.Snapshot.getDefaultInstance()) return this;
        if (other.getSizeBytes() != 0L) {
          setSizeBytes(other.getSizeBytes());
        }
        if (!other.getSnapshotId().isEmpty()) {
          snapshotId_ = other.snapshotId_;
          onChanged();
        }
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (other.hasCreationTime()) {
          mergeCreationTime(other.getCreationTime());
        }
        if (other.getReadyToUse() != false) {
          setReadyToUse(other.getReadyToUse());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.Snapshot parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.Snapshot) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long sizeBytes_ ;
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public long getSizeBytes() {
        return sizeBytes_;
      }
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public Builder setSizeBytes(long value) {
        
        sizeBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public Builder clearSizeBytes() {
        
        sizeBytes_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object snapshotId_ = "";
      /**
       * <pre>
       * The identifier for this snapshot, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific snapshot vs all other snapshots supported by this
       * plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this snapshot.
       * The SP is NOT responsible for global uniqueness of snapshot_id
       * across multiple SPs.
       * </pre>
       *
       * <code>string snapshot_id = 2;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The identifier for this snapshot, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific snapshot vs all other snapshots supported by this
       * plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this snapshot.
       * The SP is NOT responsible for global uniqueness of snapshot_id
       * across multiple SPs.
       * </pre>
       *
       * <code>string snapshot_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The identifier for this snapshot, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific snapshot vs all other snapshots supported by this
       * plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this snapshot.
       * The SP is NOT responsible for global uniqueness of snapshot_id
       * across multiple SPs.
       * </pre>
       *
       * <code>string snapshot_id = 2;</code>
       */
      public Builder setSnapshotId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        snapshotId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier for this snapshot, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific snapshot vs all other snapshots supported by this
       * plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this snapshot.
       * The SP is NOT responsible for global uniqueness of snapshot_id
       * across multiple SPs.
       * </pre>
       *
       * <code>string snapshot_id = 2;</code>
       */
      public Builder clearSnapshotId() {
        
        snapshotId_ = getDefaultInstance().getSnapshotId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier for this snapshot, generated by the plugin.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific snapshot vs all other snapshots supported by this
       * plugin.
       * This field SHALL be used by the CO in subsequent calls to refer to
       * this snapshot.
       * The SP is NOT responsible for global uniqueness of snapshot_id
       * across multiple SPs.
       * </pre>
       *
       * <code>string snapshot_id = 2;</code>
       */
      public Builder setSnapshotIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        snapshotId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.Timestamp creationTime_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> creationTimeBuilder_;
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public boolean hasCreationTime() {
        return creationTimeBuilder_ != null || creationTime_ != null;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public com.google.protobuf.Timestamp getCreationTime() {
        if (creationTimeBuilder_ == null) {
          return creationTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : creationTime_;
        } else {
          return creationTimeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public Builder setCreationTime(com.google.protobuf.Timestamp value) {
        if (creationTimeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          creationTime_ = value;
          onChanged();
        } else {
          creationTimeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public Builder setCreationTime(
          com.google.protobuf.Timestamp.Builder builderForValue) {
        if (creationTimeBuilder_ == null) {
          creationTime_ = builderForValue.build();
          onChanged();
        } else {
          creationTimeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public Builder mergeCreationTime(com.google.protobuf.Timestamp value) {
        if (creationTimeBuilder_ == null) {
          if (creationTime_ != null) {
            creationTime_ =
              com.google.protobuf.Timestamp.newBuilder(creationTime_).mergeFrom(value).buildPartial();
          } else {
            creationTime_ = value;
          }
          onChanged();
        } else {
          creationTimeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public Builder clearCreationTime() {
        if (creationTimeBuilder_ == null) {
          creationTime_ = null;
          onChanged();
        } else {
          creationTime_ = null;
          creationTimeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public com.google.protobuf.Timestamp.Builder getCreationTimeBuilder() {
        
        onChanged();
        return getCreationTimeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      public com.google.protobuf.TimestampOrBuilder getCreationTimeOrBuilder() {
        if (creationTimeBuilder_ != null) {
          return creationTimeBuilder_.getMessageOrBuilder();
        } else {
          return creationTime_ == null ?
              com.google.protobuf.Timestamp.getDefaultInstance() : creationTime_;
        }
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. This field is REQUIRED.
       * </pre>
       *
       * <code>.google.protobuf.Timestamp creation_time = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> 
          getCreationTimeFieldBuilder() {
        if (creationTimeBuilder_ == null) {
          creationTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(
                  getCreationTime(),
                  getParentForChildren(),
                  isClean());
          creationTime_ = null;
        }
        return creationTimeBuilder_;
      }

      private boolean readyToUse_ ;
      /**
       * <pre>
       * Indicates if a snapshot is ready to use as a
       * `volume_content_source` in a `CreateVolumeRequest`. The default
       * value is false. This field is REQUIRED.
       * </pre>
       *
       * <code>bool ready_to_use = 5;</code>
       */
      public boolean getReadyToUse() {
        return readyToUse_;
      }
      /**
       * <pre>
       * Indicates if a snapshot is ready to use as a
       * `volume_content_source` in a `CreateVolumeRequest`. The default
       * value is false. This field is REQUIRED.
       * </pre>
       *
       * <code>bool ready_to_use = 5;</code>
       */
      public Builder setReadyToUse(boolean value) {
        
        readyToUse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates if a snapshot is ready to use as a
       * `volume_content_source` in a `CreateVolumeRequest`. The default
       * value is false. This field is REQUIRED.
       * </pre>
       *
       * <code>bool ready_to_use = 5;</code>
       */
      public Builder clearReadyToUse() {
        
        readyToUse_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.Snapshot)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.Snapshot)
    private static final csi.v1.Csi.Snapshot DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.Snapshot();
    }

    public static csi.v1.Csi.Snapshot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Snapshot>
        PARSER = new com.google.protobuf.AbstractParser<Snapshot>() {
      public Snapshot parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Snapshot(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Snapshot> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Snapshot> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.Snapshot getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteSnapshotRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.DeleteSnapshotRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    java.lang.String getSnapshotId();
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getSnapshotIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.DeleteSnapshotRequest}
   */
  public  static final class DeleteSnapshotRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.DeleteSnapshotRequest)
      DeleteSnapshotRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteSnapshotRequest.newBuilder() to construct.
    private DeleteSnapshotRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteSnapshotRequest() {
      snapshotId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteSnapshotRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              snapshotId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.DeleteSnapshotRequest.class, csi.v1.Csi.DeleteSnapshotRequest.Builder.class);
    }

    private int bitField0_;
    public static final int SNAPSHOT_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object snapshotId_;
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    public java.lang.String getSnapshotId() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        snapshotId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSnapshotIdBytes() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        snapshotId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SECRETS_FIELD_NUMBER = 2;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getSnapshotIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, snapshotId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          2);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getSnapshotIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, snapshotId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, secrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.DeleteSnapshotRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.DeleteSnapshotRequest other = (csi.v1.Csi.DeleteSnapshotRequest) obj;

      boolean result = true;
      result = result && getSnapshotId()
          .equals(other.getSnapshotId());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSnapshotId().hashCode();
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.DeleteSnapshotRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.DeleteSnapshotRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.DeleteSnapshotRequest)
        csi.v1.Csi.DeleteSnapshotRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.DeleteSnapshotRequest.class, csi.v1.Csi.DeleteSnapshotRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.DeleteSnapshotRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        snapshotId_ = "";

        internalGetMutableSecrets().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotRequest_descriptor;
      }

      public csi.v1.Csi.DeleteSnapshotRequest getDefaultInstanceForType() {
        return csi.v1.Csi.DeleteSnapshotRequest.getDefaultInstance();
      }

      public csi.v1.Csi.DeleteSnapshotRequest build() {
        csi.v1.Csi.DeleteSnapshotRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.DeleteSnapshotRequest buildPartial() {
        csi.v1.Csi.DeleteSnapshotRequest result = new csi.v1.Csi.DeleteSnapshotRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.snapshotId_ = snapshotId_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.DeleteSnapshotRequest) {
          return mergeFrom((csi.v1.Csi.DeleteSnapshotRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.DeleteSnapshotRequest other) {
        if (other == csi.v1.Csi.DeleteSnapshotRequest.getDefaultInstance()) return this;
        if (!other.getSnapshotId().isEmpty()) {
          snapshotId_ = other.snapshotId_;
          onChanged();
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.DeleteSnapshotRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.DeleteSnapshotRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object snapshotId_ = "";
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder setSnapshotId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        snapshotId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder clearSnapshotId() {
        
        snapshotId_ = getDefaultInstance().getSnapshotId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder setSnapshotIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        snapshotId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 2 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.DeleteSnapshotRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotRequest)
    private static final csi.v1.Csi.DeleteSnapshotRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.DeleteSnapshotRequest();
    }

    public static csi.v1.Csi.DeleteSnapshotRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteSnapshotRequest>
        PARSER = new com.google.protobuf.AbstractParser<DeleteSnapshotRequest>() {
      public DeleteSnapshotRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteSnapshotRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteSnapshotRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteSnapshotRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.DeleteSnapshotRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteSnapshotResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.DeleteSnapshotResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code csi.v1.DeleteSnapshotResponse}
   */
  public  static final class DeleteSnapshotResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.DeleteSnapshotResponse)
      DeleteSnapshotResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteSnapshotResponse.newBuilder() to construct.
    private DeleteSnapshotResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteSnapshotResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteSnapshotResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.DeleteSnapshotResponse.class, csi.v1.Csi.DeleteSnapshotResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.DeleteSnapshotResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.DeleteSnapshotResponse other = (csi.v1.Csi.DeleteSnapshotResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.DeleteSnapshotResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.DeleteSnapshotResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.DeleteSnapshotResponse)
        csi.v1.Csi.DeleteSnapshotResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.DeleteSnapshotResponse.class, csi.v1.Csi.DeleteSnapshotResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.DeleteSnapshotResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_DeleteSnapshotResponse_descriptor;
      }

      public csi.v1.Csi.DeleteSnapshotResponse getDefaultInstanceForType() {
        return csi.v1.Csi.DeleteSnapshotResponse.getDefaultInstance();
      }

      public csi.v1.Csi.DeleteSnapshotResponse build() {
        csi.v1.Csi.DeleteSnapshotResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.DeleteSnapshotResponse buildPartial() {
        csi.v1.Csi.DeleteSnapshotResponse result = new csi.v1.Csi.DeleteSnapshotResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.DeleteSnapshotResponse) {
          return mergeFrom((csi.v1.Csi.DeleteSnapshotResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.DeleteSnapshotResponse other) {
        if (other == csi.v1.Csi.DeleteSnapshotResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.DeleteSnapshotResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.DeleteSnapshotResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.DeleteSnapshotResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotResponse)
    private static final csi.v1.Csi.DeleteSnapshotResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.DeleteSnapshotResponse();
    }

    public static csi.v1.Csi.DeleteSnapshotResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteSnapshotResponse>
        PARSER = new com.google.protobuf.AbstractParser<DeleteSnapshotResponse>() {
      public DeleteSnapshotResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteSnapshotResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteSnapshotResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteSnapshotResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.DeleteSnapshotResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSnapshotsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ListSnapshotsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    int getMaxEntries();

    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    java.lang.String getStartingToken();
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getStartingTokenBytes();

    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being processed after
     * it is cut.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    java.lang.String getSnapshotId();
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being processed after
     * it is cut.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    com.google.protobuf.ByteString
        getSnapshotIdBytes();
  }
  /**
   * <pre>
   * List all snapshots on the storage system regardless of how they were
   * created.
   * </pre>
   *
   * Protobuf type {@code csi.v1.ListSnapshotsRequest}
   */
  public  static final class ListSnapshotsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ListSnapshotsRequest)
      ListSnapshotsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSnapshotsRequest.newBuilder() to construct.
    private ListSnapshotsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSnapshotsRequest() {
      maxEntries_ = 0;
      startingToken_ = "";
      sourceVolumeId_ = "";
      snapshotId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListSnapshotsRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              maxEntries_ = input.readInt32();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              startingToken_ = s;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              snapshotId_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ListSnapshotsRequest.class, csi.v1.Csi.ListSnapshotsRequest.Builder.class);
    }

    public static final int MAX_ENTRIES_FIELD_NUMBER = 1;
    private int maxEntries_;
    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    public int getMaxEntries() {
      return maxEntries_;
    }

    public static final int STARTING_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object startingToken_;
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public java.lang.String getStartingToken() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        startingToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStartingTokenBytes() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startingToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 3;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SNAPSHOT_ID_FIELD_NUMBER = 4;
    private volatile java.lang.Object snapshotId_;
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being processed after
     * it is cut.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    public java.lang.String getSnapshotId() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        snapshotId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being processed after
     * it is cut.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    public com.google.protobuf.ByteString
        getSnapshotIdBytes() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        snapshotId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (maxEntries_ != 0) {
        output.writeInt32(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, startingToken_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sourceVolumeId_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, snapshotId_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxEntries_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, startingToken_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sourceVolumeId_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, snapshotId_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ListSnapshotsRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ListSnapshotsRequest other = (csi.v1.Csi.ListSnapshotsRequest) obj;

      boolean result = true;
      result = result && (getMaxEntries()
          == other.getMaxEntries());
      result = result && getStartingToken()
          .equals(other.getStartingToken());
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && getSnapshotId()
          .equals(other.getSnapshotId());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ENTRIES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxEntries();
      hash = (37 * hash) + STARTING_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getStartingToken().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSnapshotId().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ListSnapshotsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * List all snapshots on the storage system regardless of how they were
     * created.
     * </pre>
     *
     * Protobuf type {@code csi.v1.ListSnapshotsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ListSnapshotsRequest)
        csi.v1.Csi.ListSnapshotsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListSnapshotsRequest.class, csi.v1.Csi.ListSnapshotsRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ListSnapshotsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        maxEntries_ = 0;

        startingToken_ = "";

        sourceVolumeId_ = "";

        snapshotId_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsRequest_descriptor;
      }

      public csi.v1.Csi.ListSnapshotsRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ListSnapshotsRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ListSnapshotsRequest build() {
        csi.v1.Csi.ListSnapshotsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ListSnapshotsRequest buildPartial() {
        csi.v1.Csi.ListSnapshotsRequest result = new csi.v1.Csi.ListSnapshotsRequest(this);
        result.maxEntries_ = maxEntries_;
        result.startingToken_ = startingToken_;
        result.sourceVolumeId_ = sourceVolumeId_;
        result.snapshotId_ = snapshotId_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ListSnapshotsRequest) {
          return mergeFrom((csi.v1.Csi.ListSnapshotsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ListSnapshotsRequest other) {
        if (other == csi.v1.Csi.ListSnapshotsRequest.getDefaultInstance()) return this;
        if (other.getMaxEntries() != 0) {
          setMaxEntries(other.getMaxEntries());
        }
        if (!other.getStartingToken().isEmpty()) {
          startingToken_ = other.startingToken_;
          onChanged();
        }
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (!other.getSnapshotId().isEmpty()) {
          snapshotId_ = other.snapshotId_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ListSnapshotsRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ListSnapshotsRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int maxEntries_ ;
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public int getMaxEntries() {
        return maxEntries_;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder setMaxEntries(int value) {
        
        maxEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder clearMaxEntries() {
        
        maxEntries_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object startingToken_ = "";
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public java.lang.String getStartingToken() {
        java.lang.Object ref = startingToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          startingToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStartingTokenBytes() {
        java.lang.Object ref = startingToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startingToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        startingToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder clearStartingToken() {
        
        startingToken_ = getDefaultInstance().getStartingToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        startingToken_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object snapshotId_ = "";
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being processed after
       * it is cut.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being processed after
       * it is cut.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being processed after
       * it is cut.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder setSnapshotId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        snapshotId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being processed after
       * it is cut.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder clearSnapshotId() {
        
        snapshotId_ = getDefaultInstance().getSnapshotId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being processed after
       * it is cut.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder setSnapshotIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        snapshotId_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ListSnapshotsRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsRequest)
    private static final csi.v1.Csi.ListSnapshotsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ListSnapshotsRequest();
    }

    public static csi.v1.Csi.ListSnapshotsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSnapshotsRequest>
        PARSER = new com.google.protobuf.AbstractParser<ListSnapshotsRequest>() {
      public ListSnapshotsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListSnapshotsRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListSnapshotsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSnapshotsRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ListSnapshotsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSnapshotsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ListSnapshotsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry> 
        getEntriesList();
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    csi.v1.Csi.ListSnapshotsResponse.Entry getEntries(int index);
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    int getEntriesCount();
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder> 
        getEntriesOrBuilderList();
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
        int index);

    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    java.lang.String getNextToken();
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getNextTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v1.ListSnapshotsResponse}
   */
  public  static final class ListSnapshotsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ListSnapshotsResponse)
      ListSnapshotsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSnapshotsResponse.newBuilder() to construct.
    private ListSnapshotsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSnapshotsResponse() {
      entries_ = java.util.Collections.emptyList();
      nextToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListSnapshotsResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                entries_ = new java.util.ArrayList<csi.v1.Csi.ListSnapshotsResponse.Entry>();
                mutable_bitField0_ |= 0x00000001;
              }
              entries_.add(
                  input.readMessage(csi.v1.Csi.ListSnapshotsResponse.Entry.parser(), extensionRegistry));
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nextToken_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = java.util.Collections.unmodifiableList(entries_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ListSnapshotsResponse.class, csi.v1.Csi.ListSnapshotsResponse.Builder.class);
    }

    public interface EntryOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.ListSnapshotsResponse.Entry)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      boolean hasSnapshot();
      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      csi.v1.Csi.Snapshot getSnapshot();
      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder();
    }
    /**
     * Protobuf type {@code csi.v1.ListSnapshotsResponse.Entry}
     */
    public  static final class Entry extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.ListSnapshotsResponse.Entry)
        EntryOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Entry.newBuilder() to construct.
      private Entry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Entry() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Entry(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                csi.v1.Csi.Snapshot.Builder subBuilder = null;
                if (snapshot_ != null) {
                  subBuilder = snapshot_.toBuilder();
                }
                snapshot_ = input.readMessage(csi.v1.Csi.Snapshot.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(snapshot_);
                  snapshot_ = subBuilder.buildPartial();
                }

                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_Entry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListSnapshotsResponse.Entry.class, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder.class);
      }

      public static final int SNAPSHOT_FIELD_NUMBER = 1;
      private csi.v1.Csi.Snapshot snapshot_;
      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return snapshot_ != null;
      }
      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public csi.v1.Csi.Snapshot getSnapshot() {
        return snapshot_ == null ? csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
      }
      /**
       * <code>.csi.v1.Snapshot snapshot = 1;</code>
       */
      public csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
        return getSnapshot();
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (snapshot_ != null) {
          output.writeMessage(1, getSnapshot());
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (snapshot_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getSnapshot());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.ListSnapshotsResponse.Entry)) {
          return super.equals(obj);
        }
        csi.v1.Csi.ListSnapshotsResponse.Entry other = (csi.v1.Csi.ListSnapshotsResponse.Entry) obj;

        boolean result = true;
        result = result && (hasSnapshot() == other.hasSnapshot());
        if (hasSnapshot()) {
          result = result && getSnapshot()
              .equals(other.getSnapshot());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasSnapshot()) {
          hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
          hash = (53 * hash) + getSnapshot().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.ListSnapshotsResponse.Entry prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.ListSnapshotsResponse.Entry}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.ListSnapshotsResponse.Entry)
          csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_Entry_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.ListSnapshotsResponse.Entry.class, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder.class);
        }

        // Construct using csi.v1.Csi.ListSnapshotsResponse.Entry.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          if (snapshotBuilder_ == null) {
            snapshot_ = null;
          } else {
            snapshot_ = null;
            snapshotBuilder_ = null;
          }
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor;
        }

        public csi.v1.Csi.ListSnapshotsResponse.Entry getDefaultInstanceForType() {
          return csi.v1.Csi.ListSnapshotsResponse.Entry.getDefaultInstance();
        }

        public csi.v1.Csi.ListSnapshotsResponse.Entry build() {
          csi.v1.Csi.ListSnapshotsResponse.Entry result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.ListSnapshotsResponse.Entry buildPartial() {
          csi.v1.Csi.ListSnapshotsResponse.Entry result = new csi.v1.Csi.ListSnapshotsResponse.Entry(this);
          if (snapshotBuilder_ == null) {
            result.snapshot_ = snapshot_;
          } else {
            result.snapshot_ = snapshotBuilder_.build();
          }
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.ListSnapshotsResponse.Entry) {
            return mergeFrom((csi.v1.Csi.ListSnapshotsResponse.Entry)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.ListSnapshotsResponse.Entry other) {
          if (other == csi.v1.Csi.ListSnapshotsResponse.Entry.getDefaultInstance()) return this;
          if (other.hasSnapshot()) {
            mergeSnapshot(other.getSnapshot());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.ListSnapshotsResponse.Entry parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.ListSnapshotsResponse.Entry) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private csi.v1.Csi.Snapshot snapshot_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder> snapshotBuilder_;
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public boolean hasSnapshot() {
          return snapshotBuilder_ != null || snapshot_ != null;
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public csi.v1.Csi.Snapshot getSnapshot() {
          if (snapshotBuilder_ == null) {
            return snapshot_ == null ? csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
          } else {
            return snapshotBuilder_.getMessage();
          }
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public Builder setSnapshot(csi.v1.Csi.Snapshot value) {
          if (snapshotBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            snapshot_ = value;
            onChanged();
          } else {
            snapshotBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public Builder setSnapshot(
            csi.v1.Csi.Snapshot.Builder builderForValue) {
          if (snapshotBuilder_ == null) {
            snapshot_ = builderForValue.build();
            onChanged();
          } else {
            snapshotBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public Builder mergeSnapshot(csi.v1.Csi.Snapshot value) {
          if (snapshotBuilder_ == null) {
            if (snapshot_ != null) {
              snapshot_ =
                csi.v1.Csi.Snapshot.newBuilder(snapshot_).mergeFrom(value).buildPartial();
            } else {
              snapshot_ = value;
            }
            onChanged();
          } else {
            snapshotBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public Builder clearSnapshot() {
          if (snapshotBuilder_ == null) {
            snapshot_ = null;
            onChanged();
          } else {
            snapshot_ = null;
            snapshotBuilder_ = null;
          }

          return this;
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public csi.v1.Csi.Snapshot.Builder getSnapshotBuilder() {
          
          onChanged();
          return getSnapshotFieldBuilder().getBuilder();
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        public csi.v1.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
          if (snapshotBuilder_ != null) {
            return snapshotBuilder_.getMessageOrBuilder();
          } else {
            return snapshot_ == null ?
                csi.v1.Csi.Snapshot.getDefaultInstance() : snapshot_;
          }
        }
        /**
         * <code>.csi.v1.Snapshot snapshot = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder> 
            getSnapshotFieldBuilder() {
          if (snapshotBuilder_ == null) {
            snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                csi.v1.Csi.Snapshot, csi.v1.Csi.Snapshot.Builder, csi.v1.Csi.SnapshotOrBuilder>(
                    getSnapshot(),
                    getParentForChildren(),
                    isClean());
            snapshot_ = null;
          }
          return snapshotBuilder_;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.ListSnapshotsResponse.Entry)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse.Entry)
      private static final csi.v1.Csi.ListSnapshotsResponse.Entry DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.ListSnapshotsResponse.Entry();
      }

      public static csi.v1.Csi.ListSnapshotsResponse.Entry getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Entry>
          PARSER = new com.google.protobuf.AbstractParser<Entry>() {
        public Entry parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Entry(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Entry> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Entry> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.ListSnapshotsResponse.Entry getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry> entries_;
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry> getEntriesList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder> 
        getEntriesOrBuilderList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public int getEntriesCount() {
      return entries_.size();
    }
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public csi.v1.Csi.ListSnapshotsResponse.Entry getEntries(int index) {
      return entries_.get(index);
    }
    /**
     * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
        int index) {
      return entries_.get(index);
    }

    public static final int NEXT_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object nextToken_;
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public java.lang.String getNextToken() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nextToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNextTokenBytes() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nextToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < entries_.size(); i++) {
        output.writeMessage(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nextToken_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < entries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nextToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ListSnapshotsResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ListSnapshotsResponse other = (csi.v1.Csi.ListSnapshotsResponse) obj;

      boolean result = true;
      result = result && getEntriesList()
          .equals(other.getEntriesList());
      result = result && getNextToken()
          .equals(other.getNextToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getEntriesCount() > 0) {
        hash = (37 * hash) + ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + getEntriesList().hashCode();
      }
      hash = (37 * hash) + NEXT_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getNextToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ListSnapshotsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ListSnapshotsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ListSnapshotsResponse)
        csi.v1.Csi.ListSnapshotsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ListSnapshotsResponse.class, csi.v1.Csi.ListSnapshotsResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ListSnapshotsResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getEntriesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          entriesBuilder_.clear();
        }
        nextToken_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ListSnapshotsResponse_descriptor;
      }

      public csi.v1.Csi.ListSnapshotsResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ListSnapshotsResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ListSnapshotsResponse build() {
        csi.v1.Csi.ListSnapshotsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ListSnapshotsResponse buildPartial() {
        csi.v1.Csi.ListSnapshotsResponse result = new csi.v1.Csi.ListSnapshotsResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (entriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            entries_ = java.util.Collections.unmodifiableList(entries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.entries_ = entries_;
        } else {
          result.entries_ = entriesBuilder_.build();
        }
        result.nextToken_ = nextToken_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ListSnapshotsResponse) {
          return mergeFrom((csi.v1.Csi.ListSnapshotsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ListSnapshotsResponse other) {
        if (other == csi.v1.Csi.ListSnapshotsResponse.getDefaultInstance()) return this;
        if (entriesBuilder_ == null) {
          if (!other.entries_.isEmpty()) {
            if (entries_.isEmpty()) {
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureEntriesIsMutable();
              entries_.addAll(other.entries_);
            }
            onChanged();
          }
        } else {
          if (!other.entries_.isEmpty()) {
            if (entriesBuilder_.isEmpty()) {
              entriesBuilder_.dispose();
              entriesBuilder_ = null;
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              entriesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEntriesFieldBuilder() : null;
            } else {
              entriesBuilder_.addAllMessages(other.entries_);
            }
          }
        }
        if (!other.getNextToken().isEmpty()) {
          nextToken_ = other.nextToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ListSnapshotsResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ListSnapshotsResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry> entries_ =
        java.util.Collections.emptyList();
      private void ensureEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = new java.util.ArrayList<csi.v1.Csi.ListSnapshotsResponse.Entry>(entries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ListSnapshotsResponse.Entry, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder, csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder> entriesBuilder_;

      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry> getEntriesList() {
        if (entriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(entries_);
        } else {
          return entriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public int getEntriesCount() {
        if (entriesBuilder_ == null) {
          return entries_.size();
        } else {
          return entriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListSnapshotsResponse.Entry getEntries(int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);
        } else {
          return entriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v1.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.set(index, value);
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.set(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(csi.v1.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v1.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(index, value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          csi.v1.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addAllEntries(
          java.lang.Iterable<? extends csi.v1.Csi.ListSnapshotsResponse.Entry> values) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, entries_);
          onChanged();
        } else {
          entriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder clearEntries() {
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          entriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder removeEntries(int index) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.remove(index);
          onChanged();
        } else {
          entriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListSnapshotsResponse.Entry.Builder getEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
          int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);  } else {
          return entriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder> 
           getEntriesOrBuilderList() {
        if (entriesBuilder_ != null) {
          return entriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(entries_);
        }
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListSnapshotsResponse.Entry.Builder addEntriesBuilder() {
        return getEntriesFieldBuilder().addBuilder(
            csi.v1.Csi.ListSnapshotsResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v1.Csi.ListSnapshotsResponse.Entry.Builder addEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().addBuilder(
            index, csi.v1.Csi.ListSnapshotsResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v1.Csi.ListSnapshotsResponse.Entry.Builder> 
           getEntriesBuilderList() {
        return getEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.ListSnapshotsResponse.Entry, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder, csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder> 
          getEntriesFieldBuilder() {
        if (entriesBuilder_ == null) {
          entriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.ListSnapshotsResponse.Entry, csi.v1.Csi.ListSnapshotsResponse.Entry.Builder, csi.v1.Csi.ListSnapshotsResponse.EntryOrBuilder>(
                  entries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          entries_ = null;
        }
        return entriesBuilder_;
      }

      private java.lang.Object nextToken_ = "";
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public java.lang.String getNextToken() {
        java.lang.Object ref = nextToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nextToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNextTokenBytes() {
        java.lang.Object ref = nextToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nextToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nextToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder clearNextToken() {
        
        nextToken_ = getDefaultInstance().getNextToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nextToken_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ListSnapshotsResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse)
    private static final csi.v1.Csi.ListSnapshotsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ListSnapshotsResponse();
    }

    public static csi.v1.Csi.ListSnapshotsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSnapshotsResponse>
        PARSER = new com.google.protobuf.AbstractParser<ListSnapshotsResponse>() {
      public ListSnapshotsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListSnapshotsResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListSnapshotsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSnapshotsResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ListSnapshotsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerExpandVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerExpandVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to expand. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to expand. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    boolean hasCapacityRange();
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    csi.v1.Csi.CapacityRange getCapacityRange();
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder();

    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.ControllerExpandVolumeRequest}
   */
  public  static final class ControllerExpandVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerExpandVolumeRequest)
      ControllerExpandVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerExpandVolumeRequest.newBuilder() to construct.
    private ControllerExpandVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerExpandVolumeRequest() {
      volumeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerExpandVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              csi.v1.Csi.CapacityRange.Builder subBuilder = null;
              if (capacityRange_ != null) {
                subBuilder = capacityRange_.toBuilder();
              }
              capacityRange_ = input.readMessage(csi.v1.Csi.CapacityRange.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(capacityRange_);
                capacityRange_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerExpandVolumeRequest.class, csi.v1.Csi.ControllerExpandVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to expand. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to expand. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAPACITY_RANGE_FIELD_NUMBER = 2;
    private csi.v1.Csi.CapacityRange capacityRange_;
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public boolean hasCapacityRange() {
      return capacityRange_ != null;
    }
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public csi.v1.Csi.CapacityRange getCapacityRange() {
      return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
    }
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
     */
    public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
      return getCapacityRange();
    }

    public static final int SECRETS_FIELD_NUMBER = 3;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by the plugin for expanding the volume.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (capacityRange_ != null) {
        output.writeMessage(2, getCapacityRange());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          3);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (capacityRange_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getCapacityRange());
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, secrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerExpandVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerExpandVolumeRequest other = (csi.v1.Csi.ControllerExpandVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && (hasCapacityRange() == other.hasCapacityRange());
      if (hasCapacityRange()) {
        result = result && getCapacityRange()
            .equals(other.getCapacityRange());
      }
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (hasCapacityRange()) {
        hash = (37 * hash) + CAPACITY_RANGE_FIELD_NUMBER;
        hash = (53 * hash) + getCapacityRange().hashCode();
      }
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerExpandVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerExpandVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerExpandVolumeRequest)
        csi.v1.Csi.ControllerExpandVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerExpandVolumeRequest.class, csi.v1.Csi.ControllerExpandVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerExpandVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }
        internalGetMutableSecrets().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor;
      }

      public csi.v1.Csi.ControllerExpandVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerExpandVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerExpandVolumeRequest build() {
        csi.v1.Csi.ControllerExpandVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerExpandVolumeRequest buildPartial() {
        csi.v1.Csi.ControllerExpandVolumeRequest result = new csi.v1.Csi.ControllerExpandVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        if (capacityRangeBuilder_ == null) {
          result.capacityRange_ = capacityRange_;
        } else {
          result.capacityRange_ = capacityRangeBuilder_.build();
        }
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerExpandVolumeRequest) {
          return mergeFrom((csi.v1.Csi.ControllerExpandVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerExpandVolumeRequest other) {
        if (other == csi.v1.Csi.ControllerExpandVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (other.hasCapacityRange()) {
          mergeCapacityRange(other.getCapacityRange());
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerExpandVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerExpandVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to expand. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to expand. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to expand. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to expand. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to expand. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.CapacityRange capacityRange_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> capacityRangeBuilder_;
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public boolean hasCapacityRange() {
        return capacityRangeBuilder_ != null || capacityRange_ != null;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRange getCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        } else {
          return capacityRangeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capacityRange_ = value;
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(
          csi.v1.Csi.CapacityRange.Builder builderForValue) {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = builderForValue.build();
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder mergeCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (capacityRange_ != null) {
            capacityRange_ =
              csi.v1.Csi.CapacityRange.newBuilder(capacityRange_).mergeFrom(value).buildPartial();
          } else {
            capacityRange_ = value;
          }
          onChanged();
        } else {
          capacityRangeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public Builder clearCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
          onChanged();
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRange.Builder getCapacityRangeBuilder() {
        
        onChanged();
        return getCapacityRangeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
        if (capacityRangeBuilder_ != null) {
          return capacityRangeBuilder_.getMessageOrBuilder();
        } else {
          return capacityRange_ == null ?
              csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        }
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> 
          getCapacityRangeFieldBuilder() {
        if (capacityRangeBuilder_ == null) {
          capacityRangeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder>(
                  getCapacityRange(),
                  getParentForChildren(),
                  isClean());
          capacityRange_ = null;
        }
        return capacityRangeBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by the plugin for expanding the volume.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 3 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerExpandVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeRequest)
    private static final csi.v1.Csi.ControllerExpandVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerExpandVolumeRequest();
    }

    public static csi.v1.Csi.ControllerExpandVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerExpandVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerExpandVolumeRequest>() {
      public ControllerExpandVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerExpandVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerExpandVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerExpandVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerExpandVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerExpandVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.ControllerExpandVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Capacity of volume after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    long getCapacityBytes();

    /**
     * <pre>
     * Whether node expansion is required for the volume. When true
     * the CO MUST make NodeExpandVolume RPC call on the node. This field
     * is REQUIRED.
     * </pre>
     *
     * <code>bool node_expansion_required = 2;</code>
     */
    boolean getNodeExpansionRequired();
  }
  /**
   * Protobuf type {@code csi.v1.ControllerExpandVolumeResponse}
   */
  public  static final class ControllerExpandVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.ControllerExpandVolumeResponse)
      ControllerExpandVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerExpandVolumeResponse.newBuilder() to construct.
    private ControllerExpandVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerExpandVolumeResponse() {
      capacityBytes_ = 0L;
      nodeExpansionRequired_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerExpandVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              capacityBytes_ = input.readInt64();
              break;
            }
            case 16: {

              nodeExpansionRequired_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.ControllerExpandVolumeResponse.class, csi.v1.Csi.ControllerExpandVolumeResponse.Builder.class);
    }

    public static final int CAPACITY_BYTES_FIELD_NUMBER = 1;
    private long capacityBytes_;
    /**
     * <pre>
     * Capacity of volume after expansion. This field is REQUIRED.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    public long getCapacityBytes() {
      return capacityBytes_;
    }

    public static final int NODE_EXPANSION_REQUIRED_FIELD_NUMBER = 2;
    private boolean nodeExpansionRequired_;
    /**
     * <pre>
     * Whether node expansion is required for the volume. When true
     * the CO MUST make NodeExpandVolume RPC call on the node. This field
     * is REQUIRED.
     * </pre>
     *
     * <code>bool node_expansion_required = 2;</code>
     */
    public boolean getNodeExpansionRequired() {
      return nodeExpansionRequired_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (capacityBytes_ != 0L) {
        output.writeInt64(1, capacityBytes_);
      }
      if (nodeExpansionRequired_ != false) {
        output.writeBool(2, nodeExpansionRequired_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (capacityBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, capacityBytes_);
      }
      if (nodeExpansionRequired_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, nodeExpansionRequired_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.ControllerExpandVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.ControllerExpandVolumeResponse other = (csi.v1.Csi.ControllerExpandVolumeResponse) obj;

      boolean result = true;
      result = result && (getCapacityBytes()
          == other.getCapacityBytes());
      result = result && (getNodeExpansionRequired()
          == other.getNodeExpansionRequired());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CAPACITY_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapacityBytes());
      hash = (37 * hash) + NODE_EXPANSION_REQUIRED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getNodeExpansionRequired());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.ControllerExpandVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.ControllerExpandVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.ControllerExpandVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.ControllerExpandVolumeResponse)
        csi.v1.Csi.ControllerExpandVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.ControllerExpandVolumeResponse.class, csi.v1.Csi.ControllerExpandVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.ControllerExpandVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        capacityBytes_ = 0L;

        nodeExpansionRequired_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor;
      }

      public csi.v1.Csi.ControllerExpandVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.ControllerExpandVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.ControllerExpandVolumeResponse build() {
        csi.v1.Csi.ControllerExpandVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.ControllerExpandVolumeResponse buildPartial() {
        csi.v1.Csi.ControllerExpandVolumeResponse result = new csi.v1.Csi.ControllerExpandVolumeResponse(this);
        result.capacityBytes_ = capacityBytes_;
        result.nodeExpansionRequired_ = nodeExpansionRequired_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.ControllerExpandVolumeResponse) {
          return mergeFrom((csi.v1.Csi.ControllerExpandVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.ControllerExpandVolumeResponse other) {
        if (other == csi.v1.Csi.ControllerExpandVolumeResponse.getDefaultInstance()) return this;
        if (other.getCapacityBytes() != 0L) {
          setCapacityBytes(other.getCapacityBytes());
        }
        if (other.getNodeExpansionRequired() != false) {
          setNodeExpansionRequired(other.getNodeExpansionRequired());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.ControllerExpandVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.ControllerExpandVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long capacityBytes_ ;
      /**
       * <pre>
       * Capacity of volume after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public long getCapacityBytes() {
        return capacityBytes_;
      }
      /**
       * <pre>
       * Capacity of volume after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder setCapacityBytes(long value) {
        
        capacityBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Capacity of volume after expansion. This field is REQUIRED.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder clearCapacityBytes() {
        
        capacityBytes_ = 0L;
        onChanged();
        return this;
      }

      private boolean nodeExpansionRequired_ ;
      /**
       * <pre>
       * Whether node expansion is required for the volume. When true
       * the CO MUST make NodeExpandVolume RPC call on the node. This field
       * is REQUIRED.
       * </pre>
       *
       * <code>bool node_expansion_required = 2;</code>
       */
      public boolean getNodeExpansionRequired() {
        return nodeExpansionRequired_;
      }
      /**
       * <pre>
       * Whether node expansion is required for the volume. When true
       * the CO MUST make NodeExpandVolume RPC call on the node. This field
       * is REQUIRED.
       * </pre>
       *
       * <code>bool node_expansion_required = 2;</code>
       */
      public Builder setNodeExpansionRequired(boolean value) {
        
        nodeExpansionRequired_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether node expansion is required for the volume. When true
       * the CO MUST make NodeExpandVolume RPC call on the node. This field
       * is REQUIRED.
       * </pre>
       *
       * <code>bool node_expansion_required = 2;</code>
       */
      public Builder clearNodeExpansionRequired() {
        
        nodeExpansionRequired_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.ControllerExpandVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeResponse)
    private static final csi.v1.Csi.ControllerExpandVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.ControllerExpandVolumeResponse();
    }

    public static csi.v1.Csi.ControllerExpandVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerExpandVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerExpandVolumeResponse>() {
      public ControllerExpandVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerExpandVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerExpandVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerExpandVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.ControllerExpandVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeStageVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeStageVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    int getPublishContextCount();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    boolean containsPublishContext(
        java.lang.String key);
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContext();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContextMap();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    java.lang.String getPublishContextOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The path to which the volume MAY be staged. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request, and MUST be a directory. The CO SHALL ensure that there
     * is only one `staging_target_path` per volume. The CO SHALL ensure
     * that the path is directory and that the process serving the
     * request has `read` and `write` permission to that directory. The
     * CO SHALL be responsible for creating the directory if it does not
     * exist.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path to which the volume MAY be staged. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request, and MUST be a directory. The CO SHALL ensure that there
     * is only one `staging_target_path` per volume. The CO SHALL ensure
     * that the path is directory and that the process serving the
     * request has `read` and `write` permission to that directory. The
     * CO SHALL be responsible for creating the directory if it does not
     * exist.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();

    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    int getVolumeContextCount();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    boolean containsVolumeContext(
        java.lang.String key);
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContext();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContextMap();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    java.lang.String getVolumeContextOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.NodeStageVolumeRequest}
   */
  public  static final class NodeStageVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeStageVolumeRequest)
      NodeStageVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeStageVolumeRequest.newBuilder() to construct.
    private NodeStageVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeStageVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeStageVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                publishContext_ = com.google.protobuf.MapField.newMapField(
                    PublishContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishContext__ = input.readMessage(
                  PublishContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishContext_.getMutableMap().put(
                  publishContext__.getKey(), publishContext__.getValue());
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
            case 34: {
              csi.v1.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                volumeContext_ = com.google.protobuf.MapField.newMapField(
                    VolumeContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000020;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeContext__ = input.readMessage(
                  VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeContext_.getMutableMap().put(
                  volumeContext__.getKey(), volumeContext__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetPublishContext();
        case 5:
          return internalGetSecrets();
        case 6:
          return internalGetVolumeContext();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeStageVolumeRequest.class, csi.v1.Csi.NodeStageVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PUBLISH_CONTEXT_FIELD_NUMBER = 2;
    private static final class PublishContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishContext() {
      if (publishContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishContextDefaultEntryHolder.defaultEntry);
      }
      return publishContext_;
    }

    public int getPublishContextCount() {
      return internalGetPublishContext().getMap().size();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public boolean containsPublishContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
      return getPublishContextMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
      return internalGetPublishContext().getMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.lang.String getPublishContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path to which the volume MAY be staged. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request, and MUST be a directory. The CO SHALL ensure that there
     * is only one `staging_target_path` per volume. The CO SHALL ensure
     * that the path is directory and that the process serving the
     * request has `read` and `write` permission to that directory. The
     * CO SHALL be responsible for creating the directory if it does not
     * exist.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the volume MAY be staged. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request, and MUST be a directory. The CO SHALL ensure that there
     * is only one `staging_target_path` per volume. The CO SHALL ensure
     * that the path is directory and that the process serving the
     * request has `read` and `write` permission to that directory. The
     * CO SHALL be responsible for creating the directory if it does not
     * exist.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 4;
    private csi.v1.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the staged volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int SECRETS_FIELD_NUMBER = 5;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CONTEXT_FIELD_NUMBER = 6;
    private static final class VolumeContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeContext() {
      if (volumeContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeContextDefaultEntryHolder.defaultEntry);
      }
      return volumeContext_;
    }

    public int getVolumeContextCount() {
      return internalGetVolumeContext().getMap().size();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public boolean containsVolumeContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
      return getVolumeContextMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
      return internalGetVolumeContext().getMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 6;</code>
     */

    public java.lang.String getVolumeContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishContext(),
          PublishContextDefaultEntryHolder.defaultEntry,
          2);
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stagingTargetPath_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(4, getVolumeCapability());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          5);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeContext(),
          VolumeContextDefaultEntryHolder.defaultEntry,
          6);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishContext__ = PublishContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, publishContext__);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stagingTargetPath_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getVolumeCapability());
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, secrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, volumeContext__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeStageVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeStageVolumeRequest other = (csi.v1.Csi.NodeStageVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetPublishContext().equals(
          other.internalGetPublishContext());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && internalGetVolumeContext().equals(
          other.internalGetVolumeContext());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetPublishContext().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishContext().hashCode();
      }
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      if (!internalGetVolumeContext().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeContext().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeStageVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeStageVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeStageVolumeRequest)
        csi.v1.Csi.NodeStageVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetPublishContext();
          case 5:
            return internalGetSecrets();
          case 6:
            return internalGetVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutablePublishContext();
          case 5:
            return internalGetMutableSecrets();
          case 6:
            return internalGetMutableVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeStageVolumeRequest.class, csi.v1.Csi.NodeStageVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeStageVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutablePublishContext().clear();
        stagingTargetPath_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        internalGetMutableSecrets().clear();
        internalGetMutableVolumeContext().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeRequest_descriptor;
      }

      public csi.v1.Csi.NodeStageVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeStageVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeStageVolumeRequest build() {
        csi.v1.Csi.NodeStageVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeStageVolumeRequest buildPartial() {
        csi.v1.Csi.NodeStageVolumeRequest result = new csi.v1.Csi.NodeStageVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.publishContext_ = internalGetPublishContext();
        result.publishContext_.makeImmutable();
        result.stagingTargetPath_ = stagingTargetPath_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.volumeContext_ = internalGetVolumeContext();
        result.volumeContext_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeStageVolumeRequest) {
          return mergeFrom((csi.v1.Csi.NodeStageVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeStageVolumeRequest other) {
        if (other == csi.v1.Csi.NodeStageVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutablePublishContext().mergeFrom(
            other.internalGetPublishContext());
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        internalGetMutableVolumeContext().mergeFrom(
            other.internalGetVolumeContext());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeStageVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeStageVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishContext() {
        if (publishContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        return publishContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishContext() {
        onChanged();;
        if (publishContext_ == null) {
          publishContext_ = com.google.protobuf.MapField.newMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        if (!publishContext_.isMutable()) {
          publishContext_ = publishContext_.copy();
        }
        return publishContext_;
      }

      public int getPublishContextCount() {
        return internalGetPublishContext().getMap().size();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public boolean containsPublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
        return getPublishContextMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
        return internalGetPublishContext().getMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.lang.String getPublishContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.lang.String getPublishContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishContext() {
        internalGetMutablePublishContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public Builder removePublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishContext() {
        return internalGetMutablePublishContext().getMutableMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */
      public Builder putPublishContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public Builder putAllPublishContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishContext().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path to which the volume MAY be staged. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request, and MUST be a directory. The CO SHALL ensure that there
       * is only one `staging_target_path` per volume. The CO SHALL ensure
       * that the path is directory and that the process serving the
       * request has `read` and `write` permission to that directory. The
       * CO SHALL be responsible for creating the directory if it does not
       * exist.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume MAY be staged. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request, and MUST be a directory. The CO SHALL ensure that there
       * is only one `staging_target_path` per volume. The CO SHALL ensure
       * that the path is directory and that the process serving the
       * request has `read` and `write` permission to that directory. The
       * CO SHALL be responsible for creating the directory if it does not
       * exist.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume MAY be staged. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request, and MUST be a directory. The CO SHALL ensure that there
       * is only one `staging_target_path` per volume. The CO SHALL ensure
       * that the path is directory and that the process serving the
       * request has `read` and `write` permission to that directory. The
       * CO SHALL be responsible for creating the directory if it does not
       * exist.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume MAY be staged. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request, and MUST be a directory. The CO SHALL ensure that there
       * is only one `staging_target_path` per volume. The CO SHALL ensure
       * that the path is directory and that the process serving the
       * request has `read` and `write` permission to that directory. The
       * CO SHALL be responsible for creating the directory if it does not
       * exist.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume MAY be staged. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request, and MUST be a directory. The CO SHALL ensure that there
       * is only one `staging_target_path` per volume. The CO SHALL ensure
       * that the path is directory and that the process serving the
       * request has `read` and `write` permission to that directory. The
       * CO SHALL be responsible for creating the directory if it does not
       * exist.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public Builder setVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public Builder setVolumeCapability(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public Builder mergeVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v1.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the staged volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 5 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeContext() {
        onChanged();;
        if (volumeContext_ == null) {
          volumeContext_ = com.google.protobuf.MapField.newMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        if (!volumeContext_.isMutable()) {
          volumeContext_ = volumeContext_.copy();
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeContext() {
        internalGetMutableVolumeContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public Builder removeVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeContext() {
        return internalGetMutableVolumeContext().getMutableMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */
      public Builder putVolumeContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 6;</code>
       */

      public Builder putAllVolumeContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeContext().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeStageVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeRequest)
    private static final csi.v1.Csi.NodeStageVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeStageVolumeRequest();
    }

    public static csi.v1.Csi.NodeStageVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeStageVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeStageVolumeRequest>() {
      public NodeStageVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeStageVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeStageVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeStageVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeStageVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeStageVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeStageVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodeStageVolumeResponse}
   */
  public  static final class NodeStageVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeStageVolumeResponse)
      NodeStageVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeStageVolumeResponse.newBuilder() to construct.
    private NodeStageVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeStageVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeStageVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeStageVolumeResponse.class, csi.v1.Csi.NodeStageVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeStageVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeStageVolumeResponse other = (csi.v1.Csi.NodeStageVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeStageVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodeStageVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeStageVolumeResponse)
        csi.v1.Csi.NodeStageVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeStageVolumeResponse.class, csi.v1.Csi.NodeStageVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeStageVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeStageVolumeResponse_descriptor;
      }

      public csi.v1.Csi.NodeStageVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeStageVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeStageVolumeResponse build() {
        csi.v1.Csi.NodeStageVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeStageVolumeResponse buildPartial() {
        csi.v1.Csi.NodeStageVolumeResponse result = new csi.v1.Csi.NodeStageVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeStageVolumeResponse) {
          return mergeFrom((csi.v1.Csi.NodeStageVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeStageVolumeResponse other) {
        if (other == csi.v1.Csi.NodeStageVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeStageVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeStageVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeStageVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeResponse)
    private static final csi.v1.Csi.NodeStageVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeStageVolumeResponse();
    }

    public static csi.v1.Csi.NodeStageVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeStageVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeStageVolumeResponse>() {
      public NodeStageVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeStageVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeStageVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeStageVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeStageVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnstageVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeUnstageVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The path at which the volume was staged. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path at which the volume was staged. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();
  }
  /**
   * Protobuf type {@code csi.v1.NodeUnstageVolumeRequest}
   */
  public  static final class NodeUnstageVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeUnstageVolumeRequest)
      NodeUnstageVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnstageVolumeRequest.newBuilder() to construct.
    private NodeUnstageVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnstageVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnstageVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeUnstageVolumeRequest.class, csi.v1.Csi.NodeUnstageVolumeRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path at which the volume was staged. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path at which the volume was staged. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, stagingTargetPath_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, stagingTargetPath_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeUnstageVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeUnstageVolumeRequest other = (csi.v1.Csi.NodeUnstageVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeUnstageVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeUnstageVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeUnstageVolumeRequest)
        csi.v1.Csi.NodeUnstageVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeUnstageVolumeRequest.class, csi.v1.Csi.NodeUnstageVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeUnstageVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        stagingTargetPath_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor;
      }

      public csi.v1.Csi.NodeUnstageVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeUnstageVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeUnstageVolumeRequest build() {
        csi.v1.Csi.NodeUnstageVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeUnstageVolumeRequest buildPartial() {
        csi.v1.Csi.NodeUnstageVolumeRequest result = new csi.v1.Csi.NodeUnstageVolumeRequest(this);
        result.volumeId_ = volumeId_;
        result.stagingTargetPath_ = stagingTargetPath_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeUnstageVolumeRequest) {
          return mergeFrom((csi.v1.Csi.NodeUnstageVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeUnstageVolumeRequest other) {
        if (other == csi.v1.Csi.NodeUnstageVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeUnstageVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeUnstageVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path at which the volume was staged. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was staged. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was staged. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was staged. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was staged. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeUnstageVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeRequest)
    private static final csi.v1.Csi.NodeUnstageVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeUnstageVolumeRequest();
    }

    public static csi.v1.Csi.NodeUnstageVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnstageVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnstageVolumeRequest>() {
      public NodeUnstageVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnstageVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnstageVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnstageVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeUnstageVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnstageVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeUnstageVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodeUnstageVolumeResponse}
   */
  public  static final class NodeUnstageVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeUnstageVolumeResponse)
      NodeUnstageVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnstageVolumeResponse.newBuilder() to construct.
    private NodeUnstageVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnstageVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnstageVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeUnstageVolumeResponse.class, csi.v1.Csi.NodeUnstageVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeUnstageVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeUnstageVolumeResponse other = (csi.v1.Csi.NodeUnstageVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeUnstageVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodeUnstageVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeUnstageVolumeResponse)
        csi.v1.Csi.NodeUnstageVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeUnstageVolumeResponse.class, csi.v1.Csi.NodeUnstageVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeUnstageVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor;
      }

      public csi.v1.Csi.NodeUnstageVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeUnstageVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeUnstageVolumeResponse build() {
        csi.v1.Csi.NodeUnstageVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeUnstageVolumeResponse buildPartial() {
        csi.v1.Csi.NodeUnstageVolumeResponse result = new csi.v1.Csi.NodeUnstageVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeUnstageVolumeResponse) {
          return mergeFrom((csi.v1.Csi.NodeUnstageVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeUnstageVolumeResponse other) {
        if (other == csi.v1.Csi.NodeUnstageVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeUnstageVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeUnstageVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeUnstageVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeResponse)
    private static final csi.v1.Csi.NodeUnstageVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeUnstageVolumeResponse();
    }

    public static csi.v1.Csi.NodeUnstageVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnstageVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnstageVolumeResponse>() {
      public NodeUnstageVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnstageVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnstageVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnstageVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeUnstageVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodePublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodePublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    int getPublishContextCount();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    boolean containsPublishContext(
        java.lang.String key);
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContext();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishContextMap();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    java.lang.String getPublishContextOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The path to which the volume was staged by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path to which the volume was staged by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();

    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the parent directory of this path exists
     * and that the process serving the request has `read` and `write`
     * permissions to that parent directory.
     * For volumes with an access type of block, the SP SHALL place the
     * block device at target_path.
     * For volumes with an access type of mount, the SP SHALL place the
     * mounted directory at target_path.
     * Creation of target_path is the responsibility of the SP.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    java.lang.String getTargetPath();
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the parent directory of this path exists
     * and that the process serving the request has `read` and `write`
     * permissions to that parent directory.
     * For volumes with an access type of block, the SP SHALL place the
     * block device at target_path.
     * For volumes with an access type of mount, the SP SHALL place the
     * mounted directory at target_path.
     * Creation of target_path is the responsibility of the SP.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    com.google.protobuf.ByteString
        getTargetPathBytes();

    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    csi.v1.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Indicates SP MUST publish the volume in readonly mode.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 6;</code>
     */
    boolean getReadonly();

    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */
    int getSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */
    boolean containsSecrets(
        java.lang.String key);
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    java.lang.String getSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */
    int getVolumeContextCount();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */
    boolean containsVolumeContext(
        java.lang.String key);
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContext();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeContextMap();
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    java.lang.String getVolumeContextOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v1.NodePublishVolumeRequest}
   */
  public  static final class NodePublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodePublishVolumeRequest)
      NodePublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodePublishVolumeRequest.newBuilder() to construct.
    private NodePublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodePublishVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
      targetPath_ = "";
      readonly_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodePublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                publishContext_ = com.google.protobuf.MapField.newMapField(
                    PublishContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishContext__ = input.readMessage(
                  PublishContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishContext_.getMutableMap().put(
                  publishContext__.getKey(), publishContext__.getValue());
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              targetPath_ = s;
              break;
            }
            case 42: {
              csi.v1.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v1.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 48: {

              readonly_ = input.readBool();
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                secrets_ = com.google.protobuf.MapField.newMapField(
                    SecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000040;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              secrets__ = input.readMessage(
                  SecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              secrets_.getMutableMap().put(
                  secrets__.getKey(), secrets__.getValue());
              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                volumeContext_ = com.google.protobuf.MapField.newMapField(
                    VolumeContextDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000080;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeContext__ = input.readMessage(
                  VolumeContextDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeContext_.getMutableMap().put(
                  volumeContext__.getKey(), volumeContext__.getValue());
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetPublishContext();
        case 7:
          return internalGetSecrets();
        case 8:
          return internalGetVolumeContext();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodePublishVolumeRequest.class, csi.v1.Csi.NodePublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PUBLISH_CONTEXT_FIELD_NUMBER = 2;
    private static final class PublishContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishContext() {
      if (publishContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishContextDefaultEntryHolder.defaultEntry);
      }
      return publishContext_;
    }

    public int getPublishContextCount() {
      return internalGetPublishContext().getMap().size();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public boolean containsPublishContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
      return getPublishContextMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
      return internalGetPublishContext().getMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.lang.String getPublishContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_context = 2;</code>
     */

    public java.lang.String getPublishContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path to which the volume was staged by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the volume was staged by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TARGET_PATH_FIELD_NUMBER = 4;
    private volatile java.lang.Object targetPath_;
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the parent directory of this path exists
     * and that the process serving the request has `read` and `write`
     * permissions to that parent directory.
     * For volumes with an access type of block, the SP SHALL place the
     * block device at target_path.
     * For volumes with an access type of mount, the SP SHALL place the
     * mounted directory at target_path.
     * Creation of target_path is the responsibility of the SP.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    public java.lang.String getTargetPath() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        targetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the parent directory of this path exists
     * and that the process serving the request has `read` and `write`
     * permissions to that parent directory.
     * For volumes with an access type of block, the SP SHALL place the
     * block device at target_path.
     * For volumes with an access type of mount, the SP SHALL place the
     * mounted directory at target_path.
     * Creation of target_path is the responsibility of the SP.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    public com.google.protobuf.ByteString
        getTargetPathBytes() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        targetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 5;
    private csi.v1.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    public csi.v1.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * Volume capability describing how the CO intends to use this volume.
     * SP MUST ensure the CO can use the published volume as described.
     * Otherwise SP MUST return the appropriate gRPC error code.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
     */
    public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int READONLY_FIELD_NUMBER = 6;
    private boolean readonly_;
    /**
     * <pre>
     * Indicates SP MUST publish the volume in readonly mode.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 6;</code>
     */
    public boolean getReadonly() {
      return readonly_;
    }

    public static final int SECRETS_FIELD_NUMBER = 7;
    private static final class SecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> secrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSecrets() {
      if (secrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SecretsDefaultEntryHolder.defaultEntry);
      }
      return secrets_;
    }

    public int getSecretsCount() {
      return internalGetSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    public boolean containsSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
      return getSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
      return internalGetSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
     */

    public java.lang.String getSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CONTEXT_FIELD_NUMBER = 8;
    private static final class VolumeContextDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeContext_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeContext() {
      if (volumeContext_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeContextDefaultEntryHolder.defaultEntry);
      }
      return volumeContext_;
    }

    public int getVolumeContextCount() {
      return internalGetVolumeContext().getMap().size();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    public boolean containsVolumeContext(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeContext().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeContextMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
      return getVolumeContextMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
      return internalGetVolumeContext().getMap();
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    public java.lang.String getVolumeContextOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Volume context as returned by CO in CreateVolumeRequest. This field
     * is OPTIONAL and MUST match the volume_context of the volume
     * identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_context = 8;</code>
     */

    public java.lang.String getVolumeContextOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeContext().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishContext(),
          PublishContextDefaultEntryHolder.defaultEntry,
          2);
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stagingTargetPath_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, targetPath_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(5, getVolumeCapability());
      }
      if (readonly_ != false) {
        output.writeBool(6, readonly_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSecrets(),
          SecretsDefaultEntryHolder.defaultEntry,
          7);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeContext(),
          VolumeContextDefaultEntryHolder.defaultEntry,
          8);
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishContext__ = PublishContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, publishContext__);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stagingTargetPath_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, targetPath_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getVolumeCapability());
      }
      if (readonly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, readonly_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        secrets__ = SecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(7, secrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeContext().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeContext__ = VolumeContextDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(8, volumeContext__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodePublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodePublishVolumeRequest other = (csi.v1.Csi.NodePublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetPublishContext().equals(
          other.internalGetPublishContext());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && getTargetPath()
          .equals(other.getTargetPath());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && (getReadonly()
          == other.getReadonly());
      result = result && internalGetSecrets().equals(
          other.internalGetSecrets());
      result = result && internalGetVolumeContext().equals(
          other.internalGetVolumeContext());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetPublishContext().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishContext().hashCode();
      }
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      hash = (37 * hash) + TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTargetPath().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      hash = (37 * hash) + READONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReadonly());
      if (!internalGetSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSecrets().hashCode();
      }
      if (!internalGetVolumeContext().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeContext().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodePublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodePublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodePublishVolumeRequest)
        csi.v1.Csi.NodePublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetPublishContext();
          case 7:
            return internalGetSecrets();
          case 8:
            return internalGetVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutablePublishContext();
          case 7:
            return internalGetMutableSecrets();
          case 8:
            return internalGetMutableVolumeContext();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodePublishVolumeRequest.class, csi.v1.Csi.NodePublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodePublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutablePublishContext().clear();
        stagingTargetPath_ = "";

        targetPath_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        readonly_ = false;

        internalGetMutableSecrets().clear();
        internalGetMutableVolumeContext().clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeRequest_descriptor;
      }

      public csi.v1.Csi.NodePublishVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodePublishVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodePublishVolumeRequest build() {
        csi.v1.Csi.NodePublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodePublishVolumeRequest buildPartial() {
        csi.v1.Csi.NodePublishVolumeRequest result = new csi.v1.Csi.NodePublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.publishContext_ = internalGetPublishContext();
        result.publishContext_.makeImmutable();
        result.stagingTargetPath_ = stagingTargetPath_;
        result.targetPath_ = targetPath_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.readonly_ = readonly_;
        result.secrets_ = internalGetSecrets();
        result.secrets_.makeImmutable();
        result.volumeContext_ = internalGetVolumeContext();
        result.volumeContext_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodePublishVolumeRequest) {
          return mergeFrom((csi.v1.Csi.NodePublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodePublishVolumeRequest other) {
        if (other == csi.v1.Csi.NodePublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutablePublishContext().mergeFrom(
            other.internalGetPublishContext());
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        if (!other.getTargetPath().isEmpty()) {
          targetPath_ = other.targetPath_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        if (other.getReadonly() != false) {
          setReadonly(other.getReadonly());
        }
        internalGetMutableSecrets().mergeFrom(
            other.internalGetSecrets());
        internalGetMutableVolumeContext().mergeFrom(
            other.internalGetVolumeContext());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodePublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodePublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishContext() {
        if (publishContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        return publishContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishContext() {
        onChanged();;
        if (publishContext_ == null) {
          publishContext_ = com.google.protobuf.MapField.newMapField(
              PublishContextDefaultEntryHolder.defaultEntry);
        }
        if (!publishContext_.isMutable()) {
          publishContext_ = publishContext_.copy();
        }
        return publishContext_;
      }

      public int getPublishContextCount() {
        return internalGetPublishContext().getMap().size();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public boolean containsPublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishContext() {
        return getPublishContextMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishContextMap() {
        return internalGetPublishContext().getMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.lang.String getPublishContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public java.lang.String getPublishContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishContext() {
        internalGetMutablePublishContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public Builder removePublishContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishContext() {
        return internalGetMutablePublishContext().getMutableMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */
      public Builder putPublishContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_context = 2;</code>
       */

      public Builder putAllPublishContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishContext().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path to which the volume was staged by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume was staged by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume was staged by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume was staged by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume was staged by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object targetPath_ = "";
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the parent directory of this path exists
       * and that the process serving the request has `read` and `write`
       * permissions to that parent directory.
       * For volumes with an access type of block, the SP SHALL place the
       * block device at target_path.
       * For volumes with an access type of mount, the SP SHALL place the
       * mounted directory at target_path.
       * Creation of target_path is the responsibility of the SP.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public java.lang.String getTargetPath() {
        java.lang.Object ref = targetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          targetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the parent directory of this path exists
       * and that the process serving the request has `read` and `write`
       * permissions to that parent directory.
       * For volumes with an access type of block, the SP SHALL place the
       * block device at target_path.
       * For volumes with an access type of mount, the SP SHALL place the
       * mounted directory at target_path.
       * Creation of target_path is the responsibility of the SP.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public com.google.protobuf.ByteString
          getTargetPathBytes() {
        java.lang.Object ref = targetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          targetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the parent directory of this path exists
       * and that the process serving the request has `read` and `write`
       * permissions to that parent directory.
       * For volumes with an access type of block, the SP SHALL place the
       * block device at target_path.
       * For volumes with an access type of mount, the SP SHALL place the
       * mounted directory at target_path.
       * Creation of target_path is the responsibility of the SP.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder setTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        targetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the parent directory of this path exists
       * and that the process serving the request has `read` and `write`
       * permissions to that parent directory.
       * For volumes with an access type of block, the SP SHALL place the
       * block device at target_path.
       * For volumes with an access type of mount, the SP SHALL place the
       * mounted directory at target_path.
       * Creation of target_path is the responsibility of the SP.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder clearTargetPath() {
        
        targetPath_ = getDefaultInstance().getTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the parent directory of this path exists
       * and that the process serving the request has `read` and `write`
       * permissions to that parent directory.
       * For volumes with an access type of block, the SP SHALL place the
       * block device at target_path.
       * For volumes with an access type of mount, the SP SHALL place the
       * mounted directory at target_path.
       * Creation of target_path is the responsibility of the SP.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder setTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        targetPath_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v1.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public Builder setVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public Builder setVolumeCapability(
          csi.v1.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public Builder mergeVolumeCapability(csi.v1.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v1.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v1.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v1.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v1.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * Volume capability describing how the CO intends to use this volume.
       * SP MUST ensure the CO can use the published volume as described.
       * Otherwise SP MUST return the appropriate gRPC error code.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v1.VolumeCapability volume_capability = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.VolumeCapability, csi.v1.Csi.VolumeCapability.Builder, csi.v1.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private boolean readonly_ ;
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public boolean getReadonly() {
        return readonly_;
      }
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public Builder setReadonly(boolean value) {
        
        readonly_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates SP MUST publish the volume in readonly mode.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public Builder clearReadonly() {
        
        readonly_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> secrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSecrets() {
        if (secrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        return secrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSecrets() {
        onChanged();;
        if (secrets_ == null) {
          secrets_ = com.google.protobuf.MapField.newMapField(
              SecretsDefaultEntryHolder.defaultEntry);
        }
        if (!secrets_.isMutable()) {
          secrets_ = secrets_.copy();
        }
        return secrets_;
      }

      public int getSecretsCount() {
        return internalGetSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public boolean containsSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSecrets() {
        return getSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSecretsMap() {
        return internalGetSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public java.lang.String getSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSecrets() {
        internalGetMutableSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder removeSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSecrets() {
        return internalGetMutableSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */
      public Builder putSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; secrets = 7 [(.csi.v1.csi_secret) = true];</code>
       */

      public Builder putAllSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeContext_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeContext() {
        if (volumeContext_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        return volumeContext_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeContext() {
        onChanged();;
        if (volumeContext_ == null) {
          volumeContext_ = com.google.protobuf.MapField.newMapField(
              VolumeContextDefaultEntryHolder.defaultEntry);
        }
        if (!volumeContext_.isMutable()) {
          volumeContext_ = volumeContext_.copy();
        }
        return volumeContext_;
      }

      public int getVolumeContextCount() {
        return internalGetVolumeContext().getMap().size();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public boolean containsVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeContext().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeContextMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeContext() {
        return getVolumeContextMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeContextMap() {
        return internalGetVolumeContext().getMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public java.lang.String getVolumeContextOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public java.lang.String getVolumeContextOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeContext().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeContext() {
        internalGetMutableVolumeContext().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public Builder removeVolumeContext(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeContext() {
        return internalGetMutableVolumeContext().getMutableMap();
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */
      public Builder putVolumeContext(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeContext().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Volume context as returned by CO in CreateVolumeRequest. This field
       * is OPTIONAL and MUST match the volume_context of the volume
       * identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_context = 8;</code>
       */

      public Builder putAllVolumeContext(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeContext().getMutableMap()
            .putAll(values);
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodePublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeRequest)
    private static final csi.v1.Csi.NodePublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodePublishVolumeRequest();
    }

    public static csi.v1.Csi.NodePublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodePublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodePublishVolumeRequest>() {
      public NodePublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodePublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodePublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodePublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodePublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodePublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodePublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodePublishVolumeResponse}
   */
  public  static final class NodePublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodePublishVolumeResponse)
      NodePublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodePublishVolumeResponse.newBuilder() to construct.
    private NodePublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodePublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodePublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodePublishVolumeResponse.class, csi.v1.Csi.NodePublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodePublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodePublishVolumeResponse other = (csi.v1.Csi.NodePublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodePublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodePublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodePublishVolumeResponse)
        csi.v1.Csi.NodePublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodePublishVolumeResponse.class, csi.v1.Csi.NodePublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodePublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodePublishVolumeResponse_descriptor;
      }

      public csi.v1.Csi.NodePublishVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodePublishVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodePublishVolumeResponse build() {
        csi.v1.Csi.NodePublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodePublishVolumeResponse buildPartial() {
        csi.v1.Csi.NodePublishVolumeResponse result = new csi.v1.Csi.NodePublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodePublishVolumeResponse) {
          return mergeFrom((csi.v1.Csi.NodePublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodePublishVolumeResponse other) {
        if (other == csi.v1.Csi.NodePublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodePublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodePublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodePublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeResponse)
    private static final csi.v1.Csi.NodePublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodePublishVolumeResponse();
    }

    public static csi.v1.Csi.NodePublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodePublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodePublishVolumeResponse>() {
      public NodePublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodePublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodePublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodePublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodePublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnpublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeUnpublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * The SP MUST delete the file or directory it created at this path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    java.lang.String getTargetPath();
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * The SP MUST delete the file or directory it created at this path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getTargetPathBytes();
  }
  /**
   * Protobuf type {@code csi.v1.NodeUnpublishVolumeRequest}
   */
  public  static final class NodeUnpublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeUnpublishVolumeRequest)
      NodeUnpublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnpublishVolumeRequest.newBuilder() to construct.
    private NodeUnpublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnpublishVolumeRequest() {
      volumeId_ = "";
      targetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnpublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              targetPath_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeUnpublishVolumeRequest.class, csi.v1.Csi.NodeUnpublishVolumeRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TARGET_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object targetPath_;
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * The SP MUST delete the file or directory it created at this path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    public java.lang.String getTargetPath() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        targetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * The SP MUST delete the file or directory it created at this path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTargetPathBytes() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        targetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, targetPath_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, targetPath_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeUnpublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeUnpublishVolumeRequest other = (csi.v1.Csi.NodeUnpublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getTargetPath()
          .equals(other.getTargetPath());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTargetPath().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeUnpublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeUnpublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeUnpublishVolumeRequest)
        csi.v1.Csi.NodeUnpublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeUnpublishVolumeRequest.class, csi.v1.Csi.NodeUnpublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeUnpublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        targetPath_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor;
      }

      public csi.v1.Csi.NodeUnpublishVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeUnpublishVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeUnpublishVolumeRequest build() {
        csi.v1.Csi.NodeUnpublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeUnpublishVolumeRequest buildPartial() {
        csi.v1.Csi.NodeUnpublishVolumeRequest result = new csi.v1.Csi.NodeUnpublishVolumeRequest(this);
        result.volumeId_ = volumeId_;
        result.targetPath_ = targetPath_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeUnpublishVolumeRequest) {
          return mergeFrom((csi.v1.Csi.NodeUnpublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeUnpublishVolumeRequest other) {
        if (other == csi.v1.Csi.NodeUnpublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getTargetPath().isEmpty()) {
          targetPath_ = other.targetPath_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeUnpublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeUnpublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object targetPath_ = "";
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * The SP MUST delete the file or directory it created at this path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public java.lang.String getTargetPath() {
        java.lang.Object ref = targetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          targetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * The SP MUST delete the file or directory it created at this path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getTargetPathBytes() {
        java.lang.Object ref = targetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          targetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * The SP MUST delete the file or directory it created at this path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder setTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        targetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * The SP MUST delete the file or directory it created at this path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder clearTargetPath() {
        
        targetPath_ = getDefaultInstance().getTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * The SP MUST delete the file or directory it created at this path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder setTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        targetPath_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeUnpublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeRequest)
    private static final csi.v1.Csi.NodeUnpublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeUnpublishVolumeRequest();
    }

    public static csi.v1.Csi.NodeUnpublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnpublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnpublishVolumeRequest>() {
      public NodeUnpublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnpublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnpublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnpublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeUnpublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnpublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeUnpublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodeUnpublishVolumeResponse}
   */
  public  static final class NodeUnpublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeUnpublishVolumeResponse)
      NodeUnpublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnpublishVolumeResponse.newBuilder() to construct.
    private NodeUnpublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnpublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnpublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeUnpublishVolumeResponse.class, csi.v1.Csi.NodeUnpublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeUnpublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeUnpublishVolumeResponse other = (csi.v1.Csi.NodeUnpublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeUnpublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodeUnpublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeUnpublishVolumeResponse)
        csi.v1.Csi.NodeUnpublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeUnpublishVolumeResponse.class, csi.v1.Csi.NodeUnpublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeUnpublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor;
      }

      public csi.v1.Csi.NodeUnpublishVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeUnpublishVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeUnpublishVolumeResponse build() {
        csi.v1.Csi.NodeUnpublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeUnpublishVolumeResponse buildPartial() {
        csi.v1.Csi.NodeUnpublishVolumeResponse result = new csi.v1.Csi.NodeUnpublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeUnpublishVolumeResponse) {
          return mergeFrom((csi.v1.Csi.NodeUnpublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeUnpublishVolumeResponse other) {
        if (other == csi.v1.Csi.NodeUnpublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeUnpublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeUnpublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeUnpublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeResponse)
    private static final csi.v1.Csi.NodeUnpublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeUnpublishVolumeResponse();
    }

    public static csi.v1.Csi.NodeUnpublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnpublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnpublishVolumeResponse>() {
      public NodeUnpublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnpublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnpublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnpublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeUnpublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetVolumeStatsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetVolumeStatsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * It can be any valid path where volume was previously
     * staged or published.
     * It MUST be an absolute path in the root filesystem of
     * the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    java.lang.String getVolumePath();
    /**
     * <pre>
     * It can be any valid path where volume was previously
     * staged or published.
     * It MUST be an absolute path in the root filesystem of
     * the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getVolumePathBytes();
  }
  /**
   * Protobuf type {@code csi.v1.NodeGetVolumeStatsRequest}
   */
  public  static final class NodeGetVolumeStatsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetVolumeStatsRequest)
      NodeGetVolumeStatsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetVolumeStatsRequest.newBuilder() to construct.
    private NodeGetVolumeStatsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetVolumeStatsRequest() {
      volumeId_ = "";
      volumePath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetVolumeStatsRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              volumePath_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetVolumeStatsRequest.class, csi.v1.Csi.NodeGetVolumeStatsRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object volumePath_;
    /**
     * <pre>
     * It can be any valid path where volume was previously
     * staged or published.
     * It MUST be an absolute path in the root filesystem of
     * the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    public java.lang.String getVolumePath() {
      java.lang.Object ref = volumePath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumePath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * It can be any valid path where volume was previously
     * staged or published.
     * It MUST be an absolute path in the root filesystem of
     * the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVolumePathBytes() {
      java.lang.Object ref = volumePath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumePath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getVolumePathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, volumePath_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getVolumePathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, volumePath_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetVolumeStatsRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetVolumeStatsRequest other = (csi.v1.Csi.NodeGetVolumeStatsRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getVolumePath()
          .equals(other.getVolumePath());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + VOLUME_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getVolumePath().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetVolumeStatsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeGetVolumeStatsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetVolumeStatsRequest)
        csi.v1.Csi.NodeGetVolumeStatsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetVolumeStatsRequest.class, csi.v1.Csi.NodeGetVolumeStatsRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetVolumeStatsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        volumePath_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor;
      }

      public csi.v1.Csi.NodeGetVolumeStatsRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetVolumeStatsRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetVolumeStatsRequest build() {
        csi.v1.Csi.NodeGetVolumeStatsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetVolumeStatsRequest buildPartial() {
        csi.v1.Csi.NodeGetVolumeStatsRequest result = new csi.v1.Csi.NodeGetVolumeStatsRequest(this);
        result.volumeId_ = volumeId_;
        result.volumePath_ = volumePath_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetVolumeStatsRequest) {
          return mergeFrom((csi.v1.Csi.NodeGetVolumeStatsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetVolumeStatsRequest other) {
        if (other == csi.v1.Csi.NodeGetVolumeStatsRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getVolumePath().isEmpty()) {
          volumePath_ = other.volumePath_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetVolumeStatsRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetVolumeStatsRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object volumePath_ = "";
      /**
       * <pre>
       * It can be any valid path where volume was previously
       * staged or published.
       * It MUST be an absolute path in the root filesystem of
       * the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public java.lang.String getVolumePath() {
        java.lang.Object ref = volumePath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumePath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * It can be any valid path where volume was previously
       * staged or published.
       * It MUST be an absolute path in the root filesystem of
       * the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getVolumePathBytes() {
        java.lang.Object ref = volumePath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumePath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * It can be any valid path where volume was previously
       * staged or published.
       * It MUST be an absolute path in the root filesystem of
       * the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder setVolumePath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumePath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * It can be any valid path where volume was previously
       * staged or published.
       * It MUST be an absolute path in the root filesystem of
       * the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder clearVolumePath() {
        
        volumePath_ = getDefaultInstance().getVolumePath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * It can be any valid path where volume was previously
       * staged or published.
       * It MUST be an absolute path in the root filesystem of
       * the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder setVolumePathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumePath_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetVolumeStatsRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsRequest)
    private static final csi.v1.Csi.NodeGetVolumeStatsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetVolumeStatsRequest();
    }

    public static csi.v1.Csi.NodeGetVolumeStatsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetVolumeStatsRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetVolumeStatsRequest>() {
      public NodeGetVolumeStatsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetVolumeStatsRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetVolumeStatsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetVolumeStatsRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetVolumeStatsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetVolumeStatsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetVolumeStatsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    java.util.List<csi.v1.Csi.VolumeUsage> 
        getUsageList();
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    csi.v1.Csi.VolumeUsage getUsage(int index);
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    int getUsageCount();
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.VolumeUsageOrBuilder> 
        getUsageOrBuilderList();
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    csi.v1.Csi.VolumeUsageOrBuilder getUsageOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v1.NodeGetVolumeStatsResponse}
   */
  public  static final class NodeGetVolumeStatsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetVolumeStatsResponse)
      NodeGetVolumeStatsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetVolumeStatsResponse.newBuilder() to construct.
    private NodeGetVolumeStatsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetVolumeStatsResponse() {
      usage_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetVolumeStatsResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                usage_ = new java.util.ArrayList<csi.v1.Csi.VolumeUsage>();
                mutable_bitField0_ |= 0x00000001;
              }
              usage_.add(
                  input.readMessage(csi.v1.Csi.VolumeUsage.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          usage_ = java.util.Collections.unmodifiableList(usage_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetVolumeStatsResponse.class, csi.v1.Csi.NodeGetVolumeStatsResponse.Builder.class);
    }

    public static final int USAGE_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.VolumeUsage> usage_;
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    public java.util.List<csi.v1.Csi.VolumeUsage> getUsageList() {
      return usage_;
    }
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.VolumeUsageOrBuilder> 
        getUsageOrBuilderList() {
      return usage_;
    }
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    public int getUsageCount() {
      return usage_.size();
    }
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    public csi.v1.Csi.VolumeUsage getUsage(int index) {
      return usage_.get(index);
    }
    /**
     * <pre>
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
     */
    public csi.v1.Csi.VolumeUsageOrBuilder getUsageOrBuilder(
        int index) {
      return usage_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < usage_.size(); i++) {
        output.writeMessage(1, usage_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < usage_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, usage_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetVolumeStatsResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetVolumeStatsResponse other = (csi.v1.Csi.NodeGetVolumeStatsResponse) obj;

      boolean result = true;
      result = result && getUsageList()
          .equals(other.getUsageList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getUsageCount() > 0) {
        hash = (37 * hash) + USAGE_FIELD_NUMBER;
        hash = (53 * hash) + getUsageList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetVolumeStatsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetVolumeStatsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeGetVolumeStatsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetVolumeStatsResponse)
        csi.v1.Csi.NodeGetVolumeStatsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetVolumeStatsResponse.class, csi.v1.Csi.NodeGetVolumeStatsResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetVolumeStatsResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getUsageFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (usageBuilder_ == null) {
          usage_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          usageBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor;
      }

      public csi.v1.Csi.NodeGetVolumeStatsResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetVolumeStatsResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetVolumeStatsResponse build() {
        csi.v1.Csi.NodeGetVolumeStatsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetVolumeStatsResponse buildPartial() {
        csi.v1.Csi.NodeGetVolumeStatsResponse result = new csi.v1.Csi.NodeGetVolumeStatsResponse(this);
        int from_bitField0_ = bitField0_;
        if (usageBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            usage_ = java.util.Collections.unmodifiableList(usage_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.usage_ = usage_;
        } else {
          result.usage_ = usageBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetVolumeStatsResponse) {
          return mergeFrom((csi.v1.Csi.NodeGetVolumeStatsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetVolumeStatsResponse other) {
        if (other == csi.v1.Csi.NodeGetVolumeStatsResponse.getDefaultInstance()) return this;
        if (usageBuilder_ == null) {
          if (!other.usage_.isEmpty()) {
            if (usage_.isEmpty()) {
              usage_ = other.usage_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureUsageIsMutable();
              usage_.addAll(other.usage_);
            }
            onChanged();
          }
        } else {
          if (!other.usage_.isEmpty()) {
            if (usageBuilder_.isEmpty()) {
              usageBuilder_.dispose();
              usageBuilder_ = null;
              usage_ = other.usage_;
              bitField0_ = (bitField0_ & ~0x00000001);
              usageBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getUsageFieldBuilder() : null;
            } else {
              usageBuilder_.addAllMessages(other.usage_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetVolumeStatsResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetVolumeStatsResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.VolumeUsage> usage_ =
        java.util.Collections.emptyList();
      private void ensureUsageIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          usage_ = new java.util.ArrayList<csi.v1.Csi.VolumeUsage>(usage_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeUsage, csi.v1.Csi.VolumeUsage.Builder, csi.v1.Csi.VolumeUsageOrBuilder> usageBuilder_;

      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeUsage> getUsageList() {
        if (usageBuilder_ == null) {
          return java.util.Collections.unmodifiableList(usage_);
        } else {
          return usageBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public int getUsageCount() {
        if (usageBuilder_ == null) {
          return usage_.size();
        } else {
          return usageBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public csi.v1.Csi.VolumeUsage getUsage(int index) {
        if (usageBuilder_ == null) {
          return usage_.get(index);
        } else {
          return usageBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder setUsage(
          int index, csi.v1.Csi.VolumeUsage value) {
        if (usageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsageIsMutable();
          usage_.set(index, value);
          onChanged();
        } else {
          usageBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder setUsage(
          int index, csi.v1.Csi.VolumeUsage.Builder builderForValue) {
        if (usageBuilder_ == null) {
          ensureUsageIsMutable();
          usage_.set(index, builderForValue.build());
          onChanged();
        } else {
          usageBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder addUsage(csi.v1.Csi.VolumeUsage value) {
        if (usageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsageIsMutable();
          usage_.add(value);
          onChanged();
        } else {
          usageBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder addUsage(
          int index, csi.v1.Csi.VolumeUsage value) {
        if (usageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsageIsMutable();
          usage_.add(index, value);
          onChanged();
        } else {
          usageBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder addUsage(
          csi.v1.Csi.VolumeUsage.Builder builderForValue) {
        if (usageBuilder_ == null) {
          ensureUsageIsMutable();
          usage_.add(builderForValue.build());
          onChanged();
        } else {
          usageBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder addUsage(
          int index, csi.v1.Csi.VolumeUsage.Builder builderForValue) {
        if (usageBuilder_ == null) {
          ensureUsageIsMutable();
          usage_.add(index, builderForValue.build());
          onChanged();
        } else {
          usageBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder addAllUsage(
          java.lang.Iterable<? extends csi.v1.Csi.VolumeUsage> values) {
        if (usageBuilder_ == null) {
          ensureUsageIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, usage_);
          onChanged();
        } else {
          usageBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder clearUsage() {
        if (usageBuilder_ == null) {
          usage_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          usageBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public Builder removeUsage(int index) {
        if (usageBuilder_ == null) {
          ensureUsageIsMutable();
          usage_.remove(index);
          onChanged();
        } else {
          usageBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public csi.v1.Csi.VolumeUsage.Builder getUsageBuilder(
          int index) {
        return getUsageFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public csi.v1.Csi.VolumeUsageOrBuilder getUsageOrBuilder(
          int index) {
        if (usageBuilder_ == null) {
          return usage_.get(index);  } else {
          return usageBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.VolumeUsageOrBuilder> 
           getUsageOrBuilderList() {
        if (usageBuilder_ != null) {
          return usageBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(usage_);
        }
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public csi.v1.Csi.VolumeUsage.Builder addUsageBuilder() {
        return getUsageFieldBuilder().addBuilder(
            csi.v1.Csi.VolumeUsage.getDefaultInstance());
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public csi.v1.Csi.VolumeUsage.Builder addUsageBuilder(
          int index) {
        return getUsageFieldBuilder().addBuilder(
            index, csi.v1.Csi.VolumeUsage.getDefaultInstance());
      }
      /**
       * <pre>
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.VolumeUsage usage = 1;</code>
       */
      public java.util.List<csi.v1.Csi.VolumeUsage.Builder> 
           getUsageBuilderList() {
        return getUsageFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.VolumeUsage, csi.v1.Csi.VolumeUsage.Builder, csi.v1.Csi.VolumeUsageOrBuilder> 
          getUsageFieldBuilder() {
        if (usageBuilder_ == null) {
          usageBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.VolumeUsage, csi.v1.Csi.VolumeUsage.Builder, csi.v1.Csi.VolumeUsageOrBuilder>(
                  usage_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          usage_ = null;
        }
        return usageBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetVolumeStatsResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsResponse)
    private static final csi.v1.Csi.NodeGetVolumeStatsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetVolumeStatsResponse();
    }

    public static csi.v1.Csi.NodeGetVolumeStatsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetVolumeStatsResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetVolumeStatsResponse>() {
      public NodeGetVolumeStatsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetVolumeStatsResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetVolumeStatsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetVolumeStatsResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetVolumeStatsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeUsageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.VolumeUsage)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The available capacity in specified Unit. This field is OPTIONAL.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available = 1;</code>
     */
    long getAvailable();

    /**
     * <pre>
     * The total capacity in specified Unit. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 total = 2;</code>
     */
    long getTotal();

    /**
     * <pre>
     * The used capacity in specified Unit. This field is OPTIONAL.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 used = 3;</code>
     */
    long getUsed();

    /**
     * <pre>
     * Units by which values are measured. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
     */
    int getUnitValue();
    /**
     * <pre>
     * Units by which values are measured. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
     */
    csi.v1.Csi.VolumeUsage.Unit getUnit();
  }
  /**
   * Protobuf type {@code csi.v1.VolumeUsage}
   */
  public  static final class VolumeUsage extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.VolumeUsage)
      VolumeUsageOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VolumeUsage.newBuilder() to construct.
    private VolumeUsage(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VolumeUsage() {
      available_ = 0L;
      total_ = 0L;
      used_ = 0L;
      unit_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private VolumeUsage(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              available_ = input.readInt64();
              break;
            }
            case 16: {

              total_ = input.readInt64();
              break;
            }
            case 24: {

              used_ = input.readInt64();
              break;
            }
            case 32: {
              int rawValue = input.readEnum();

              unit_ = rawValue;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeUsage_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_VolumeUsage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.VolumeUsage.class, csi.v1.Csi.VolumeUsage.Builder.class);
    }

    /**
     * Protobuf enum {@code csi.v1.VolumeUsage.Unit}
     */
    public enum Unit
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <code>BYTES = 1;</code>
       */
      BYTES(1),
      /**
       * <code>INODES = 2;</code>
       */
      INODES(2),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <code>BYTES = 1;</code>
       */
      public static final int BYTES_VALUE = 1;
      /**
       * <code>INODES = 2;</code>
       */
      public static final int INODES_VALUE = 2;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Unit valueOf(int value) {
        return forNumber(value);
      }

      public static Unit forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return BYTES;
          case 2: return INODES;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Unit>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Unit> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Unit>() {
              public Unit findValueByNumber(int number) {
                return Unit.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return csi.v1.Csi.VolumeUsage.getDescriptor().getEnumTypes().get(0);
      }

      private static final Unit[] VALUES = values();

      public static Unit valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Unit(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:csi.v1.VolumeUsage.Unit)
    }

    public static final int AVAILABLE_FIELD_NUMBER = 1;
    private long available_;
    /**
     * <pre>
     * The available capacity in specified Unit. This field is OPTIONAL.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available = 1;</code>
     */
    public long getAvailable() {
      return available_;
    }

    public static final int TOTAL_FIELD_NUMBER = 2;
    private long total_;
    /**
     * <pre>
     * The total capacity in specified Unit. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 total = 2;</code>
     */
    public long getTotal() {
      return total_;
    }

    public static final int USED_FIELD_NUMBER = 3;
    private long used_;
    /**
     * <pre>
     * The used capacity in specified Unit. This field is OPTIONAL.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 used = 3;</code>
     */
    public long getUsed() {
      return used_;
    }

    public static final int UNIT_FIELD_NUMBER = 4;
    private int unit_;
    /**
     * <pre>
     * Units by which values are measured. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
     */
    public int getUnitValue() {
      return unit_;
    }
    /**
     * <pre>
     * Units by which values are measured. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
     */
    public csi.v1.Csi.VolumeUsage.Unit getUnit() {
      csi.v1.Csi.VolumeUsage.Unit result = csi.v1.Csi.VolumeUsage.Unit.valueOf(unit_);
      return result == null ? csi.v1.Csi.VolumeUsage.Unit.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (available_ != 0L) {
        output.writeInt64(1, available_);
      }
      if (total_ != 0L) {
        output.writeInt64(2, total_);
      }
      if (used_ != 0L) {
        output.writeInt64(3, used_);
      }
      if (unit_ != csi.v1.Csi.VolumeUsage.Unit.UNKNOWN.getNumber()) {
        output.writeEnum(4, unit_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (available_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, available_);
      }
      if (total_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, total_);
      }
      if (used_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, used_);
      }
      if (unit_ != csi.v1.Csi.VolumeUsage.Unit.UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(4, unit_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.VolumeUsage)) {
        return super.equals(obj);
      }
      csi.v1.Csi.VolumeUsage other = (csi.v1.Csi.VolumeUsage) obj;

      boolean result = true;
      result = result && (getAvailable()
          == other.getAvailable());
      result = result && (getTotal()
          == other.getTotal());
      result = result && (getUsed()
          == other.getUsed());
      result = result && unit_ == other.unit_;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AVAILABLE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAvailable());
      hash = (37 * hash) + TOTAL_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTotal());
      hash = (37 * hash) + USED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getUsed());
      hash = (37 * hash) + UNIT_FIELD_NUMBER;
      hash = (53 * hash) + unit_;
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.VolumeUsage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeUsage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeUsage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.VolumeUsage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.VolumeUsage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.VolumeUsage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.VolumeUsage)
        csi.v1.Csi.VolumeUsageOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeUsage_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeUsage_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.VolumeUsage.class, csi.v1.Csi.VolumeUsage.Builder.class);
      }

      // Construct using csi.v1.Csi.VolumeUsage.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        available_ = 0L;

        total_ = 0L;

        used_ = 0L;

        unit_ = 0;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_VolumeUsage_descriptor;
      }

      public csi.v1.Csi.VolumeUsage getDefaultInstanceForType() {
        return csi.v1.Csi.VolumeUsage.getDefaultInstance();
      }

      public csi.v1.Csi.VolumeUsage build() {
        csi.v1.Csi.VolumeUsage result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.VolumeUsage buildPartial() {
        csi.v1.Csi.VolumeUsage result = new csi.v1.Csi.VolumeUsage(this);
        result.available_ = available_;
        result.total_ = total_;
        result.used_ = used_;
        result.unit_ = unit_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.VolumeUsage) {
          return mergeFrom((csi.v1.Csi.VolumeUsage)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.VolumeUsage other) {
        if (other == csi.v1.Csi.VolumeUsage.getDefaultInstance()) return this;
        if (other.getAvailable() != 0L) {
          setAvailable(other.getAvailable());
        }
        if (other.getTotal() != 0L) {
          setTotal(other.getTotal());
        }
        if (other.getUsed() != 0L) {
          setUsed(other.getUsed());
        }
        if (other.unit_ != 0) {
          setUnitValue(other.getUnitValue());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.VolumeUsage parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.VolumeUsage) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long available_ ;
      /**
       * <pre>
       * The available capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available = 1;</code>
       */
      public long getAvailable() {
        return available_;
      }
      /**
       * <pre>
       * The available capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available = 1;</code>
       */
      public Builder setAvailable(long value) {
        
        available_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The available capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available = 1;</code>
       */
      public Builder clearAvailable() {
        
        available_ = 0L;
        onChanged();
        return this;
      }

      private long total_ ;
      /**
       * <pre>
       * The total capacity in specified Unit. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 total = 2;</code>
       */
      public long getTotal() {
        return total_;
      }
      /**
       * <pre>
       * The total capacity in specified Unit. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 total = 2;</code>
       */
      public Builder setTotal(long value) {
        
        total_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total capacity in specified Unit. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 total = 2;</code>
       */
      public Builder clearTotal() {
        
        total_ = 0L;
        onChanged();
        return this;
      }

      private long used_ ;
      /**
       * <pre>
       * The used capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 used = 3;</code>
       */
      public long getUsed() {
        return used_;
      }
      /**
       * <pre>
       * The used capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 used = 3;</code>
       */
      public Builder setUsed(long value) {
        
        used_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The used capacity in specified Unit. This field is OPTIONAL.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 used = 3;</code>
       */
      public Builder clearUsed() {
        
        used_ = 0L;
        onChanged();
        return this;
      }

      private int unit_ = 0;
      /**
       * <pre>
       * Units by which values are measured. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
       */
      public int getUnitValue() {
        return unit_;
      }
      /**
       * <pre>
       * Units by which values are measured. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
       */
      public Builder setUnitValue(int value) {
        unit_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Units by which values are measured. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
       */
      public csi.v1.Csi.VolumeUsage.Unit getUnit() {
        csi.v1.Csi.VolumeUsage.Unit result = csi.v1.Csi.VolumeUsage.Unit.valueOf(unit_);
        return result == null ? csi.v1.Csi.VolumeUsage.Unit.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Units by which values are measured. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
       */
      public Builder setUnit(csi.v1.Csi.VolumeUsage.Unit value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        unit_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Units by which values are measured. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v1.VolumeUsage.Unit unit = 4;</code>
       */
      public Builder clearUnit() {
        
        unit_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.VolumeUsage)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.VolumeUsage)
    private static final csi.v1.Csi.VolumeUsage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.VolumeUsage();
    }

    public static csi.v1.Csi.VolumeUsage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeUsage>
        PARSER = new com.google.protobuf.AbstractParser<VolumeUsage>() {
      public VolumeUsage parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new VolumeUsage(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<VolumeUsage> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeUsage> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.VolumeUsage getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodeGetCapabilitiesRequest}
   */
  public  static final class NodeGetCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetCapabilitiesRequest)
      NodeGetCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetCapabilitiesRequest.newBuilder() to construct.
    private NodeGetCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetCapabilitiesRequest.class, csi.v1.Csi.NodeGetCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetCapabilitiesRequest other = (csi.v1.Csi.NodeGetCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodeGetCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetCapabilitiesRequest)
        csi.v1.Csi.NodeGetCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetCapabilitiesRequest.class, csi.v1.Csi.NodeGetCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor;
      }

      public csi.v1.Csi.NodeGetCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetCapabilitiesRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetCapabilitiesRequest build() {
        csi.v1.Csi.NodeGetCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetCapabilitiesRequest buildPartial() {
        csi.v1.Csi.NodeGetCapabilitiesRequest result = new csi.v1.Csi.NodeGetCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetCapabilitiesRequest) {
          return mergeFrom((csi.v1.Csi.NodeGetCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetCapabilitiesRequest other) {
        if (other == csi.v1.Csi.NodeGetCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesRequest)
    private static final csi.v1.Csi.NodeGetCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetCapabilitiesRequest();
    }

    public static csi.v1.Csi.NodeGetCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetCapabilitiesRequest>() {
      public NodeGetCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    java.util.List<csi.v1.Csi.NodeServiceCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    csi.v1.Csi.NodeServiceCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    java.util.List<? extends csi.v1.Csi.NodeServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    csi.v1.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v1.NodeGetCapabilitiesResponse}
   */
  public  static final class NodeGetCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetCapabilitiesResponse)
      NodeGetCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetCapabilitiesResponse.newBuilder() to construct.
    private NodeGetCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v1.Csi.NodeServiceCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v1.Csi.NodeServiceCapability.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetCapabilitiesResponse.class, csi.v1.Csi.NodeGetCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v1.Csi.NodeServiceCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    public java.util.List<csi.v1.Csi.NodeServiceCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v1.Csi.NodeServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.NodeServiceCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
     */
    public csi.v1.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(1, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetCapabilitiesResponse other = (csi.v1.Csi.NodeGetCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeGetCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetCapabilitiesResponse)
        csi.v1.Csi.NodeGetCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetCapabilitiesResponse.class, csi.v1.Csi.NodeGetCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor;
      }

      public csi.v1.Csi.NodeGetCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetCapabilitiesResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetCapabilitiesResponse build() {
        csi.v1.Csi.NodeGetCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetCapabilitiesResponse buildPartial() {
        csi.v1.Csi.NodeGetCapabilitiesResponse result = new csi.v1.Csi.NodeGetCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetCapabilitiesResponse) {
          return mergeFrom((csi.v1.Csi.NodeGetCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetCapabilitiesResponse other) {
        if (other == csi.v1.Csi.NodeGetCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v1.Csi.NodeServiceCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v1.Csi.NodeServiceCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.NodeServiceCapability, csi.v1.Csi.NodeServiceCapability.Builder, csi.v1.Csi.NodeServiceCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.NodeServiceCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v1.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(csi.v1.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          csi.v1.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v1.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v1.Csi.NodeServiceCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v1.Csi.NodeServiceCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v1.Csi.NodeServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v1.Csi.NodeServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v1.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v1.Csi.NodeServiceCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v1.Csi.NodeServiceCapability, csi.v1.Csi.NodeServiceCapability.Builder, csi.v1.Csi.NodeServiceCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v1.Csi.NodeServiceCapability, csi.v1.Csi.NodeServiceCapability.Builder, csi.v1.Csi.NodeServiceCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesResponse)
    private static final csi.v1.Csi.NodeGetCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetCapabilitiesResponse();
    }

    public static csi.v1.Csi.NodeGetCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetCapabilitiesResponse>() {
      public NodeGetCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeServiceCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeServiceCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    boolean hasRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    csi.v1.Csi.NodeServiceCapability.RPC getRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    csi.v1.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder();

    public csi.v1.Csi.NodeServiceCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the node service.
   * </pre>
   *
   * Protobuf type {@code csi.v1.NodeServiceCapability}
   */
  public  static final class NodeServiceCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeServiceCapability)
      NodeServiceCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeServiceCapability.newBuilder() to construct.
    private NodeServiceCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeServiceCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeServiceCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              csi.v1.Csi.NodeServiceCapability.RPC.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v1.Csi.NodeServiceCapability.RPC) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v1.Csi.NodeServiceCapability.RPC.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v1.Csi.NodeServiceCapability.RPC) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeServiceCapability.class, csi.v1.Csi.NodeServiceCapability.Builder.class);
    }

    public interface RPCOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v1.NodeServiceCapability.RPC)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      csi.v1.Csi.NodeServiceCapability.RPC.Type getType();
    }
    /**
     * Protobuf type {@code csi.v1.NodeServiceCapability.RPC}
     */
    public  static final class RPC extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v1.NodeServiceCapability.RPC)
        RPCOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use RPC.newBuilder() to construct.
      private RPC(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private RPC() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private RPC(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_RPC_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_RPC_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeServiceCapability.RPC.class, csi.v1.Csi.NodeServiceCapability.RPC.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v1.NodeServiceCapability.RPC.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <code>STAGE_UNSTAGE_VOLUME = 1;</code>
         */
        STAGE_UNSTAGE_VOLUME(1),
        /**
         * <pre>
         * If Plugin implements GET_VOLUME_STATS capability
         * then it MUST implement NodeGetVolumeStats RPC
         * call for fetching volume statistics.
         * </pre>
         *
         * <code>GET_VOLUME_STATS = 2;</code>
         */
        GET_VOLUME_STATS(2),
        /**
         * <pre>
         * See VolumeExpansion for details.
         * </pre>
         *
         * <code>EXPAND_VOLUME = 3;</code>
         */
        EXPAND_VOLUME(3),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <code>STAGE_UNSTAGE_VOLUME = 1;</code>
         */
        public static final int STAGE_UNSTAGE_VOLUME_VALUE = 1;
        /**
         * <pre>
         * If Plugin implements GET_VOLUME_STATS capability
         * then it MUST implement NodeGetVolumeStats RPC
         * call for fetching volume statistics.
         * </pre>
         *
         * <code>GET_VOLUME_STATS = 2;</code>
         */
        public static final int GET_VOLUME_STATS_VALUE = 2;
        /**
         * <pre>
         * See VolumeExpansion for details.
         * </pre>
         *
         * <code>EXPAND_VOLUME = 3;</code>
         */
        public static final int EXPAND_VOLUME_VALUE = 3;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return STAGE_UNSTAGE_VOLUME;
            case 2: return GET_VOLUME_STATS;
            case 3: return EXPAND_VOLUME;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v1.Csi.NodeServiceCapability.RPC.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v1.NodeServiceCapability.RPC.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.RPC.Type getType() {
        csi.v1.Csi.NodeServiceCapability.RPC.Type result = csi.v1.Csi.NodeServiceCapability.RPC.Type.valueOf(type_);
        return result == null ? csi.v1.Csi.NodeServiceCapability.RPC.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v1.Csi.NodeServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v1.Csi.NodeServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v1.Csi.NodeServiceCapability.RPC)) {
          return super.equals(obj);
        }
        csi.v1.Csi.NodeServiceCapability.RPC other = (csi.v1.Csi.NodeServiceCapability.RPC) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v1.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v1.Csi.NodeServiceCapability.RPC prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v1.NodeServiceCapability.RPC}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v1.NodeServiceCapability.RPC)
          csi.v1.Csi.NodeServiceCapability.RPCOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_RPC_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_RPC_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v1.Csi.NodeServiceCapability.RPC.class, csi.v1.Csi.NodeServiceCapability.RPC.Builder.class);
        }

        // Construct using csi.v1.Csi.NodeServiceCapability.RPC.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_RPC_descriptor;
        }

        public csi.v1.Csi.NodeServiceCapability.RPC getDefaultInstanceForType() {
          return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }

        public csi.v1.Csi.NodeServiceCapability.RPC build() {
          csi.v1.Csi.NodeServiceCapability.RPC result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public csi.v1.Csi.NodeServiceCapability.RPC buildPartial() {
          csi.v1.Csi.NodeServiceCapability.RPC result = new csi.v1.Csi.NodeServiceCapability.RPC(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v1.Csi.NodeServiceCapability.RPC) {
            return mergeFrom((csi.v1.Csi.NodeServiceCapability.RPC)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v1.Csi.NodeServiceCapability.RPC other) {
          if (other == csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v1.Csi.NodeServiceCapability.RPC parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v1.Csi.NodeServiceCapability.RPC) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public csi.v1.Csi.NodeServiceCapability.RPC.Type getType() {
          csi.v1.Csi.NodeServiceCapability.RPC.Type result = csi.v1.Csi.NodeServiceCapability.RPC.Type.valueOf(type_);
          return result == null ? csi.v1.Csi.NodeServiceCapability.RPC.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setType(csi.v1.Csi.NodeServiceCapability.RPC.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v1.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v1.NodeServiceCapability.RPC)
      }

      // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability.RPC)
      private static final csi.v1.Csi.NodeServiceCapability.RPC DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v1.Csi.NodeServiceCapability.RPC();
      }

      public static csi.v1.Csi.NodeServiceCapability.RPC getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<RPC>
          PARSER = new com.google.protobuf.AbstractParser<RPC>() {
        public RPC parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new RPC(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<RPC> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<RPC> getParserForType() {
        return PARSER;
      }

      public csi.v1.Csi.NodeServiceCapability.RPC getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      RPC(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return RPC;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int RPC_FIELD_NUMBER = 1;
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public boolean hasRpc() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v1.Csi.NodeServiceCapability.RPC getRpc() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.NodeServiceCapability.RPC) type_;
      }
      return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v1.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v1.Csi.NodeServiceCapability.RPC) type_;
      }
      return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v1.Csi.NodeServiceCapability.RPC) type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v1.Csi.NodeServiceCapability.RPC) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeServiceCapability)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeServiceCapability other = (csi.v1.Csi.NodeServiceCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getRpc()
              .equals(other.getRpc());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + RPC_FIELD_NUMBER;
          hash = (53 * hash) + getRpc().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeServiceCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeServiceCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeServiceCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the node service.
     * </pre>
     *
     * Protobuf type {@code csi.v1.NodeServiceCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeServiceCapability)
        csi.v1.Csi.NodeServiceCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeServiceCapability.class, csi.v1.Csi.NodeServiceCapability.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeServiceCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeServiceCapability_descriptor;
      }

      public csi.v1.Csi.NodeServiceCapability getDefaultInstanceForType() {
        return csi.v1.Csi.NodeServiceCapability.getDefaultInstance();
      }

      public csi.v1.Csi.NodeServiceCapability build() {
        csi.v1.Csi.NodeServiceCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeServiceCapability buildPartial() {
        csi.v1.Csi.NodeServiceCapability result = new csi.v1.Csi.NodeServiceCapability(this);
        if (typeCase_ == 1) {
          if (rpcBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = rpcBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeServiceCapability) {
          return mergeFrom((csi.v1.Csi.NodeServiceCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeServiceCapability other) {
        if (other == csi.v1.Csi.NodeServiceCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case RPC: {
            mergeRpc(other.getRpc());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeServiceCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeServiceCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.NodeServiceCapability.RPC, csi.v1.Csi.NodeServiceCapability.RPC.Builder, csi.v1.Csi.NodeServiceCapability.RPCOrBuilder> rpcBuilder_;
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public boolean hasRpc() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.RPC getRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.NodeServiceCapability.RPC) type_;
          }
          return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return rpcBuilder_.getMessage();
          }
          return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(csi.v1.Csi.NodeServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(
          csi.v1.Csi.NodeServiceCapability.RPC.Builder builderForValue) {
        if (rpcBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          rpcBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder mergeRpc(csi.v1.Csi.NodeServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance()) {
            type_ = csi.v1.Csi.NodeServiceCapability.RPC.newBuilder((csi.v1.Csi.NodeServiceCapability.RPC) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            rpcBuilder_.mergeFrom(value);
          }
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder clearRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          rpcBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.RPC.Builder getRpcBuilder() {
        return getRpcFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v1.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder() {
        if ((typeCase_ == 1) && (rpcBuilder_ != null)) {
          return rpcBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v1.Csi.NodeServiceCapability.RPC) type_;
          }
          return csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v1.NodeServiceCapability.RPC rpc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.NodeServiceCapability.RPC, csi.v1.Csi.NodeServiceCapability.RPC.Builder, csi.v1.Csi.NodeServiceCapability.RPCOrBuilder> 
          getRpcFieldBuilder() {
        if (rpcBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v1.Csi.NodeServiceCapability.RPC.getDefaultInstance();
          }
          rpcBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.NodeServiceCapability.RPC, csi.v1.Csi.NodeServiceCapability.RPC.Builder, csi.v1.Csi.NodeServiceCapability.RPCOrBuilder>(
                  (csi.v1.Csi.NodeServiceCapability.RPC) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return rpcBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeServiceCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability)
    private static final csi.v1.Csi.NodeServiceCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeServiceCapability();
    }

    public static csi.v1.Csi.NodeServiceCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeServiceCapability>
        PARSER = new com.google.protobuf.AbstractParser<NodeServiceCapability>() {
      public NodeServiceCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeServiceCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeServiceCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeServiceCapability> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeServiceCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetInfoRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code csi.v1.NodeGetInfoRequest}
   */
  public  static final class NodeGetInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetInfoRequest)
      NodeGetInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetInfoRequest.newBuilder() to construct.
    private NodeGetInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetInfoRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetInfoRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetInfoRequest.class, csi.v1.Csi.NodeGetInfoRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetInfoRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetInfoRequest other = (csi.v1.Csi.NodeGetInfoRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeGetInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetInfoRequest)
        csi.v1.Csi.NodeGetInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetInfoRequest.class, csi.v1.Csi.NodeGetInfoRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetInfoRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoRequest_descriptor;
      }

      public csi.v1.Csi.NodeGetInfoRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetInfoRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetInfoRequest build() {
        csi.v1.Csi.NodeGetInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetInfoRequest buildPartial() {
        csi.v1.Csi.NodeGetInfoRequest result = new csi.v1.Csi.NodeGetInfoRequest(this);
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetInfoRequest) {
          return mergeFrom((csi.v1.Csi.NodeGetInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetInfoRequest other) {
        if (other == csi.v1.Csi.NodeGetInfoRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetInfoRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetInfoRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoRequest)
    private static final csi.v1.Csi.NodeGetInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetInfoRequest();
    }

    public static csi.v1.Csi.NodeGetInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetInfoRequest>() {
      public NodeGetInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetInfoRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetInfoRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeGetInfoResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The identifier of the node as understood by the SP.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific node vs all other nodes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls, including
     * `ControllerPublishVolume`, to refer to this node.
     * The SP is NOT responsible for global uniqueness of node_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The identifier of the node as understood by the SP.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific node vs all other nodes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls, including
     * `ControllerPublishVolume`, to refer to this node.
     * The SP is NOT responsible for global uniqueness of node_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * Maximum number of volumes that controller can publish to the node.
     * If value is not set or zero CO SHALL decide how many volumes of
     * this type can be published by the controller to the node. The
     * plugin MUST NOT set negative values here.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 max_volumes_per_node = 2;</code>
     */
    long getMaxVolumesPerNode();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    boolean hasAccessibleTopology();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    csi.v1.Csi.Topology getAccessibleTopology();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.NodeGetInfoResponse}
   */
  public  static final class NodeGetInfoResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeGetInfoResponse)
      NodeGetInfoResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetInfoResponse.newBuilder() to construct.
    private NodeGetInfoResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetInfoResponse() {
      nodeId_ = "";
      maxVolumesPerNode_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetInfoResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 16: {

              maxVolumesPerNode_ = input.readInt64();
              break;
            }
            case 26: {
              csi.v1.Csi.Topology.Builder subBuilder = null;
              if (accessibleTopology_ != null) {
                subBuilder = accessibleTopology_.toBuilder();
              }
              accessibleTopology_ = input.readMessage(csi.v1.Csi.Topology.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibleTopology_);
                accessibleTopology_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeGetInfoResponse.class, csi.v1.Csi.NodeGetInfoResponse.Builder.class);
    }

    public static final int NODE_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The identifier of the node as understood by the SP.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific node vs all other nodes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls, including
     * `ControllerPublishVolume`, to refer to this node.
     * The SP is NOT responsible for global uniqueness of node_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The identifier of the node as understood by the SP.
     * This field is REQUIRED.
     * This field MUST contain enough information to uniquely identify
     * this specific node vs all other nodes supported by this plugin.
     * This field SHALL be used by the CO in subsequent calls, including
     * `ControllerPublishVolume`, to refer to this node.
     * The SP is NOT responsible for global uniqueness of node_id across
     * multiple SPs.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MAX_VOLUMES_PER_NODE_FIELD_NUMBER = 2;
    private long maxVolumesPerNode_;
    /**
     * <pre>
     * Maximum number of volumes that controller can publish to the node.
     * If value is not set or zero CO SHALL decide how many volumes of
     * this type can be published by the controller to the node. The
     * plugin MUST NOT set negative values here.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 max_volumes_per_node = 2;</code>
     */
    public long getMaxVolumesPerNode() {
      return maxVolumesPerNode_;
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 3;
    private csi.v1.Csi.Topology accessibleTopology_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public boolean hasAccessibleTopology() {
      return accessibleTopology_ != null;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public csi.v1.Csi.Topology getAccessibleTopology() {
      return accessibleTopology_ == null ? csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v1.Topology accessible_topology = 3;</code>
     */
    public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
      return getAccessibleTopology();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, nodeId_);
      }
      if (maxVolumesPerNode_ != 0L) {
        output.writeInt64(2, maxVolumesPerNode_);
      }
      if (accessibleTopology_ != null) {
        output.writeMessage(3, getAccessibleTopology());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, nodeId_);
      }
      if (maxVolumesPerNode_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, maxVolumesPerNode_);
      }
      if (accessibleTopology_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessibleTopology());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeGetInfoResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeGetInfoResponse other = (csi.v1.Csi.NodeGetInfoResponse) obj;

      boolean result = true;
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && (getMaxVolumesPerNode()
          == other.getMaxVolumesPerNode());
      result = result && (hasAccessibleTopology() == other.hasAccessibleTopology());
      if (hasAccessibleTopology()) {
        result = result && getAccessibleTopology()
            .equals(other.getAccessibleTopology());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      hash = (37 * hash) + MAX_VOLUMES_PER_NODE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxVolumesPerNode());
      if (hasAccessibleTopology()) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopology().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeGetInfoResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeGetInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeGetInfoResponse)
        csi.v1.Csi.NodeGetInfoResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeGetInfoResponse.class, csi.v1.Csi.NodeGetInfoResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeGetInfoResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        nodeId_ = "";

        maxVolumesPerNode_ = 0L;

        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeGetInfoResponse_descriptor;
      }

      public csi.v1.Csi.NodeGetInfoResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeGetInfoResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeGetInfoResponse build() {
        csi.v1.Csi.NodeGetInfoResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeGetInfoResponse buildPartial() {
        csi.v1.Csi.NodeGetInfoResponse result = new csi.v1.Csi.NodeGetInfoResponse(this);
        result.nodeId_ = nodeId_;
        result.maxVolumesPerNode_ = maxVolumesPerNode_;
        if (accessibleTopologyBuilder_ == null) {
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeGetInfoResponse) {
          return mergeFrom((csi.v1.Csi.NodeGetInfoResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeGetInfoResponse other) {
        if (other == csi.v1.Csi.NodeGetInfoResponse.getDefaultInstance()) return this;
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        if (other.getMaxVolumesPerNode() != 0L) {
          setMaxVolumesPerNode(other.getMaxVolumesPerNode());
        }
        if (other.hasAccessibleTopology()) {
          mergeAccessibleTopology(other.getAccessibleTopology());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeGetInfoResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeGetInfoResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The identifier of the node as understood by the SP.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific node vs all other nodes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls, including
       * `ControllerPublishVolume`, to refer to this node.
       * The SP is NOT responsible for global uniqueness of node_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The identifier of the node as understood by the SP.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific node vs all other nodes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls, including
       * `ControllerPublishVolume`, to refer to this node.
       * The SP is NOT responsible for global uniqueness of node_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The identifier of the node as understood by the SP.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific node vs all other nodes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls, including
       * `ControllerPublishVolume`, to refer to this node.
       * The SP is NOT responsible for global uniqueness of node_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier of the node as understood by the SP.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific node vs all other nodes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls, including
       * `ControllerPublishVolume`, to refer to this node.
       * The SP is NOT responsible for global uniqueness of node_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The identifier of the node as understood by the SP.
       * This field is REQUIRED.
       * This field MUST contain enough information to uniquely identify
       * this specific node vs all other nodes supported by this plugin.
       * This field SHALL be used by the CO in subsequent calls, including
       * `ControllerPublishVolume`, to refer to this node.
       * The SP is NOT responsible for global uniqueness of node_id across
       * multiple SPs.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private long maxVolumesPerNode_ ;
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public long getMaxVolumesPerNode() {
        return maxVolumesPerNode_;
      }
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public Builder setMaxVolumesPerNode(long value) {
        
        maxVolumesPerNode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public Builder clearMaxVolumesPerNode() {
        
        maxVolumesPerNode_ = 0L;
        onChanged();
        return this;
      }

      private csi.v1.Csi.Topology accessibleTopology_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public boolean hasAccessibleTopology() {
        return accessibleTopologyBuilder_ != null || accessibleTopology_ != null;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.Topology getAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_ == null ? csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        } else {
          return accessibleTopologyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibleTopology_ = value;
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(
          csi.v1.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = builderForValue.build();
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder mergeAccessibleTopology(csi.v1.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (accessibleTopology_ != null) {
            accessibleTopology_ =
              csi.v1.Csi.Topology.newBuilder(accessibleTopology_).mergeFrom(value).buildPartial();
          } else {
            accessibleTopology_ = value;
          }
          onChanged();
        } else {
          accessibleTopologyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
          onChanged();
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.Topology.Builder getAccessibleTopologyBuilder() {
        
        onChanged();
        return getAccessibleTopologyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      public csi.v1.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilder();
        } else {
          return accessibleTopology_ == null ?
              csi.v1.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v1.Topology accessible_topology = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.Topology, csi.v1.Csi.Topology.Builder, csi.v1.Csi.TopologyOrBuilder>(
                  getAccessibleTopology(),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeGetInfoResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoResponse)
    private static final csi.v1.Csi.NodeGetInfoResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeGetInfoResponse();
    }

    public static csi.v1.Csi.NodeGetInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetInfoResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetInfoResponse>() {
      public NodeGetInfoResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetInfoResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetInfoResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetInfoResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeGetInfoResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeExpandVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeExpandVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The path on which volume is available. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    java.lang.String getVolumePath();
    /**
     * <pre>
     * The path on which volume is available. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getVolumePathBytes();

    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    boolean hasCapacityRange();
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    csi.v1.Csi.CapacityRange getCapacityRange();
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v1.NodeExpandVolumeRequest}
   */
  public  static final class NodeExpandVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeExpandVolumeRequest)
      NodeExpandVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeExpandVolumeRequest.newBuilder() to construct.
    private NodeExpandVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeExpandVolumeRequest() {
      volumeId_ = "";
      volumePath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeExpandVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              volumePath_ = s;
              break;
            }
            case 26: {
              csi.v1.Csi.CapacityRange.Builder subBuilder = null;
              if (capacityRange_ != null) {
                subBuilder = capacityRange_.toBuilder();
              }
              capacityRange_ = input.readMessage(csi.v1.Csi.CapacityRange.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(capacityRange_);
                capacityRange_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeRequest_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeExpandVolumeRequest.class, csi.v1.Csi.NodeExpandVolumeRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object volumePath_;
    /**
     * <pre>
     * The path on which volume is available. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    public java.lang.String getVolumePath() {
      java.lang.Object ref = volumePath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumePath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path on which volume is available. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVolumePathBytes() {
      java.lang.Object ref = volumePath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumePath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAPACITY_RANGE_FIELD_NUMBER = 3;
    private csi.v1.Csi.CapacityRange capacityRange_;
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    public boolean hasCapacityRange() {
      return capacityRange_ != null;
    }
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    public csi.v1.Csi.CapacityRange getCapacityRange() {
      return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
    }
    /**
     * <pre>
     * This allows CO to specify the capacity requirements of the volume
     * after expansion. If capacity_range is omitted then a plugin MAY
     * inspect the file system of the volume to determine the maximum
     * capacity to which the volume can be expanded. In such cases a
     * plugin MAY expand the volume to its maximum capacity.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
     */
    public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
      return getCapacityRange();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getVolumePathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, volumePath_);
      }
      if (capacityRange_ != null) {
        output.writeMessage(3, getCapacityRange());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getVolumePathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, volumePath_);
      }
      if (capacityRange_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCapacityRange());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeExpandVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeExpandVolumeRequest other = (csi.v1.Csi.NodeExpandVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getVolumePath()
          .equals(other.getVolumePath());
      result = result && (hasCapacityRange() == other.hasCapacityRange());
      if (hasCapacityRange()) {
        result = result && getCapacityRange()
            .equals(other.getCapacityRange());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + VOLUME_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getVolumePath().hashCode();
      if (hasCapacityRange()) {
        hash = (37 * hash) + CAPACITY_RANGE_FIELD_NUMBER;
        hash = (53 * hash) + getCapacityRange().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeExpandVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeExpandVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeExpandVolumeRequest)
        csi.v1.Csi.NodeExpandVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeRequest_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeExpandVolumeRequest.class, csi.v1.Csi.NodeExpandVolumeRequest.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeExpandVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        volumePath_ = "";

        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeRequest_descriptor;
      }

      public csi.v1.Csi.NodeExpandVolumeRequest getDefaultInstanceForType() {
        return csi.v1.Csi.NodeExpandVolumeRequest.getDefaultInstance();
      }

      public csi.v1.Csi.NodeExpandVolumeRequest build() {
        csi.v1.Csi.NodeExpandVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeExpandVolumeRequest buildPartial() {
        csi.v1.Csi.NodeExpandVolumeRequest result = new csi.v1.Csi.NodeExpandVolumeRequest(this);
        result.volumeId_ = volumeId_;
        result.volumePath_ = volumePath_;
        if (capacityRangeBuilder_ == null) {
          result.capacityRange_ = capacityRange_;
        } else {
          result.capacityRange_ = capacityRangeBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeExpandVolumeRequest) {
          return mergeFrom((csi.v1.Csi.NodeExpandVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeExpandVolumeRequest other) {
        if (other == csi.v1.Csi.NodeExpandVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getVolumePath().isEmpty()) {
          volumePath_ = other.volumePath_;
          onChanged();
        }
        if (other.hasCapacityRange()) {
          mergeCapacityRange(other.getCapacityRange());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeExpandVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeExpandVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object volumePath_ = "";
      /**
       * <pre>
       * The path on which volume is available. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public java.lang.String getVolumePath() {
        java.lang.Object ref = volumePath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumePath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path on which volume is available. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getVolumePathBytes() {
        java.lang.Object ref = volumePath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumePath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path on which volume is available. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder setVolumePath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumePath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path on which volume is available. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder clearVolumePath() {
        
        volumePath_ = getDefaultInstance().getVolumePath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path on which volume is available. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_path = 2;</code>
       */
      public Builder setVolumePathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumePath_ = value;
        onChanged();
        return this;
      }

      private csi.v1.Csi.CapacityRange capacityRange_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> capacityRangeBuilder_;
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public boolean hasCapacityRange() {
        return capacityRangeBuilder_ != null || capacityRange_ != null;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public csi.v1.Csi.CapacityRange getCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          return capacityRange_ == null ? csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        } else {
          return capacityRangeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public Builder setCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capacityRange_ = value;
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public Builder setCapacityRange(
          csi.v1.Csi.CapacityRange.Builder builderForValue) {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = builderForValue.build();
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public Builder mergeCapacityRange(csi.v1.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (capacityRange_ != null) {
            capacityRange_ =
              csi.v1.Csi.CapacityRange.newBuilder(capacityRange_).mergeFrom(value).buildPartial();
          } else {
            capacityRange_ = value;
          }
          onChanged();
        } else {
          capacityRangeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public Builder clearCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
          onChanged();
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public csi.v1.Csi.CapacityRange.Builder getCapacityRangeBuilder() {
        
        onChanged();
        return getCapacityRangeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      public csi.v1.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
        if (capacityRangeBuilder_ != null) {
          return capacityRangeBuilder_.getMessageOrBuilder();
        } else {
          return capacityRange_ == null ?
              csi.v1.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        }
      }
      /**
       * <pre>
       * This allows CO to specify the capacity requirements of the volume
       * after expansion. If capacity_range is omitted then a plugin MAY
       * inspect the file system of the volume to determine the maximum
       * capacity to which the volume can be expanded. In such cases a
       * plugin MAY expand the volume to its maximum capacity.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v1.CapacityRange capacity_range = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder> 
          getCapacityRangeFieldBuilder() {
        if (capacityRangeBuilder_ == null) {
          capacityRangeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v1.Csi.CapacityRange, csi.v1.Csi.CapacityRange.Builder, csi.v1.Csi.CapacityRangeOrBuilder>(
                  getCapacityRange(),
                  getParentForChildren(),
                  isClean());
          capacityRange_ = null;
        }
        return capacityRangeBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeExpandVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeRequest)
    private static final csi.v1.Csi.NodeExpandVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeExpandVolumeRequest();
    }

    public static csi.v1.Csi.NodeExpandVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeExpandVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeExpandVolumeRequest>() {
      public NodeExpandVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeExpandVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeExpandVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeExpandVolumeRequest> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeExpandVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeExpandVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v1.NodeExpandVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    long getCapacityBytes();
  }
  /**
   * Protobuf type {@code csi.v1.NodeExpandVolumeResponse}
   */
  public  static final class NodeExpandVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v1.NodeExpandVolumeResponse)
      NodeExpandVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeExpandVolumeResponse.newBuilder() to construct.
    private NodeExpandVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeExpandVolumeResponse() {
      capacityBytes_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeExpandVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              capacityBytes_ = input.readInt64();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeResponse_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v1.Csi.NodeExpandVolumeResponse.class, csi.v1.Csi.NodeExpandVolumeResponse.Builder.class);
    }

    public static final int CAPACITY_BYTES_FIELD_NUMBER = 1;
    private long capacityBytes_;
    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    public long getCapacityBytes() {
      return capacityBytes_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (capacityBytes_ != 0L) {
        output.writeInt64(1, capacityBytes_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (capacityBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, capacityBytes_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v1.Csi.NodeExpandVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v1.Csi.NodeExpandVolumeResponse other = (csi.v1.Csi.NodeExpandVolumeResponse) obj;

      boolean result = true;
      result = result && (getCapacityBytes()
          == other.getCapacityBytes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CAPACITY_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapacityBytes());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v1.Csi.NodeExpandVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v1.Csi.NodeExpandVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v1.NodeExpandVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v1.NodeExpandVolumeResponse)
        csi.v1.Csi.NodeExpandVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeResponse_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v1.Csi.NodeExpandVolumeResponse.class, csi.v1.Csi.NodeExpandVolumeResponse.Builder.class);
      }

      // Construct using csi.v1.Csi.NodeExpandVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        capacityBytes_ = 0L;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v1.Csi.internal_static_csi_v1_NodeExpandVolumeResponse_descriptor;
      }

      public csi.v1.Csi.NodeExpandVolumeResponse getDefaultInstanceForType() {
        return csi.v1.Csi.NodeExpandVolumeResponse.getDefaultInstance();
      }

      public csi.v1.Csi.NodeExpandVolumeResponse build() {
        csi.v1.Csi.NodeExpandVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public csi.v1.Csi.NodeExpandVolumeResponse buildPartial() {
        csi.v1.Csi.NodeExpandVolumeResponse result = new csi.v1.Csi.NodeExpandVolumeResponse(this);
        result.capacityBytes_ = capacityBytes_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v1.Csi.NodeExpandVolumeResponse) {
          return mergeFrom((csi.v1.Csi.NodeExpandVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v1.Csi.NodeExpandVolumeResponse other) {
        if (other == csi.v1.Csi.NodeExpandVolumeResponse.getDefaultInstance()) return this;
        if (other.getCapacityBytes() != 0L) {
          setCapacityBytes(other.getCapacityBytes());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v1.Csi.NodeExpandVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v1.Csi.NodeExpandVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long capacityBytes_ ;
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public long getCapacityBytes() {
        return capacityBytes_;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder setCapacityBytes(long value) {
        
        capacityBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder clearCapacityBytes() {
        
        capacityBytes_ = 0L;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v1.NodeExpandVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeResponse)
    private static final csi.v1.Csi.NodeExpandVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v1.Csi.NodeExpandVolumeResponse();
    }

    public static csi.v1.Csi.NodeExpandVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeExpandVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeExpandVolumeResponse>() {
      public NodeExpandVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeExpandVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeExpandVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeExpandVolumeResponse> getParserForType() {
      return PARSER;
    }

    public csi.v1.Csi.NodeExpandVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int CSI_SECRET_FIELD_NUMBER = 1059;
  /**
   * <pre>
   * Indicates that a field MAY contain information that is sensitive
   * and MUST be treated as such (e.g. not logged).
   * </pre>
   *
   * <code>extend .google.protobuf.FieldOptions { ... }</code>
   */
  public static final
    com.google.protobuf.GeneratedMessage.GeneratedExtension<
      com.google.protobuf.DescriptorProtos.FieldOptions,
      java.lang.Boolean> csiSecret = com.google.protobuf.GeneratedMessage
          .newFileScopedGeneratedExtension(
        java.lang.Boolean.class,
        null);
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetPluginInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetPluginInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetPluginInfoResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetPluginInfoResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetPluginCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetPluginCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_PluginCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_PluginCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_PluginCapability_Service_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_PluginCapability_Service_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_PluginCapability_VolumeExpansion_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ProbeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ProbeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ProbeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ProbeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeContentSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeContentSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeContentSource_SnapshotSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeContentSource_VolumeSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeCapability_BlockVolume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeCapability_MountVolume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeCapability_MountVolume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeCapability_AccessMode_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeCapability_AccessMode_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CapacityRange_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CapacityRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_Volume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_Volume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_Volume_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_Volume_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_TopologyRequirement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_TopologyRequirement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_Topology_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_Topology_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_Topology_SegmentsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_Topology_SegmentsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerPublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerPublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerUnpublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerUnpublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListVolumesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListVolumesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListVolumesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListVolumesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListVolumesResponse_Entry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListVolumesResponse_Entry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetCapacityRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetCapacityRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetCapacityRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetCapacityRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_GetCapacityResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_GetCapacityResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerGetCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerGetCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerServiceCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerServiceCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerServiceCapability_RPC_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateSnapshotRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateSnapshotRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_CreateSnapshotResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_CreateSnapshotResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_Snapshot_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_Snapshot_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteSnapshotRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteSnapshotRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_DeleteSnapshotResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_DeleteSnapshotResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListSnapshotsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListSnapshotsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListSnapshotsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListSnapshotsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ListSnapshotsResponse_Entry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerExpandVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_ControllerExpandVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeStageVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeStageVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeStageVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeStageVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeUnstageVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeUnstageVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodePublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodePublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodePublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodePublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeUnpublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeUnpublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetVolumeStatsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetVolumeStatsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_VolumeUsage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_VolumeUsage_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeServiceCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeServiceCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeServiceCapability_RPC_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeServiceCapability_RPC_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeGetInfoResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeGetInfoResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeExpandVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeExpandVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v1_NodeExpandVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v1_NodeExpandVolumeResponse_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\tcsi.proto\022\006csi.v1\032 google/protobuf/des" +
      "criptor.proto\032\037google/protobuf/timestamp" +
      ".proto\032\036google/protobuf/wrappers.proto\"\026" +
      "\n\024GetPluginInfoRequest\"\255\001\n\025GetPluginInfo" +
      "Response\022\014\n\004name\030\001 \001(\t\022\026\n\016vendor_version" +
      "\030\002 \001(\t\022=\n\010manifest\030\003 \003(\0132+.csi.v1.GetPlu" +
      "ginInfoResponse.ManifestEntry\032/\n\rManifes" +
      "tEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\036" +
      "\n\034GetPluginCapabilitiesRequest\"O\n\035GetPlu" +
      "ginCapabilitiesResponse\022.\n\014capabilities\030" +
      "\001 \003(\0132\030.csi.v1.PluginCapability\"\352\002\n\020Plug" +
      "inCapability\0223\n\007service\030\001 \001(\0132 .csi.v1.P" +
      "luginCapability.ServiceH\000\022D\n\020volume_expa" +
      "nsion\030\002 \001(\0132(.csi.v1.PluginCapability.Vo" +
      "lumeExpansionH\000\032\221\001\n\007Service\0223\n\004type\030\001 \001(" +
      "\0162%.csi.v1.PluginCapability.Service.Type" +
      "\"Q\n\004Type\022\013\n\007UNKNOWN\020\000\022\026\n\022CONTROLLER_SERV" +
      "ICE\020\001\022$\n VOLUME_ACCESSIBILITY_CONSTRAINT" +
      "S\020\002\032?\n\017VolumeExpansion\",\n\004Type\022\013\n\007UNKNOW" +
      "N\020\000\022\n\n\006ONLINE\020\001\022\013\n\007OFFLINE\020\002B\006\n\004type\"\016\n\014" +
      "ProbeRequest\":\n\rProbeResponse\022)\n\005ready\030\001" +
      " \001(\0132\032.google.protobuf.BoolValue\"\352\003\n\023Cre" +
      "ateVolumeRequest\022\014\n\004name\030\001 \001(\t\022-\n\016capaci" +
      "ty_range\030\002 \001(\0132\025.csi.v1.CapacityRange\0225\n" +
      "\023volume_capabilities\030\003 \003(\0132\030.csi.v1.Volu" +
      "meCapability\022?\n\nparameters\030\004 \003(\0132+.csi.v" +
      "1.CreateVolumeRequest.ParametersEntry\022>\n" +
      "\007secrets\030\005 \003(\0132(.csi.v1.CreateVolumeRequ" +
      "est.SecretsEntryB\003\230B\001\022:\n\025volume_content_" +
      "source\030\006 \001(\0132\033.csi.v1.VolumeContentSourc" +
      "e\022?\n\032accessibility_requirements\030\007 \001(\0132\033." +
      "csi.v1.TopologyRequirement\0321\n\017Parameters" +
      "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032.\n" +
      "\014SecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(" +
      "\t:\0028\001\"\343\001\n\023VolumeContentSource\022>\n\010snapsho" +
      "t\030\001 \001(\0132*.csi.v1.VolumeContentSource.Sna" +
      "pshotSourceH\000\022:\n\006volume\030\002 \001(\0132(.csi.v1.V" +
      "olumeContentSource.VolumeSourceH\000\032%\n\016Sna" +
      "pshotSource\022\023\n\013snapshot_id\030\001 \001(\t\032!\n\014Volu" +
      "meSource\022\021\n\tvolume_id\030\001 \001(\tB\006\n\004type\"6\n\024C" +
      "reateVolumeResponse\022\036\n\006volume\030\001 \001(\0132\016.cs" +
      "i.v1.Volume\"\366\003\n\020VolumeCapability\0225\n\005bloc" +
      "k\030\001 \001(\0132$.csi.v1.VolumeCapability.BlockV" +
      "olumeH\000\0225\n\005mount\030\002 \001(\0132$.csi.v1.VolumeCa" +
      "pability.MountVolumeH\000\0228\n\013access_mode\030\003 " +
      "\001(\0132#.csi.v1.VolumeCapability.AccessMode" +
      "\032\r\n\013BlockVolume\0323\n\013MountVolume\022\017\n\007fs_typ" +
      "e\030\001 \001(\t\022\023\n\013mount_flags\030\002 \003(\t\032\346\001\n\nAccessM" +
      "ode\0226\n\004mode\030\001 \001(\0162(.csi.v1.VolumeCapabil" +
      "ity.AccessMode.Mode\"\237\001\n\004Mode\022\013\n\007UNKNOWN\020" +
      "\000\022\026\n\022SINGLE_NODE_WRITER\020\001\022\033\n\027SINGLE_NODE" +
      "_READER_ONLY\020\002\022\032\n\026MULTI_NODE_READER_ONLY" +
      "\020\003\022\034\n\030MULTI_NODE_SINGLE_WRITER\020\004\022\033\n\027MULT" +
      "I_NODE_MULTI_WRITER\020\005B\r\n\013access_type\"<\n\r" +
      "CapacityRange\022\026\n\016required_bytes\030\001 \001(\003\022\023\n" +
      "\013limit_bytes\030\002 \001(\003\"\210\002\n\006Volume\022\026\n\016capacit" +
      "y_bytes\030\001 \001(\003\022\021\n\tvolume_id\030\002 \001(\t\0229\n\016volu" +
      "me_context\030\003 \003(\0132!.csi.v1.Volume.VolumeC" +
      "ontextEntry\0223\n\016content_source\030\004 \001(\0132\033.cs" +
      "i.v1.VolumeContentSource\022-\n\023accessible_t" +
      "opology\030\005 \003(\0132\020.csi.v1.Topology\0324\n\022Volum" +
      "eContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(" +
      "\t:\0028\001\"_\n\023TopologyRequirement\022#\n\trequisit" +
      "e\030\001 \003(\0132\020.csi.v1.Topology\022#\n\tpreferred\030\002" +
      " \003(\0132\020.csi.v1.Topology\"m\n\010Topology\0220\n\010se" +
      "gments\030\001 \003(\0132\036.csi.v1.Topology.SegmentsE" +
      "ntry\032/\n\rSegmentsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005va" +
      "lue\030\002 \001(\t:\0028\001\"\230\001\n\023DeleteVolumeRequest\022\021\n" +
      "\tvolume_id\030\001 \001(\t\022>\n\007secrets\030\002 \003(\0132(.csi." +
      "v1.DeleteVolumeRequest.SecretsEntryB\003\230B\001" +
      "\032.\n\014SecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002" +
      " \001(\t:\0028\001\"\026\n\024DeleteVolumeResponse\"\217\003\n\036Con" +
      "trollerPublishVolumeRequest\022\021\n\tvolume_id" +
      "\030\001 \001(\t\022\017\n\007node_id\030\002 \001(\t\0223\n\021volume_capabi" +
      "lity\030\003 \001(\0132\030.csi.v1.VolumeCapability\022\020\n\010" +
      "readonly\030\004 \001(\010\022I\n\007secrets\030\005 \003(\01323.csi.v1" +
      ".ControllerPublishVolumeRequest.SecretsE" +
      "ntryB\003\230B\001\022Q\n\016volume_context\030\006 \003(\01329.csi." +
      "v1.ControllerPublishVolumeRequest.Volume" +
      "ContextEntry\032.\n\014SecretsEntry\022\013\n\003key\030\001 \001(" +
      "\t\022\r\n\005value\030\002 \001(\t:\0028\001\0324\n\022VolumeContextEnt" +
      "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\256\001\n\037C" +
      "ontrollerPublishVolumeResponse\022T\n\017publis" +
      "h_context\030\001 \003(\0132;.csi.v1.ControllerPubli" +
      "shVolumeResponse.PublishContextEntry\0325\n\023" +
      "PublishContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu" +
      "e\030\002 \001(\t:\0028\001\"\303\001\n ControllerUnpublishVolum" +
      "eRequest\022\021\n\tvolume_id\030\001 \001(\t\022\017\n\007node_id\030\002" +
      " \001(\t\022K\n\007secrets\030\003 \003(\01325.csi.v1.Controlle" +
      "rUnpublishVolumeRequest.SecretsEntryB\003\230B" +
      "\001\032.\n\014SecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030" +
      "\002 \001(\t:\0028\001\"#\n!ControllerUnpublishVolumeRe" +
      "sponse\"\371\003\n!ValidateVolumeCapabilitiesReq" +
      "uest\022\021\n\tvolume_id\030\001 \001(\t\022T\n\016volume_contex" +
      "t\030\002 \003(\0132<.csi.v1.ValidateVolumeCapabilit" +
      "iesRequest.VolumeContextEntry\0225\n\023volume_" +
      "capabilities\030\003 \003(\0132\030.csi.v1.VolumeCapabi" +
      "lity\022M\n\nparameters\030\004 \003(\01329.csi.v1.Valida" +
      "teVolumeCapabilitiesRequest.ParametersEn" +
      "try\022L\n\007secrets\030\005 \003(\01326.csi.v1.ValidateVo" +
      "lumeCapabilitiesRequest.SecretsEntryB\003\230B" +
      "\001\0324\n\022VolumeContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005" +
      "value\030\002 \001(\t:\0028\001\0321\n\017ParametersEntry\022\013\n\003ke" +
      "y\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\032.\n\014SecretsEnt" +
      "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\347\003\n\"V" +
      "alidateVolumeCapabilitiesResponse\022G\n\tcon" +
      "firmed\030\001 \001(\01324.csi.v1.ValidateVolumeCapa" +
      "bilitiesResponse.Confirmed\022\017\n\007message\030\002 " +
      "\001(\t\032\346\002\n\tConfirmed\022_\n\016volume_context\030\001 \003(" +
      "\0132G.csi.v1.ValidateVolumeCapabilitiesRes" +
      "ponse.Confirmed.VolumeContextEntry\0225\n\023vo" +
      "lume_capabilities\030\002 \003(\0132\030.csi.v1.VolumeC" +
      "apability\022X\n\nparameters\030\003 \003(\0132D.csi.v1.V" +
      "alidateVolumeCapabilitiesResponse.Confir" +
      "med.ParametersEntry\0324\n\022VolumeContextEntr" +
      "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0321\n\017Par" +
      "ametersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t" +
      ":\0028\001\"A\n\022ListVolumesRequest\022\023\n\013max_entrie" +
      "s\030\001 \001(\005\022\026\n\016starting_token\030\002 \001(\t\"\206\001\n\023List" +
      "VolumesResponse\0222\n\007entries\030\001 \003(\0132!.csi.v" +
      "1.ListVolumesResponse.Entry\022\022\n\nnext_toke" +
      "n\030\002 \001(\t\032\'\n\005Entry\022\036\n\006volume\030\001 \001(\0132\016.csi.v" +
      "1.Volume\"\355\001\n\022GetCapacityRequest\0225\n\023volum" +
      "e_capabilities\030\001 \003(\0132\030.csi.v1.VolumeCapa" +
      "bility\022>\n\nparameters\030\002 \003(\0132*.csi.v1.GetC" +
      "apacityRequest.ParametersEntry\022-\n\023access" +
      "ible_topology\030\003 \001(\0132\020.csi.v1.Topology\0321\n" +
      "\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002" +
      " \001(\t:\0028\001\"1\n\023GetCapacityResponse\022\032\n\022avail" +
      "able_capacity\030\001 \001(\003\"\"\n ControllerGetCapa" +
      "bilitiesRequest\"^\n!ControllerGetCapabili" +
      "tiesResponse\0229\n\014capabilities\030\001 \003(\0132#.csi" +
      ".v1.ControllerServiceCapability\"\376\002\n\033Cont" +
      "rollerServiceCapability\0226\n\003rpc\030\001 \001(\0132\'.c" +
      "si.v1.ControllerServiceCapability.RPCH\000\032" +
      "\236\002\n\003RPC\022:\n\004type\030\001 \001(\0162,.csi.v1.Controlle" +
      "rServiceCapability.RPC.Type\"\332\001\n\004Type\022\013\n\007" +
      "UNKNOWN\020\000\022\030\n\024CREATE_DELETE_VOLUME\020\001\022\034\n\030P" +
      "UBLISH_UNPUBLISH_VOLUME\020\002\022\020\n\014LIST_VOLUME" +
      "S\020\003\022\020\n\014GET_CAPACITY\020\004\022\032\n\026CREATE_DELETE_S" +
      "NAPSHOT\020\005\022\022\n\016LIST_SNAPSHOTS\020\006\022\020\n\014CLONE_V" +
      "OLUME\020\007\022\024\n\020PUBLISH_READONLY\020\010\022\021\n\rEXPAND_" +
      "VOLUME\020\tB\006\n\004type\"\247\002\n\025CreateSnapshotReque" +
      "st\022\030\n\020source_volume_id\030\001 \001(\t\022\014\n\004name\030\002 \001" +
      "(\t\022@\n\007secrets\030\003 \003(\0132*.csi.v1.CreateSnaps" +
      "hotRequest.SecretsEntryB\003\230B\001\022A\n\nparamete" +
      "rs\030\004 \003(\0132-.csi.v1.CreateSnapshotRequest." +
      "ParametersEntry\032.\n\014SecretsEntry\022\013\n\003key\030\001" +
      " \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0321\n\017ParametersEnt" +
      "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"<\n\026Cr" +
      "eateSnapshotResponse\022\"\n\010snapshot\030\001 \001(\0132\020" +
      ".csi.v1.Snapshot\"\226\001\n\010Snapshot\022\022\n\nsize_by" +
      "tes\030\001 \001(\003\022\023\n\013snapshot_id\030\002 \001(\t\022\030\n\020source" +
      "_volume_id\030\003 \001(\t\0221\n\rcreation_time\030\004 \001(\0132" +
      "\032.google.protobuf.Timestamp\022\024\n\014ready_to_" +
      "use\030\005 \001(\010\"\236\001\n\025DeleteSnapshotRequest\022\023\n\013s" +
      "napshot_id\030\001 \001(\t\022@\n\007secrets\030\002 \003(\0132*.csi." +
      "v1.DeleteSnapshotRequest.SecretsEntryB\003\230" +
      "B\001\032.\n\014SecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value" +
      "\030\002 \001(\t:\0028\001\"\030\n\026DeleteSnapshotResponse\"r\n\024" +
      "ListSnapshotsRequest\022\023\n\013max_entries\030\001 \001(" +
      "\005\022\026\n\016starting_token\030\002 \001(\t\022\030\n\020source_volu" +
      "me_id\030\003 \001(\t\022\023\n\013snapshot_id\030\004 \001(\t\"\216\001\n\025Lis" +
      "tSnapshotsResponse\0224\n\007entries\030\001 \003(\0132#.cs" +
      "i.v1.ListSnapshotsResponse.Entry\022\022\n\nnext" +
      "_token\030\002 \001(\t\032+\n\005Entry\022\"\n\010snapshot\030\001 \001(\0132" +
      "\020.csi.v1.Snapshot\"\333\001\n\035ControllerExpandVo" +
      "lumeRequest\022\021\n\tvolume_id\030\001 \001(\t\022-\n\016capaci" +
      "ty_range\030\002 \001(\0132\025.csi.v1.CapacityRange\022H\n" +
      "\007secrets\030\003 \003(\01322.csi.v1.ControllerExpand" +
      "VolumeRequest.SecretsEntryB\003\230B\001\032.\n\014Secre" +
      "tsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"" +
      "Y\n\036ControllerExpandVolumeResponse\022\026\n\016cap" +
      "acity_bytes\030\001 \001(\003\022\037\n\027node_expansion_requ" +
      "ired\030\002 \001(\010\"\365\003\n\026NodeStageVolumeRequest\022\021\n" +
      "\tvolume_id\030\001 \001(\t\022K\n\017publish_context\030\002 \003(" +
      "\01322.csi.v1.NodeStageVolumeRequest.Publis" +
      "hContextEntry\022\033\n\023staging_target_path\030\003 \001" +
      "(\t\0223\n\021volume_capability\030\004 \001(\0132\030.csi.v1.V" +
      "olumeCapability\022A\n\007secrets\030\005 \003(\0132+.csi.v" +
      "1.NodeStageVolumeRequest.SecretsEntryB\003\230" +
      "B\001\022I\n\016volume_context\030\006 \003(\01321.csi.v1.Node" +
      "StageVolumeRequest.VolumeContextEntry\0325\n" +
      "\023PublishContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005val" +
      "ue\030\002 \001(\t:\0028\001\032.\n\014SecretsEntry\022\013\n\003key\030\001 \001(" +
      "\t\022\r\n\005value\030\002 \001(\t:\0028\001\0324\n\022VolumeContextEnt" +
      "ry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\031\n\027No" +
      "deStageVolumeResponse\"J\n\030NodeUnstageVolu" +
      "meRequest\022\021\n\tvolume_id\030\001 \001(\t\022\033\n\023staging_" +
      "target_path\030\002 \001(\t\"\033\n\031NodeUnstageVolumeRe" +
      "sponse\"\244\004\n\030NodePublishVolumeRequest\022\021\n\tv" +
      "olume_id\030\001 \001(\t\022M\n\017publish_context\030\002 \003(\0132" +
      "4.csi.v1.NodePublishVolumeRequest.Publis" +
      "hContextEntry\022\033\n\023staging_target_path\030\003 \001" +
      "(\t\022\023\n\013target_path\030\004 \001(\t\0223\n\021volume_capabi" +
      "lity\030\005 \001(\0132\030.csi.v1.VolumeCapability\022\020\n\010" +
      "readonly\030\006 \001(\010\022C\n\007secrets\030\007 \003(\0132-.csi.v1" +
      ".NodePublishVolumeRequest.SecretsEntryB\003" +
      "\230B\001\022K\n\016volume_context\030\010 \003(\01323.csi.v1.Nod" +
      "ePublishVolumeRequest.VolumeContextEntry" +
      "\0325\n\023PublishContextEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005" +
      "value\030\002 \001(\t:\0028\001\032.\n\014SecretsEntry\022\013\n\003key\030\001" +
      " \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0324\n\022VolumeContext" +
      "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\033\n" +
      "\031NodePublishVolumeResponse\"D\n\032NodeUnpubl" +
      "ishVolumeRequest\022\021\n\tvolume_id\030\001 \001(\t\022\023\n\013t" +
      "arget_path\030\002 \001(\t\"\035\n\033NodeUnpublishVolumeR" +
      "esponse\"C\n\031NodeGetVolumeStatsRequest\022\021\n\t" +
      "volume_id\030\001 \001(\t\022\023\n\013volume_path\030\002 \001(\t\"@\n\032" +
      "NodeGetVolumeStatsResponse\022\"\n\005usage\030\001 \003(" +
      "\0132\023.csi.v1.VolumeUsage\"\221\001\n\013VolumeUsage\022\021" +
      "\n\tavailable\030\001 \001(\003\022\r\n\005total\030\002 \001(\003\022\014\n\004used" +
      "\030\003 \001(\003\022&\n\004unit\030\004 \001(\0162\030.csi.v1.VolumeUsag" +
      "e.Unit\"*\n\004Unit\022\013\n\007UNKNOWN\020\000\022\t\n\005BYTES\020\001\022\n" +
      "\n\006INODES\020\002\"\034\n\032NodeGetCapabilitiesRequest" +
      "\"R\n\033NodeGetCapabilitiesResponse\0223\n\014capab" +
      "ilities\030\001 \003(\0132\035.csi.v1.NodeServiceCapabi" +
      "lity\"\347\001\n\025NodeServiceCapability\0220\n\003rpc\030\001 " +
      "\001(\0132!.csi.v1.NodeServiceCapability.RPCH\000" +
      "\032\223\001\n\003RPC\0224\n\004type\030\001 \001(\0162&.csi.v1.NodeServ" +
      "iceCapability.RPC.Type\"V\n\004Type\022\013\n\007UNKNOW" +
      "N\020\000\022\030\n\024STAGE_UNSTAGE_VOLUME\020\001\022\024\n\020GET_VOL" +
      "UME_STATS\020\002\022\021\n\rEXPAND_VOLUME\020\003B\006\n\004type\"\024" +
      "\n\022NodeGetInfoRequest\"s\n\023NodeGetInfoRespo" +
      "nse\022\017\n\007node_id\030\001 \001(\t\022\034\n\024max_volumes_per_" +
      "node\030\002 \001(\003\022-\n\023accessible_topology\030\003 \001(\0132" +
      "\020.csi.v1.Topology\"p\n\027NodeExpandVolumeReq" +
      "uest\022\021\n\tvolume_id\030\001 \001(\t\022\023\n\013volume_path\030\002" +
      " \001(\t\022-\n\016capacity_range\030\003 \001(\0132\025.csi.v1.Ca" +
      "pacityRange\"2\n\030NodeExpandVolumeResponse\022" +
      "\026\n\016capacity_bytes\030\001 \001(\0032\372\001\n\010Identity\022N\n\r" +
      "GetPluginInfo\022\034.csi.v1.GetPluginInfoRequ" +
      "est\032\035.csi.v1.GetPluginInfoResponse\"\000\022f\n\025" +
      "GetPluginCapabilities\022$.csi.v1.GetPlugin" +
      "CapabilitiesRequest\032%.csi.v1.GetPluginCa" +
      "pabilitiesResponse\"\000\0226\n\005Probe\022\024.csi.v1.P" +
      "robeRequest\032\025.csi.v1.ProbeResponse\"\0002\350\010\n" +
      "\nController\022K\n\014CreateVolume\022\033.csi.v1.Cre" +
      "ateVolumeRequest\032\034.csi.v1.CreateVolumeRe" +
      "sponse\"\000\022K\n\014DeleteVolume\022\033.csi.v1.Delete" +
      "VolumeRequest\032\034.csi.v1.DeleteVolumeRespo" +
      "nse\"\000\022l\n\027ControllerPublishVolume\022&.csi.v" +
      "1.ControllerPublishVolumeRequest\032\'.csi.v" +
      "1.ControllerPublishVolumeResponse\"\000\022r\n\031C" +
      "ontrollerUnpublishVolume\022(.csi.v1.Contro" +
      "llerUnpublishVolumeRequest\032).csi.v1.Cont" +
      "rollerUnpublishVolumeResponse\"\000\022u\n\032Valid" +
      "ateVolumeCapabilities\022).csi.v1.ValidateV" +
      "olumeCapabilitiesRequest\032*.csi.v1.Valida" +
      "teVolumeCapabilitiesResponse\"\000\022H\n\013ListVo" +
      "lumes\022\032.csi.v1.ListVolumesRequest\032\033.csi." +
      "v1.ListVolumesResponse\"\000\022H\n\013GetCapacity\022" +
      "\032.csi.v1.GetCapacityRequest\032\033.csi.v1.Get" +
      "CapacityResponse\"\000\022r\n\031ControllerGetCapab" +
      "ilities\022(.csi.v1.ControllerGetCapabiliti" +
      "esRequest\032).csi.v1.ControllerGetCapabili" +
      "tiesResponse\"\000\022Q\n\016CreateSnapshot\022\035.csi.v" +
      "1.CreateSnapshotRequest\032\036.csi.v1.CreateS" +
      "napshotResponse\"\000\022Q\n\016DeleteSnapshot\022\035.cs" +
      "i.v1.DeleteSnapshotRequest\032\036.csi.v1.Dele" +
      "teSnapshotResponse\"\000\022N\n\rListSnapshots\022\034." +
      "csi.v1.ListSnapshotsRequest\032\035.csi.v1.Lis" +
      "tSnapshotsResponse\"\000\022i\n\026ControllerExpand" +
      "Volume\022%.csi.v1.ControllerExpandVolumeRe" +
      "quest\032&.csi.v1.ControllerExpandVolumeRes" +
      "ponse\"\0002\332\005\n\004Node\022T\n\017NodeStageVolume\022\036.cs" +
      "i.v1.NodeStageVolumeRequest\032\037.csi.v1.Nod" +
      "eStageVolumeResponse\"\000\022Z\n\021NodeUnstageVol" +
      "ume\022 .csi.v1.NodeUnstageVolumeRequest\032!." +
      "csi.v1.NodeUnstageVolumeResponse\"\000\022Z\n\021No" +
      "dePublishVolume\022 .csi.v1.NodePublishVolu" +
      "meRequest\032!.csi.v1.NodePublishVolumeResp" +
      "onse\"\000\022`\n\023NodeUnpublishVolume\022\".csi.v1.N" +
      "odeUnpublishVolumeRequest\032#.csi.v1.NodeU" +
      "npublishVolumeResponse\"\000\022]\n\022NodeGetVolum" +
      "eStats\022!.csi.v1.NodeGetVolumeStatsReques" +
      "t\032\".csi.v1.NodeGetVolumeStatsResponse\"\000\022" +
      "W\n\020NodeExpandVolume\022\037.csi.v1.NodeExpandV" +
      "olumeRequest\032 .csi.v1.NodeExpandVolumeRe" +
      "sponse\"\000\022`\n\023NodeGetCapabilities\022\".csi.v1" +
      ".NodeGetCapabilitiesRequest\032#.csi.v1.Nod" +
      "eGetCapabilitiesResponse\"\000\022H\n\013NodeGetInf" +
      "o\022\032.csi.v1.NodeGetInfoRequest\032\033.csi.v1.N" +
      "odeGetInfoResponse\"\000:2\n\ncsi_secret\022\035.goo" +
      "gle.protobuf.FieldOptions\030\243\010 \001(\010B\005Z\003csib" +
      "\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.DescriptorProtos.getDescriptor(),
          com.google.protobuf.TimestampProto.getDescriptor(),
          com.google.protobuf.WrappersProto.getDescriptor(),
        }, assigner);
    internal_static_csi_v1_GetPluginInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_csi_v1_GetPluginInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetPluginInfoRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_GetPluginInfoResponse_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_csi_v1_GetPluginInfoResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetPluginInfoResponse_descriptor,
        new java.lang.String[] { "Name", "VendorVersion", "Manifest", });
    internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_descriptor =
      internal_static_csi_v1_GetPluginInfoResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetPluginInfoResponse_ManifestEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_csi_v1_GetPluginCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetPluginCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_csi_v1_GetPluginCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetPluginCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v1_PluginCapability_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_csi_v1_PluginCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_PluginCapability_descriptor,
        new java.lang.String[] { "Service", "VolumeExpansion", "Type", });
    internal_static_csi_v1_PluginCapability_Service_descriptor =
      internal_static_csi_v1_PluginCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_PluginCapability_Service_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_PluginCapability_Service_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor =
      internal_static_csi_v1_PluginCapability_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_PluginCapability_VolumeExpansion_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_PluginCapability_VolumeExpansion_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ProbeRequest_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_csi_v1_ProbeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ProbeRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ProbeResponse_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_csi_v1_ProbeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ProbeResponse_descriptor,
        new java.lang.String[] { "Ready", });
    internal_static_csi_v1_CreateVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_csi_v1_CreateVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateVolumeRequest_descriptor,
        new java.lang.String[] { "Name", "CapacityRange", "VolumeCapabilities", "Parameters", "Secrets", "VolumeContentSource", "AccessibilityRequirements", });
    internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_descriptor =
      internal_static_csi_v1_CreateVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateVolumeRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_CreateVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_VolumeContentSource_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_csi_v1_VolumeContentSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeContentSource_descriptor,
        new java.lang.String[] { "Snapshot", "Volume", "Type", });
    internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor =
      internal_static_csi_v1_VolumeContentSource_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_VolumeContentSource_SnapshotSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeContentSource_SnapshotSource_descriptor,
        new java.lang.String[] { "SnapshotId", });
    internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor =
      internal_static_csi_v1_VolumeContentSource_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_VolumeContentSource_VolumeSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeContentSource_VolumeSource_descriptor,
        new java.lang.String[] { "VolumeId", });
    internal_static_csi_v1_CreateVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_csi_v1_CreateVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateVolumeResponse_descriptor,
        new java.lang.String[] { "Volume", });
    internal_static_csi_v1_VolumeCapability_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_csi_v1_VolumeCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeCapability_descriptor,
        new java.lang.String[] { "Block", "Mount", "AccessMode", "AccessType", });
    internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor =
      internal_static_csi_v1_VolumeCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_VolumeCapability_BlockVolume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeCapability_BlockVolume_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_VolumeCapability_MountVolume_descriptor =
      internal_static_csi_v1_VolumeCapability_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_VolumeCapability_MountVolume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeCapability_MountVolume_descriptor,
        new java.lang.String[] { "FsType", "MountFlags", });
    internal_static_csi_v1_VolumeCapability_AccessMode_descriptor =
      internal_static_csi_v1_VolumeCapability_descriptor.getNestedTypes().get(2);
    internal_static_csi_v1_VolumeCapability_AccessMode_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeCapability_AccessMode_descriptor,
        new java.lang.String[] { "Mode", });
    internal_static_csi_v1_CapacityRange_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_csi_v1_CapacityRange_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CapacityRange_descriptor,
        new java.lang.String[] { "RequiredBytes", "LimitBytes", });
    internal_static_csi_v1_Volume_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_csi_v1_Volume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_Volume_descriptor,
        new java.lang.String[] { "CapacityBytes", "VolumeId", "VolumeContext", "ContentSource", "AccessibleTopology", });
    internal_static_csi_v1_Volume_VolumeContextEntry_descriptor =
      internal_static_csi_v1_Volume_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_Volume_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_Volume_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_TopologyRequirement_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_csi_v1_TopologyRequirement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_TopologyRequirement_descriptor,
        new java.lang.String[] { "Requisite", "Preferred", });
    internal_static_csi_v1_Topology_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_csi_v1_Topology_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_Topology_descriptor,
        new java.lang.String[] { "Segments", });
    internal_static_csi_v1_Topology_SegmentsEntry_descriptor =
      internal_static_csi_v1_Topology_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_Topology_SegmentsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_Topology_SegmentsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_DeleteVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_csi_v1_DeleteVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "Secrets", });
    internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_DeleteVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_DeleteVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_csi_v1_DeleteVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_csi_v1_ControllerPublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "NodeId", "VolumeCapability", "Readonly", "Secrets", "VolumeContext", });
    internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerPublishVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_descriptor =
      internal_static_csi_v1_ControllerPublishVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerPublishVolumeRequest_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_csi_v1_ControllerPublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor,
        new java.lang.String[] { "PublishContext", });
    internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_descriptor =
      internal_static_csi_v1_ControllerPublishVolumeResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerPublishVolumeResponse_PublishContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "NodeId", "Secrets", });
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_ControllerUnpublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerUnpublishVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_csi_v1_ControllerUnpublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerUnpublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor,
        new java.lang.String[] { "VolumeId", "VolumeContext", "VolumeCapabilities", "Parameters", "Secrets", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_descriptor.getNestedTypes().get(2);
    internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Confirmed", "Message", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor,
        new java.lang.String[] { "VolumeContext", "VolumeCapabilities", "Parameters", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_descriptor =
      internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ListVolumesRequest_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_csi_v1_ListVolumesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListVolumesRequest_descriptor,
        new java.lang.String[] { "MaxEntries", "StartingToken", });
    internal_static_csi_v1_ListVolumesResponse_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_csi_v1_ListVolumesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListVolumesResponse_descriptor,
        new java.lang.String[] { "Entries", "NextToken", });
    internal_static_csi_v1_ListVolumesResponse_Entry_descriptor =
      internal_static_csi_v1_ListVolumesResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ListVolumesResponse_Entry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListVolumesResponse_Entry_descriptor,
        new java.lang.String[] { "Volume", });
    internal_static_csi_v1_GetCapacityRequest_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_csi_v1_GetCapacityRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetCapacityRequest_descriptor,
        new java.lang.String[] { "VolumeCapabilities", "Parameters", "AccessibleTopology", });
    internal_static_csi_v1_GetCapacityRequest_ParametersEntry_descriptor =
      internal_static_csi_v1_GetCapacityRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_GetCapacityRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetCapacityRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_GetCapacityResponse_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_csi_v1_GetCapacityResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_GetCapacityResponse_descriptor,
        new java.lang.String[] { "AvailableCapacity", });
    internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_csi_v1_ControllerGetCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerGetCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_csi_v1_ControllerGetCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerGetCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v1_ControllerServiceCapability_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_csi_v1_ControllerServiceCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerServiceCapability_descriptor,
        new java.lang.String[] { "Rpc", "Type", });
    internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor =
      internal_static_csi_v1_ControllerServiceCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ControllerServiceCapability_RPC_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerServiceCapability_RPC_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v1_CreateSnapshotRequest_descriptor =
      getDescriptor().getMessageTypes().get(30);
    internal_static_csi_v1_CreateSnapshotRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateSnapshotRequest_descriptor,
        new java.lang.String[] { "SourceVolumeId", "Name", "Secrets", "Parameters", });
    internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_CreateSnapshotRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateSnapshotRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_descriptor =
      internal_static_csi_v1_CreateSnapshotRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateSnapshotRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_CreateSnapshotResponse_descriptor =
      getDescriptor().getMessageTypes().get(31);
    internal_static_csi_v1_CreateSnapshotResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_CreateSnapshotResponse_descriptor,
        new java.lang.String[] { "Snapshot", });
    internal_static_csi_v1_Snapshot_descriptor =
      getDescriptor().getMessageTypes().get(32);
    internal_static_csi_v1_Snapshot_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_Snapshot_descriptor,
        new java.lang.String[] { "SizeBytes", "SnapshotId", "SourceVolumeId", "CreationTime", "ReadyToUse", });
    internal_static_csi_v1_DeleteSnapshotRequest_descriptor =
      getDescriptor().getMessageTypes().get(33);
    internal_static_csi_v1_DeleteSnapshotRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteSnapshotRequest_descriptor,
        new java.lang.String[] { "SnapshotId", "Secrets", });
    internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_DeleteSnapshotRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteSnapshotRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_DeleteSnapshotResponse_descriptor =
      getDescriptor().getMessageTypes().get(34);
    internal_static_csi_v1_DeleteSnapshotResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_DeleteSnapshotResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_ListSnapshotsRequest_descriptor =
      getDescriptor().getMessageTypes().get(35);
    internal_static_csi_v1_ListSnapshotsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListSnapshotsRequest_descriptor,
        new java.lang.String[] { "MaxEntries", "StartingToken", "SourceVolumeId", "SnapshotId", });
    internal_static_csi_v1_ListSnapshotsResponse_descriptor =
      getDescriptor().getMessageTypes().get(36);
    internal_static_csi_v1_ListSnapshotsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListSnapshotsResponse_descriptor,
        new java.lang.String[] { "Entries", "NextToken", });
    internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor =
      internal_static_csi_v1_ListSnapshotsResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ListSnapshotsResponse_Entry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ListSnapshotsResponse_Entry_descriptor,
        new java.lang.String[] { "Snapshot", });
    internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(37);
    internal_static_csi_v1_ControllerExpandVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "CapacityRange", "Secrets", });
    internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_ControllerExpandVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerExpandVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(38);
    internal_static_csi_v1_ControllerExpandVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_ControllerExpandVolumeResponse_descriptor,
        new java.lang.String[] { "CapacityBytes", "NodeExpansionRequired", });
    internal_static_csi_v1_NodeStageVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(39);
    internal_static_csi_v1_NodeStageVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeStageVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "PublishContext", "StagingTargetPath", "VolumeCapability", "Secrets", "VolumeContext", });
    internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_descriptor =
      internal_static_csi_v1_NodeStageVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeStageVolumeRequest_PublishContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_NodeStageVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeStageVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_descriptor =
      internal_static_csi_v1_NodeStageVolumeRequest_descriptor.getNestedTypes().get(2);
    internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeStageVolumeRequest_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodeStageVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(40);
    internal_static_csi_v1_NodeStageVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeStageVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(41);
    internal_static_csi_v1_NodeUnstageVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeUnstageVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "StagingTargetPath", });
    internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(42);
    internal_static_csi_v1_NodeUnstageVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeUnstageVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodePublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(43);
    internal_static_csi_v1_NodePublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodePublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "PublishContext", "StagingTargetPath", "TargetPath", "VolumeCapability", "Readonly", "Secrets", "VolumeContext", });
    internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_descriptor =
      internal_static_csi_v1_NodePublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodePublishVolumeRequest_PublishContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_descriptor =
      internal_static_csi_v1_NodePublishVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodePublishVolumeRequest_SecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_descriptor =
      internal_static_csi_v1_NodePublishVolumeRequest_descriptor.getNestedTypes().get(2);
    internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodePublishVolumeRequest_VolumeContextEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v1_NodePublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(44);
    internal_static_csi_v1_NodePublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodePublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(45);
    internal_static_csi_v1_NodeUnpublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeUnpublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "TargetPath", });
    internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(46);
    internal_static_csi_v1_NodeUnpublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeUnpublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor =
      getDescriptor().getMessageTypes().get(47);
    internal_static_csi_v1_NodeGetVolumeStatsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetVolumeStatsRequest_descriptor,
        new java.lang.String[] { "VolumeId", "VolumePath", });
    internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor =
      getDescriptor().getMessageTypes().get(48);
    internal_static_csi_v1_NodeGetVolumeStatsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetVolumeStatsResponse_descriptor,
        new java.lang.String[] { "Usage", });
    internal_static_csi_v1_VolumeUsage_descriptor =
      getDescriptor().getMessageTypes().get(49);
    internal_static_csi_v1_VolumeUsage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_VolumeUsage_descriptor,
        new java.lang.String[] { "Available", "Total", "Used", "Unit", });
    internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(50);
    internal_static_csi_v1_NodeGetCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(51);
    internal_static_csi_v1_NodeGetCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v1_NodeServiceCapability_descriptor =
      getDescriptor().getMessageTypes().get(52);
    internal_static_csi_v1_NodeServiceCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeServiceCapability_descriptor,
        new java.lang.String[] { "Rpc", "Type", });
    internal_static_csi_v1_NodeServiceCapability_RPC_descriptor =
      internal_static_csi_v1_NodeServiceCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v1_NodeServiceCapability_RPC_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeServiceCapability_RPC_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v1_NodeGetInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(53);
    internal_static_csi_v1_NodeGetInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetInfoRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v1_NodeGetInfoResponse_descriptor =
      getDescriptor().getMessageTypes().get(54);
    internal_static_csi_v1_NodeGetInfoResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeGetInfoResponse_descriptor,
        new java.lang.String[] { "NodeId", "MaxVolumesPerNode", "AccessibleTopology", });
    internal_static_csi_v1_NodeExpandVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(55);
    internal_static_csi_v1_NodeExpandVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeExpandVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "VolumePath", "CapacityRange", });
    internal_static_csi_v1_NodeExpandVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(56);
    internal_static_csi_v1_NodeExpandVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v1_NodeExpandVolumeResponse_descriptor,
        new java.lang.String[] { "CapacityBytes", });
    csiSecret.internalInit(descriptor.getExtensions().get(0));
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(csi.v1.Csi.csiSecret);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    com.google.protobuf.DescriptorProtos.getDescriptor();
    com.google.protobuf.TimestampProto.getDescriptor();
    com.google.protobuf.WrappersProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
